###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Nov/2018  13:52:16
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack
#        Mesh 1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\stack\zcl\zcl.c" -D FEATURE_SYSTEM_STATS -D
#        POWER_SAVING -lC "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" --diag_suppress
#        Pe001,Pa010 -o "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e --no_code_motion
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\zcl.lst
#    Object file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj\zcl.r51
#
###############################################################################

D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh 1.0.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2014-06-25 18:07:01 -0700 (Wed, 25 Jun 2014) $
      4            Revision:       $Revision: 39221 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Command record list
    104          typedef struct zclCmdRecsList
    105          {
    106            struct zclCmdRecsList *pNext;
    107            uint8                 endpoint;
    108            uint8                 numCommands;
    109            CONST zclCommandRec_t *pCmdRecs;
    110          } zclCmdRecsList_t;
    111          
    112          // Attribute record list item
    113          typedef struct zclAttrRecsList
    114          {
    115            struct zclAttrRecsList *next;
    116            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    117            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    118            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    119            uint8                  numAttributes; // Number of the following records
    120            CONST zclAttrRec_t     *attrs;        // attribute records
    121          } zclAttrRecsList;
    122          
    123          // Cluster option list item
    124          typedef struct zclClusterOptionList
    125          {
    126            struct zclClusterOptionList *next;
    127            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    128            uint8                       numOptions; // Number of the following records
    129            zclOptionRec_t              *options;   // option records
    130          } zclClusterOptionList;
    131          
    132          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    133          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    134          
    135          typedef struct
    136          {
    137            zclParseInProfileCmd_t   pfnParseInProfile;
    138            zclProcessInProfileCmd_t pfnProcessInProfile;
    139          } zclCmdItems_t;
    140          
    141          
    142          /*********************************************************************
    143           * GLOBAL VARIABLES
    144           */
    145          
    146          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    148          
    149            // The task Id of the Application where the unprocessed Foundation
    150            // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    151            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    152          #endif
    153          
    154          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    155          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    156          
    157          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    158          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    159          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    161          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    162          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    163          
    164          /*********************************************************************
    165           * EXTERNAL VARIABLES
    166           */
    167          
    168          /*********************************************************************
    169           * EXTERNAL FUNCTIONS
    170           */
    171          
    172          /*********************************************************************
    173           * LOCAL VARIABLES
    174           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    175          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    176          
    177          #if defined ( ZCL_DISCOVER )
    178            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    179          #endif
    180          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    182          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    183          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    184          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    185          
    186          /*********************************************************************
    187           * LOCAL FUNCTIONS
    188           */
    189          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    190          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    191          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    192          
    193          #if defined ( ZCL_DISCOVER )
    194            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    195          #endif
    196          
    197          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    198          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    199          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    200          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    201          
    202          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    203          
    204          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    205          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    206          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    207          #endif // ZCL_READ || ZCL_WRITE
    208          
    209          #ifdef ZCL_READ
    210          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    211          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    212          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    213                                                   uint8 *pAttrData, uint16 *pDataLen );
    214          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    215          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    216          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    217          #endif // ZCL_READ
    218          
    219          #ifdef ZCL_WRITE
    220          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    221                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    222          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    223                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    224          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    225          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    226          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    227          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    228          #endif // ZCL_WRITE
    229          
    230          #ifdef ZCL_REPORT
    231          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    232          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    233          #endif // ZCL_REPORT
    234          
    235          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    236          
    237          #ifdef ZCL_DISCOVER
    238          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    239          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    240          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    241          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    242          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    243          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    244          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    245          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    246          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    247          #endif // ZCL_DISCOVER
    248          
    249          /*********************************************************************
    250           * Parse Profile Command Function Table
    251           */
    252          

   \                                 In  segment CODE_C, align 1
    253          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   0000         DW 0H
   \   000002   0000         DW 0H
   \   000004   0000         DW 0H
   \   000006   0000         DW 0H
   \   000008   0000         DW 0H
   \   00000A   0000         DW 0H
   \   00000C   0000         DW 0H
   \   00000E   0000         DW 0H
   \   000010   0000         DW 0H
   \   000012   0000         DW 0H
   \   000014   0000         DW 0H
   \   000016   0000         DW 0H
   \   000018   0000         DW 0H
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   0000         DW 0H
   \   000022   0000         DW 0H
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    254          {
    255          #ifdef ZCL_READ
    256            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    257            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    258          #else
    259            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    260            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    261          #endif // ZCL_READ
    262          
    263          #ifdef ZCL_WRITE
    264            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    265            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    266            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    267            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    268          #else
    269            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    270            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    271            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    272            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    273          #endif // ZCL_WRITE
    274          
    275          #ifdef ZCL_REPORT
    276            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    277            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    278            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    279            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    280            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    281          #else
    282            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    283            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287          #endif // ZCL_REPORT
    288          
    289            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    290          
    291          #ifdef ZCL_DISCOVER
    292            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    293            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    294            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    295            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    296            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    297            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    298            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    299            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    300            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    301            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    302            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    303          #else
    304            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    305            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    306            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    307            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    308            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    309            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    310            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    313            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    314            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    315          #endif // ZCL_DISCOVER
    316          };
    317          
    318          /*********************************************************************
    319           * PUBLIC FUNCTIONS
    320           *********************************************************************/
    321          
    322          #if !defined ( ZCL_STANDALONE )
    323          /*********************************************************************
    324           * @fn          zcl_Init
    325           *
    326           * @brief       Initialization function for the zcl layer.
    327           *
    328           * @param       task_id - ZCL task id
    329           *
    330           * @return      none
    331           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    332          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    333          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    334            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    335          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    336          #endif
    337          
    338          #if !defined ( ZCL_STANDALONE )
    339          /*********************************************************************
    340           * @fn          zcl_event_loop
    341           *
    342           * @brief       Event Loop Processor for zcl.
    343           *
    344           * @param       task_id - task id
    345           * @param       events - event bitmap
    346           *
    347           * @return      unprocessed events
    348           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    349          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    350          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    351            uint8 *msgPtr;
    352          
    353            (void)task_id;  // Intentionally unreferenced parameter
    354          
    355            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    356            {
    357              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    358              while ( msgPtr != NULL )
    359              {
    360                uint8 dealloc = TRUE;
    361          
    362                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    363                {
    364                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    365                }
    366                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    367                {
    368                  // send it to another task to process.
    369                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    370                  dealloc = FALSE;
    371                }
    372          
    373                // Release the memory
    374                if ( dealloc )
    375                {
    376                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    377                }
    378          
    379                // Next
    380                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    381              }
    382          
    383              // return unprocessed events
    384              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0
   \   00004F   E5..         MOV     A,?V1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    385            }
    386          
    387            // Discard unknown events
    388            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    390          #endif
    391          
    392          #if !defined ( ZCL_STANDALONE )
    393          /*********************************************************************
    394           * @fn      zcl_registerForMsg
    395           *
    396           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    397           *          messages that aren't processed to one task (if a task is
    398           *          registered).
    399           *
    400           * @param   taskId - task Id of the Application where commands will be sent to
    401           *
    402           * @return  TRUE if task registeration successful, FALSE otherwise
    403           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    404          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    405          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    406            // Allow only the first task
    407            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    408            {
    409              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    410          
    411              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    412            }
    413          
    414            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    415          }
    416          #endif
    417          
    418          #if !defined ( ZCL_STANDALONE )
    419          /*********************************************************************
    420           * @fn      zcl_HandleExternal
    421           *
    422           * @brief
    423           *
    424           * @param   pInMsg - incoming message to process
    425           *
    426           * @return  TRUE
    427           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    428          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    429          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    430            zclIncomingMsg_t *pCmd;
    431          
    432            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    433            {
    434              return ( TRUE );
    435            }
    436          
    437            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    438            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    439            {
    440              // fill in the message
    441              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   7434         MOV     A,#0x34
   \   000027   12....       LCALL   ?Subroutine11 & 0xFFFF
    442              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_10:
   \   00002A   A3           INC     DPTR
   \   00002B   EA           MOV     A,R2
   \   00002C   2402         ADD     A,#0x2
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   3B           ADDC    A,R3
   \   000031   FD           MOV     R5,A
   \   000032   7406         MOV     A,#0x6
   \   000034   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    443              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00003E   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   EC           MOV     A,R4
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   ED           MOV     A,R5
   \   000051   12....       LCALL   ?Subroutine10 & 0xFFFF
    444              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_8:
   \   000054   A3           INC     DPTR
   \   000055   EA           MOV     A,R2
   \   000056   240A         ADD     A,#0xa
   \   000058   FC           MOV     R4,A
   \   000059   E4           CLR     A
   \   00005A   3B           ADDC    A,R3
   \   00005B   FD           MOV     R5,A
   \   00005C   740C         MOV     A,#0xc
   \   00005E   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    445              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000061   8E82         MOV     DPL,R6
   \   000063   8F83         MOV     DPH,R7
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F8           MOV     R0,A
   \   000067   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00006A   C0E0         PUSH    A
   \   00006C   EA           MOV     A,R2
   \   00006D   2416         ADD     A,#0x16
   \   00006F   F582         MOV     DPL,A
   \   000071   E4           CLR     A
   \   000072   3B           ADDC    A,R3
   \   000073   F583         MOV     DPH,A
   \   000075   D0E0         POP     A
   \   000077   F0           MOVX    @DPTR,A
    446              pCmd->attrCmd   = pInMsg->attrCmd;
   \   000078   EE           MOV     A,R6
   \   000079   240C         ADD     A,#0xc
   \   00007B   F8           MOV     R0,A
   \   00007C   E4           CLR     A
   \   00007D   3F           ADDC    A,R7
   \   00007E   F9           MOV     R1,A
   \   00007F   8882         MOV     DPL,R0
   \   000081   8983         MOV     DPH,R1
   \   000083   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000086   EA           MOV     A,R2
   \   000087   2417         ADD     A,#0x17
   \   000089   F582         MOV     DPL,A
   \   00008B   E4           CLR     A
   \   00008C   3B           ADDC    A,R3
   \   00008D   F583         MOV     DPH,A
   \   00008F   EC           MOV     A,R4
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   ED           MOV     A,R5
   \   000093   F0           MOVX    @DPTR,A
    447          
    448              // Application will free the attrCmd buffer
    449              pInMsg->attrCmd = NULL;
   \   000094   8882         MOV     DPL,R0
   \   000096   8983         MOV     DPH,R1
   \   000098   E4           CLR     A
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   F0           MOVX    @DPTR,A
    450          
    451              /* send message through task message */
    452              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   00009C                ; Setup parameters for call to function osal_msg_send
   \   00009C   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   F9           MOV     R1,A
   \   0000A1   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    453            }
    454          
    455            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000A4   7901         MOV     R1,#0x1
   \   0000A6   02....       LJMP    ?Subroutine2 & 0xFFFF
    456          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine51_0
   \   000004                ; // Fall through to label ??Subroutine51_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   2414         ADD     A,#0x14
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   38           ADDC    A,R0
   \   000009   F583         MOV     DPH,A
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    457          #endif
    458          
    459          
    460          /*********************************************************************
    461           * @fn          zcl_getRawAFMsg
    462           *
    463           * @brief       Call to get original unprocessed AF message
    464           *              (not parsed by ZCL).
    465           *
    466           *   NOTE:  This function can only be called during a ZCL callback function
    467           *          and the calling function must NOT change any data in the message.
    468           *
    469           * @param       none
    470           *
    471           * @return      pointer to original AF message, NULL if not processing
    472           *              AF message.
    473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    474          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    475          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    476            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00000A   80..         SJMP    ?Subroutine0
    477          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    478          
    479          /*********************************************************************
    480           * @fn          zcl_getParsedTransSeqNum
    481           *
    482           * @brief       Call to the get the transaction sequence number from 
    483           *              the incoming message.
    484           *
    485           *   NOTE:  This function can only be called during a ZCL callback function
    486           *          and the calling function must NOT change any data in the message.
    487           *
    488           * @param       none
    489           *
    490           * @return      transaction sequence number.
    491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    492          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    493          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    494            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    495          }
    496          
    497          /*********************************************************************
    498           * @fn          zcl_registerPlugin
    499           *
    500           * @brief       Add a Cluster Library handler
    501           *
    502           * @param       startClusterID - starting cluster ID
    503           * @param       endClusterID - ending cluster ID
    504           * @param       pfnHdlr - function pointer to incoming message handler
    505           *
    506           * @return      ZSuccess if OK
    507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    508          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    509                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    510          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    511            zclLibPlugin_t *pNewItem;
    512            zclLibPlugin_t *pLoop;
    513          
    514            // Fill in the new profile list
    515            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    516            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    517            {
    518              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8041         SJMP    ??CrossCallReturnLabel_13
    519            }
    520          
    521            // Fill in the plugin record.
    522            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
    523            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_16:
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine7 & 0xFFFF
    524            pNewItem->endClusterID = endClusterID;
    525            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_2:
   \   000036   740C         MOV     A,#0xc
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   00003E   8882         MOV     DPL,R0
   \   000040   8983         MOV     DPH,R1
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   EA           MOV     A,R2
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   EB           MOV     A,R3
   \   00004C   F0           MOVX    @DPTR,A
    526          
    527            // Find spot in list
    528            if (  plugins == NULL )
   \   00004D   90....       MOV     DPTR,#plugins
   \   000050   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000053   7008         JNZ     ??zcl_registerPlugin_1
    529            {
    530              plugins = pNewItem;
   \   000055   90....       MOV     DPTR,#plugins
   \   000058   8008         SJMP    ??zcl_registerPlugin_2
    531            }
    532            else
    533            {
    534              // Look for end of list
    535              pLoop = plugins;
    536              while ( pLoop->next != NULL )
    537              {
    538                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   FA           MOV     R2,A
   \   00005C   A3           INC     DPTR
    539              }
   \                     ??zcl_registerPlugin_1:
   \   00005D   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000060   70F8         JNZ     ??zcl_registerPlugin_3
    540          
    541              // Put new item at end of list
    542              pLoop->next = pNewItem;
    543            }
   \                     ??zcl_registerPlugin_2:
   \   000062   12....       LCALL   ?Subroutine12 & 0xFFFF
    544          
    545            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_13:
   \   000065   80..         SJMP    ?Subroutine1
    546          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FB           MOV     R3,A
   \   000002   8A82         MOV     DPL,R2
   \   000004   8B83         MOV     DPH,R3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FC           MOV     R4,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FD           MOV     R5,A
   \   00000B   EC           MOV     A,R4
   \   00000C   4D           ORL     A,R5
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000005   A3           INC     DPTR
   \   000006   EE           MOV     A,R6
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EF           MOV     A,R7
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   22           RET
    547          
    548          #ifdef ZCL_DISCOVER
    549          /*********************************************************************
    550           * @fn          zcl_registerCmdList
    551           *
    552           * @brief       Register a Command List with ZCL Foundation
    553           *
    554           * @param       endpoint - endpoint the attribute list belongs to
    555           * @param       newCmdList - array of command records
    556           *
    557           * @return      ZSuccess if OK
    558           */
    559          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    560          {
    561            zclCmdRecsList_t *pNewItem;
    562            zclCmdRecsList_t *pLoop;
    563          
    564            // Fill in the new profile list
    565            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    566            if ( pNewItem == NULL )
    567            {
    568              return (ZMemError);
    569            }
    570          
    571            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    572            pNewItem->endpoint = endpoint;
    573            pNewItem->numCommands = cmdListSize;
    574            pNewItem->pCmdRecs = newCmdList;
    575          
    576            // Find spot in list
    577            if ( gpCmdList == NULL )
    578            {
    579              gpCmdList = pNewItem;
    580            }
    581            else
    582            {
    583              // Look for end of list
    584              pLoop = gpCmdList;
    585              while ( pLoop->pNext != NULL )
    586              {
    587                pLoop = pLoop->pNext;
    588              }
    589          
    590              // Put new item at end of list
    591              pLoop->pNext = pNewItem;
    592            }
    593          
    594            return ( ZSuccess );
    595          }
    596          #endif  // ZCL_DISCOVER
    597          
    598          /*********************************************************************
    599           * @fn          zcl_registerAttrList
    600           *
    601           * @brief       Register an Attribute List with ZCL Foundation
    602           *
    603           * @param       endpoint - endpoint the attribute list belongs to
    604           * @param       numAttr - number of attributes in list
    605           * @param       newAttrList - array of Attribute records.
    606           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    607           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    608           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    609           *
    610           * @return      ZSuccess if OK
    611           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    612          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    613          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    614            zclAttrRecsList *pNewItem;
    615            zclAttrRecsList *pLoop;
    616          
    617            // Fill in the new profile list
    618            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    619            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerAttrList_0
    620            {
    621              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   802C         SJMP    ??CrossCallReturnLabel_14
    622            }
    623          
    624            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL   ?Subroutine6 & 0xFFFF
    625            pNewItem->endpoint = endpoint;
    626            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_0:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   12....       LCALL   ?Subroutine9 & 0xFFFF
    627            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_6:
   \   00002D   E5..         MOV     A,?V1
   \   00002F   12....       LCALL   ?Subroutine9 & 0xFFFF
    628            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_7:
   \   000032   A3           INC     DPTR
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
    629          
    630            // Find spot in list
    631            if ( attrList == NULL )
   \   000038   90....       MOV     DPTR,#attrList
   \   00003B   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00003E   7008         JNZ     ??zcl_registerAttrList_1
    632            {
    633              attrList = pNewItem;
   \   000040   90....       MOV     DPTR,#attrList
   \   000043   8008         SJMP    ??zcl_registerAttrList_2
    634            }
    635            else
    636            {
    637              // Look for end of list
    638              pLoop = attrList;
    639              while ( pLoop->next != NULL )
    640              {
    641                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000045   E0           MOVX    A,@DPTR
   \   000046   FA           MOV     R2,A
   \   000047   A3           INC     DPTR
    642              }
   \                     ??zcl_registerAttrList_1:
   \   000048   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00004B   70F8         JNZ     ??zcl_registerAttrList_3
    643          
    644              // Put new item at end of list
    645              pLoop->next = pNewItem;
    646            }
   \                     ??zcl_registerAttrList_2:
   \   00004D   12....       LCALL   ?Subroutine12 & 0xFFFF
    647          
    648            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_14:
   \   000050                REQUIRE ?Subroutine1
   \   000050                ; // Fall through to label ?Subroutine1
    649          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0
   \   00000D   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000010   22           RET
    650          
    651          /*********************************************************************
    652           * @fn          zcl_registerClusterOptionList
    653           *
    654           * @brief       Register a Cluster Option List with ZCL Foundation
    655           *
    656           * @param       endpoint - endpoint the option list belongs to
    657           * @param       numOption - number of options in list
    658           * @param       optionList - array of cluster option records.
    659           *
    660           *              NOTE: This API should be called to enable 'Application
    661           *                    Link Key' security and/or 'APS ACK' for a specific
    662           *                    Cluster. The 'Application Link Key' is discarded
    663           *                    if security isn't enabled on the device.
    664           *                    The default behavior is 'Network Key' when security
    665           *                    is enabled and no 'APS ACK' for the ZCL messages.
    666           *
    667           * @return      ZSuccess if OK
    668           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    669          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    670          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    671            zclClusterOptionList *pNewItem;
    672            zclClusterOptionList *pLoop;
    673          
    674            // Fill in the new profile list
    675            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    676            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    677            {
    678              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   801E         SJMP    ??CrossCallReturnLabel_15
    679            }
    680          
    681            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine6 & 0xFFFF
    682            pNewItem->endpoint = endpoint;
    683            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_1:
   \   000027   12....       LCALL   ?Subroutine7 & 0xFFFF
    684            pNewItem->options = optionList;
    685          
    686            // Find spot in list
    687            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_3:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000030   7008         JNZ     ??zcl_registerClusterOptionList_1
    688            {
    689              clusterOptionList = pNewItem;
   \   000032   90....       MOV     DPTR,#clusterOptionList
   \   000035   8008         SJMP    ??zcl_registerClusterOptionList_2
    690            }
    691            else
    692            {
    693              // Look for end of list
    694              pLoop = clusterOptionList;
    695              while ( pLoop->next != NULL )
    696              {
    697                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   A3           INC     DPTR
    698              }
   \                     ??zcl_registerClusterOptionList_1:
   \   00003A   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00003D   70F8         JNZ     ??zcl_registerClusterOptionList_3
    699          
    700              // Put new item at end of list
    701              pLoop->next = pNewItem;
    702            }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003F   12....       LCALL   ?Subroutine12 & 0xFFFF
    703          
    704            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_15:
   \   000042   80..         SJMP    ?Subroutine1
    705          }
    706          
    707          /*********************************************************************
    708           * @fn          zcl_registerValidateAttrData
    709           *
    710           * @brief       Add a validation function for attribute data
    711           *
    712           * @param       pfnValidateAttrData - function pointer to validate routine
    713           *
    714           * @return      ZSuccess if OK
    715           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    716          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    717          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    718            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    719          
    720            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   02....       LJMP    ?Subroutine0 & 0xFFFF
    721          }
    722          
    723          /*********************************************************************
    724           * @fn          zcl_registerReadWriteCB
    725           *
    726           * @brief       Register the application's callback function to read/write
    727           *              attribute data, and authorize read/write operation.
    728           *
    729           *              Note: The pfnReadWriteCB callback function is only required
    730           *                    when the attribute data format is unknown to ZCL. The
    731           *                    callback function gets called when the pointer 'dataPtr'
    732           *                    to the attribute value is NULL in the attribute database
    733           *                    registered with the ZCL.
    734           *
    735           *              Note: The pfnAuthorizeCB callback function is only required
    736           *                    when the Read/Write operation on an attribute requires
    737           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    738           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    739           *
    740           * @param       endpoint - application's endpoint
    741           * @param       pfnReadWriteCB - function pointer to read/write routine
    742           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    743           *
    744           * @return      ZSuccess if successful. ZFailure, otherwise.
    745           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    746          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    747                                             zclAuthorizeCB_t pfnAuthorizeCB )
    748          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    749            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    750          
    751            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6019         JZ      ??zcl_registerReadWriteCB_0
    752            {
    753              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine10 & 0xFFFF
    754              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_9:
   \   00002A   E5..         MOV     A,?V0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V1
   \   000030   F0           MOVX    @DPTR,A
    755          
    756              return ( ZSuccess );
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??zcl_registerReadWriteCB_1
    757            }
    758          
    759            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037                REQUIRE ?Subroutine3
   \   000037                ; // Fall through to label ?Subroutine3
    760          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    761          
    762          /*********************************************************************
    763           * @fn      zcl_DeviceOperational
    764           *
    765           * @brief   Used to see whether or not the device can send or respond
    766           *          to application level commands.
    767           *
    768           * @param   srcEP - source endpoint
    769           * @param   clusterID - cluster ID
    770           * @param   frameType - command type
    771           * @param   cmd - command ID
    772           *
    773           * @return  TRUE if device is operational, FALSE otherwise
    774           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    775          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    776                                              uint8 frameType, uint8 cmd, uint16 profileID )
    777          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
    778            zclAttrRec_t attrRec;
    779            uint8 deviceEnabled = DEVICE_ENABLED; // default value
    780          
    781            (void)profileID;  // Intentionally unreferenced parameter
    782          
    783            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    784            // cannot send or respond to application level commands, other than commands
    785            // to read or write attributes. Note that the Identify cluster cannot be
    786            // disabled, and remains functional regardless of this setting.
    787            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   00000D   7006         JNZ     ??zcl_DeviceOperational_0
   \   00000F   ED           MOV     A,R5
   \   000010   C3           CLR     C
   \   000011   9406         SUBB    A,#0x6
   \   000013   4006         JC      ??zcl_DeviceOperational_1
    788            {
    789              return ( TRUE );
    790            }
    791          
    792            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000015   7403         MOV     A,#0x3
   \   000017   6A           XRL     A,R2
   \   000018   4B           ORL     A,R3
   \   000019   700A         JNZ     ??zcl_DeviceOperational_2
    793            {
    794              return ( TRUE );
   \                     ??zcl_DeviceOperational_1:
   \   00001B   7901         MOV     R1,#0x1
   \   00001D   7408         MOV     A,#0x8
   \   00001F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000022   02....       LJMP    ?Subroutine1 & 0xFFFF
    795            }
    796          
    797            // Is device enabled?
    798            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    799                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \                     ??zcl_DeviceOperational_2:
   \   000025                ; Setup parameters for call to function zclFindAttrRec
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V2,R0
   \   00002B   89..         MOV     ?V3,R1
   \   00002D   78..         MOV     R0,#?V2
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   7C12         MOV     R4,#0x12
   \   000034   7D00         MOV     R5,#0x0
   \   000036   7A00         MOV     R2,#0x0
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   EE           MOV     A,R6
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?DEALLOC_XSTACK8
   \   000044   80D5         SJMP    ??zcl_DeviceOperational_1
    800            {
    801          #ifdef ZCL_READ
    802              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
    803          #endif
    804            }
    805          
    806            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
    807          }
    808          
    809          /*********************************************************************
    810           * @fn      zcl_SendCommand
    811           *
    812           * @brief   Used to send Profile and Cluster Specific Command messages.
    813           *
    814           *          NOTE: The calling application is responsible for incrementing
    815           *                the Sequence Number.
    816           *
    817           * @param   srcEp - source endpoint
    818           * @param   destAddr - destination address
    819           * @param   clusterID - cluster ID
    820           * @param   cmd - command ID
    821           * @param   specific - whether the command is Cluster Specific
    822           * @param   direction - client/server direction of the command
    823           * @param   disableDefaultRsp - disable Default Response command
    824           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    825           * @param   seqNumber - identification number for the transaction
    826           * @param   cmdFormatLen - length of the command to be sent
    827           * @param   cmdFormat - command to be sent
    828           *
    829           * @return  ZSuccess if OK
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    832                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    833                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    834                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    835          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    836            endPointDesc_t *epDesc;
    837            zclFrameHdr_t hdr;
    838            uint8 *msgBuf;
    839            uint16 msgLen;
    840            uint8 *pBuf;
    841            uint8 options;
    842            ZStatus_t status;
    843          
    844            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    845            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    846            {
    847              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    848            }
    849          
    850          #if defined ( INTER_PAN )
    851            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function StubAPS_InterPan
   \   000025   85..82       MOV     DPL,?V14
   \   000028   85..83       MOV     DPH,?V15
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F9           MOV     R1,A
   \   000036   85..82       MOV     DPL,?V14
   \   000039   85..83       MOV     DPH,?V15
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   12....       LCALL   ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000049   12....       LCALL   `??StubAPS_InterPan::?relay`; Banked call to: StubAPS_InterPan
   \   00004C   E9           MOV     A,R1
   \   00004D   6005         JZ      ??zcl_SendCommand_2
    852            {
    853              options = AF_TX_OPTIONS_NONE;
   \   00004F   75..00       MOV     ?V2,#0x0
   \   000052   802C         SJMP    ??zcl_SendCommand_3
    854            }
    855            else
    856          #endif
    857            {
    858              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_2:
   \   000054                ; Setup parameters for call to function zclGetClusterOption
   \   000054   AA..         MOV     R2,?V0
   \   000056   AB..         MOV     R3,?V1
   \   000058   A9..         MOV     R1,?V3
   \   00005A   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00005D   E9           MOV     A,R1
   \   00005E   F5..         MOV     ?V2,A
    859          
    860              // The cluster might not have been defined to use security but if this message
    861              // is in response to another message that was using APS security this message
    862              // will be sent with APS security
    863              if ( !( options & AF_EN_SECURITY ) )
   \   000060   A2E6         MOV     C,0xE0 /* A   */.6
   \   000062   401C         JC      ??zcl_SendCommand_3
    864              {
    865                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000064   90....       MOV     DPTR,#rawAFMsg
   \   000067   12....       LCALL   ??Subroutine53_0 & 0xFFFF
    866          
    867                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_117:
   \   00006A   6014         JZ      ??zcl_SendCommand_3
   \   00006C   E8           MOV     A,R0
   \   00006D   2419         ADD     A,#0x19
   \   00006F   F582         MOV     DPL,A
   \   000071   E4           CLR     A
   \   000072   39           ADDC    A,R1
   \   000073   F583         MOV     DPH,A
   \   000075   E0           MOVX    A,@DPTR
   \   000076   6401         XRL     A,#0x1
   \   000078   7006         JNZ     ??zcl_SendCommand_3
    868                {
    869                  options |= AF_EN_SECURITY;
   \   00007A   E5..         MOV     A,?V2
   \   00007C   D2E6         SETB    0xE0 /* A   */.6
   \   00007E   F5..         MOV     ?V2,A
    870                }
    871              }
    872            }
    873          
    874            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_3:
   \   000080                ; Setup parameters for call to function osal_memset
   \   000080   7C06         MOV     R4,#0x6
   \   000082   7D00         MOV     R5,#0x0
   \   000084   7900         MOV     R1,#0x0
   \   000086   AA..         MOV     R2,?XSP + 0
   \   000088   AB..         MOV     R3,?XSP + 1
   \   00008A   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    875          
    876            // Not Profile wide command (like READ, WRITE)
    877            if ( specific )
   \   00008D   741F         MOV     A,#0x1f
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000095   6009         JZ      ??zcl_SendCommand_4
    878            {
    879              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000097   E0           MOVX    A,@DPTR
   \   000098   54FC         ANL     A,#0xfc
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   4401         ORL     A,#0x1
   \   00009E   8003         SJMP    ??zcl_SendCommand_5
    880            }
    881            else
    882            {
    883              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_4:
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   54FC         ANL     A,#0xfc
   \                     ??zcl_SendCommand_5:
   \   0000A3   F0           MOVX    @DPTR,A
    884            }
    885          
    886            if ( ( epDesc->simpleDesc == NULL ) ||
    887                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    888                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   0000A4   85..82       MOV     DPL,?V12
   \   0000A7   85..83       MOV     DPH,?V13
   \   0000AA   A3           INC     DPTR
   \   0000AB   12....       LCALL   ??Subroutine52_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000AE   6036         JZ      ??zcl_SendCommand_6
   \   0000B0   741E         MOV     A,#0x1e
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   FE           MOV     R6,A
   \   0000B7                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000B7   85..82       MOV     DPL,?V12
   \   0000BA   85..83       MOV     DPH,?V13
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F583         MOV     DPH,A
   \   0000C4   8882         MOV     DPL,R0
   \   0000C6   A3           INC     DPTR
   \   0000C7   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000CA   EE           MOV     A,R6
   \   0000CB   FD           MOV     R5,A
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   5403         ANL     A,#0x3
   \   0000D4   FC           MOV     R4,A
   \   0000D5   AA..         MOV     R2,?V0
   \   0000D7   AB..         MOV     R3,?V1
   \   0000D9   A9..         MOV     R1,?V3
   \   0000DB   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000DE   7402         MOV     A,#0x2
   \   0000E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E3   E9           MOV     A,R1
   \   0000E4   7005         JNZ     ??zcl_SendCommand_7
    889            {
    890              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_6:
   \   0000E6   7901         MOV     R1,#0x1
   \   0000E8   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    891            }
   \                     ??zcl_SendCommand_7:
   \   0000EB   7422         MOV     A,#0x22
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   12....       LCALL   ??Subroutine53_0 & 0xFFFF
    892          
    893            // Fill in the Maufacturer Code
    894            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_118:
   \   0000F3   6012         JZ      ??CrossCallReturnLabel_105
    895            {
    896              hdr.fc.manuSpecific = 1;
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   4404         ORL     A,#0x4
   \   0000FE   F0           MOVX    @DPTR,A
    897              hdr.manuCode = manuCode;
   \   0000FF   7402         MOV     A,#0x2
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   12....       LCALL   ?Subroutine13 & 0xFFFF
    898            }
    899          
    900            // Set the Command Direction
    901            if ( direction )
   \                     ??CrossCallReturnLabel_105:
   \   000107   7420         MOV     A,#0x20
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00010F   6005         JZ      ??zcl_SendCommand_8
    902            {
    903              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000111   E0           MOVX    A,@DPTR
   \   000112   4408         ORL     A,#0x8
   \   000114   8003         SJMP    ??zcl_SendCommand_9
    904            }
    905            else
    906            {
    907              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_8:
   \   000116   E0           MOVX    A,@DPTR
   \   000117   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_9:
   \   000119   F0           MOVX    @DPTR,A
    908            }
    909          
    910            // Set the Disable Default Response field
    911            if ( disableDefaultRsp )
   \   00011A   7421         MOV     A,#0x21
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000122   6005         JZ      ??zcl_SendCommand_10
    912            {
    913              hdr.fc.disableDefaultRsp = 1;
   \   000124   E0           MOVX    A,@DPTR
   \   000125   4410         ORL     A,#0x10
   \   000127   8003         SJMP    ??zcl_SendCommand_11
    914            }
    915            else
    916            {
    917              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_10:
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_11:
   \   00012C   F0           MOVX    @DPTR,A
    918            }
    919          
    920            // Fill in the Transaction Sequence Number
    921            hdr.transSeqNum = seqNum;
   \   00012D   7424         MOV     A,#0x24
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   E0           MOVX    A,@DPTR
   \   000133   C0E0         PUSH    A
   \   000135   7404         MOV     A,#0x4
   \   000137   12....       LCALL   ?XSTACK_DISP0_8
   \   00013A   D0E0         POP     A
   \   00013C   F0           MOVX    @DPTR,A
    922          
    923            // Fill in the command
    924            hdr.commandID = cmd;
   \   00013D   7405         MOV     A,#0x5
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   EE           MOV     A,R6
   \   000143   F0           MOVX    @DPTR,A
    925          
    926            // calculate the needed buffer size
    927            msgLen = zclCalcHdrSize( &hdr );
   \   000144   7803         MOV     R0,#0x3
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   5404         ANL     A,#0x4
   \   00014F   6002         JZ      ??zcl_SendCommand_12
   \   000151   7805         MOV     R0,#0x5
   \                     ??zcl_SendCommand_12:
   \   000153   7425         MOV     A,#0x25
   \   000155   12....       LCALL   ?XSTACK_DISP0_8
   \   000158   E0           MOVX    A,@DPTR
   \   000159   F5..         MOV     ?V10,A
   \   00015B   A3           INC     DPTR
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   F5..         MOV     ?V11,A
    928            msgLen += cmdFormatLen;
   \   00015F   E8           MOV     A,R0
   \   000160   25..         ADD     A,?V10
   \   000162   FE           MOV     R6,A
   \   000163   E4           CLR     A
   \   000164   35..         ADDC    A,?V11
   \   000166   FF           MOV     R7,A
    929          
    930            // Allocate the buffer needed
    931            msgBuf = zcl_mem_alloc( msgLen );
   \   000167                ; Setup parameters for call to function osal_mem_alloc
   \   000167   EE           MOV     A,R6
   \   000168   FA           MOV     R2,A
   \   000169   EF           MOV     A,R7
   \   00016A   FB           MOV     R3,A
   \   00016B   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00016E   8A..         MOV     ?V8,R2
   \   000170   8B..         MOV     ?V9,R3
    932            if ( msgBuf != NULL )
   \   000172   EA           MOV     A,R2
   \   000173   45..         ORL     A,?V9
   \   000175   606E         JZ      ??zcl_SendCommand_13
    933            {
    934              // Fill in the ZCL Header
    935              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000177                ; Setup parameters for call to function zclBuildHdr
   \   000177   AC..         MOV     R4,?V8
   \   000179   AD..         MOV     R5,?V9
   \   00017B   AA..         MOV     R2,?XSP + 0
   \   00017D   AB..         MOV     R3,?XSP + 1
   \   00017F   12....       LCALL   `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
    936          
    937              // Fill in the command frame
    938              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000182                ; Setup parameters for call to function osal_memcpy
   \   000182   7427         MOV     A,#0x27
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   E0           MOVX    A,@DPTR
   \   000188   F5..         MOV     ?V4,A
   \   00018A   A3           INC     DPTR
   \   00018B   E0           MOVX    A,@DPTR
   \   00018C   F5..         MOV     ?V5,A
   \   00018E   75..00       MOV     ?V6,#0x0
   \   000191   78..         MOV     R0,#?V4
   \   000193   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000196   AC..         MOV     R4,?V10
   \   000198   AD..         MOV     R5,?V11
   \   00019A   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00019D   7403         MOV     A,#0x3
   \   00019F   12....       LCALL   ?DEALLOC_XSTACK8
    939          
    940              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    941                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   0001A2                ; Setup parameters for call to function AF_DataRequest
   \   0001A2   75..1E       MOV     ?V4,#0x1e
   \   0001A5   78..         MOV     R0,#?V4
   \   0001A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001AA   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   0001AD   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   0001B0   78..         MOV     R0,#?V4
   \   0001B2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B5   78..         MOV     R0,#?V8
   \   0001B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001BA   8E..         MOV     ?V4,R6
   \   0001BC   8F..         MOV     ?V5,R7
   \   0001BE   78..         MOV     R0,#?V4
   \   0001C0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C3   78..         MOV     R0,#?V0
   \   0001C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C8   A9..         MOV     R1,?V2
   \   0001CA   AC..         MOV     R4,?V12
   \   0001CC   AD..         MOV     R5,?V13
   \   0001CE   AA..         MOV     R2,?V14
   \   0001D0   AB..         MOV     R3,?V15
   \   0001D2   12....       LCALL   `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   0001D5   7409         MOV     A,#0x9
   \   0001D7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001DA   E9           MOV     A,R1
   \   0001DB   FE           MOV     R6,A
    942              zcl_mem_free ( msgBuf );
   \   0001DC                ; Setup parameters for call to function osal_mem_free
   \   0001DC   AA..         MOV     R2,?V8
   \   0001DE   AB..         MOV     R3,?V9
   \   0001E0   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001E3   8002         SJMP    ??zcl_SendCommand_14
    943            }
    944            else
    945            {
    946              status = ZMemError;
   \                     ??zcl_SendCommand_13:
   \   0001E5   7E10         MOV     R6,#0x10
    947            }
    948          
    949            return ( status );
   \                     ??zcl_SendCommand_14:
   \   0001E7   EE           MOV     A,R6
   \   0001E8   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   0001E9   7406         MOV     A,#0x6
   \   0001EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001EE   7F10         MOV     R7,#0x10
   \   0001F0   02....       LJMP    ?BANKED_LEAVE_XDATA
    950          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine50_0
   \   000001                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine52_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine53_0
   \   000002                ; // Fall through to label ??Subroutine53_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine53_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET
    951          
    952          #ifdef ZCL_READ
    953          /*********************************************************************
    954           * @fn      zcl_SendRead
    955           *
    956           * @brief   Send a Read command
    957           *
    958           * @param   srcEP - Application's endpoint
    959           * @param   dstAddr - destination address
    960           * @param   clusterID - cluster ID
    961           * @param   readCmd - read command to be sent
    962           * @param   direction - direction of the command
    963           * @param   seqNum - transaction sequence number
    964           *
    965           * @return  ZSuccess if OK
    966           */
    967          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
    968                                  uint16 clusterID, zclReadCmd_t *readCmd,
    969                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    970          {
    971            uint16 dataLen;
    972            uint8 *buf;
    973            uint8 *pBuf;
    974            ZStatus_t status;
    975          
    976            dataLen = readCmd->numAttr * 2; // Attribute ID
    977          
    978            buf = zcl_mem_alloc( dataLen );
    979            if ( buf != NULL )
    980            {
    981              uint8 i;
    982          
    983              // Load the buffer - serially
    984              pBuf = buf;
    985              for (i = 0; i < readCmd->numAttr; i++)
    986              {
    987                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
    988                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
    989              }
    990          
    991              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    992                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    993              zcl_mem_free( buf );
    994            }
    995            else
    996            {
    997              status = ZMemError;
    998            }
    999          
   1000            return ( status );
   1001          }
   1002          
   1003          /*********************************************************************
   1004           * @fn      zcl_SendReadRsp
   1005           *
   1006           * @brief   Send a Read Response command.
   1007           *
   1008           * @param   srcEP - Application's endpoint
   1009           * @param   dstAddr - destination address
   1010           * @param   clusterID - cluster ID
   1011           * @param   readRspCmd - read response command to be sent
   1012           * @param   direction - direction of the command
   1013           * @param   seqNum - transaction sequence number
   1014           *
   1015           * @return  ZSuccess if OK
   1016           */
   1017          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1018                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1019                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1020          {
   1021            uint8 *buf;
   1022            uint16 len = 0;
   1023            ZStatus_t status;
   1024            uint8 i;
   1025          
   1026            // calculate the size of the command
   1027            for ( i = 0; i < readRspCmd->numAttr; i++ )
   1028            {
   1029              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1030          
   1031              len += 2 + 1; // Attribute ID + Status
   1032          
   1033              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1034              {
   1035                len++; // Attribute Data Type length
   1036          
   1037                // Attribute Data length
   1038                if ( statusRec->data != NULL )
   1039                {
   1040                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1041                }
   1042                else
   1043                {
   1044                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   1045                }
   1046              }
   1047            }
   1048          
   1049            buf = zcl_mem_alloc( len );
   1050            if ( buf != NULL )
   1051            {
   1052              // Load the buffer - serially
   1053              uint8 *pBuf = buf;
   1054          
   1055              for ( i = 0; i < readRspCmd->numAttr; i++ )
   1056              {
   1057                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1058          
   1059                *pBuf++ = LO_UINT16( statusRec->attrID );
   1060                *pBuf++ = HI_UINT16( statusRec->attrID );
   1061                *pBuf++ = statusRec->status;
   1062          
   1063                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1064                {
   1065                  *pBuf++ = statusRec->dataType;
   1066          
   1067                  if ( statusRec->data != NULL )
   1068                  {
   1069                    // Copy attribute data to the buffer to be sent out
   1070                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1071                  }
   1072                  else
   1073                  {
   1074                    uint16 dataLen;
   1075          
   1076                    // Read attribute data directly into the buffer to be sent out
   1077                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   1078                    pBuf += dataLen;
   1079                  }
   1080                }
   1081              } // for loop
   1082          
   1083              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1084                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   1085              zcl_mem_free( buf );
   1086            }
   1087            else
   1088            {
   1089              status = ZMemError;
   1090            }
   1091          
   1092            return ( status );
   1093          }
   1094          #endif // ZCL_READ
   1095          
   1096          #ifdef ZCL_WRITE
   1097          /*********************************************************************
   1098           * @fn      sendWriteRequest
   1099           *
   1100           * @brief   Send a Write command
   1101           *
   1102           * @param   dstAddr - destination address
   1103           * @param   clusterID - cluster ID
   1104           * @param   writeCmd - write command to be sent
   1105           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1106           * @param   direction - direction of the command
   1107           * @param   seqNum - transaction sequence number
   1108           *
   1109           * @return  ZSuccess if OK
   1110           */
   1111          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1112                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1113                                          uint8 disableDefaultRsp, uint8 seqNum )
   1114          {
   1115            uint8 *buf;
   1116            uint16 dataLen = 0;
   1117            ZStatus_t status;
   1118            uint8 i;
   1119          
   1120            for ( i = 0; i < writeCmd->numAttr; i++ )
   1121            {
   1122              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   1123          
   1124              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1125          
   1126              // Attribute Data
   1127              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1128            }
   1129          
   1130            buf = zcl_mem_alloc( dataLen );
   1131            if ( buf != NULL )
   1132            {
   1133              // Load the buffer - serially
   1134              uint8 *pBuf = buf;
   1135              for ( i = 0; i < writeCmd->numAttr; i++ )
   1136              {
   1137                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   1138          
   1139                *pBuf++ = LO_UINT16( statusRec->attrID );
   1140                *pBuf++ = HI_UINT16( statusRec->attrID );
   1141                *pBuf++ = statusRec->dataType;
   1142          
   1143                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1144              }
   1145          
   1146              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1147                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1148              zcl_mem_free( buf );
   1149            }
   1150            else
   1151            {
   1152              status = ZMemError;
   1153            }
   1154          
   1155            return ( status);
   1156          }
   1157          
   1158          /*********************************************************************
   1159           * @fn      zcl_SendWriteRsp
   1160           *
   1161           * @brief   Send a Write Response command
   1162           *
   1163           * @param   dstAddr - destination address
   1164           * @param   clusterID - cluster ID
   1165           * @param   wrtieRspCmd - write response command to be sent
   1166           * @param   direction - direction of the command
   1167           * @param   seqNum - transaction sequence number
   1168           *
   1169           * @return  ZSuccess if OK
   1170           */
   1171          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1172                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1173                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1174          {
   1175            uint16 dataLen;
   1176            uint8 *buf;
   1177            ZStatus_t status;
   1178          
   1179            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1180          
   1181            buf = zcl_mem_alloc( dataLen );
   1182            if ( buf != NULL )
   1183            {
   1184              // Load the buffer - serially
   1185              uint8 i;
   1186              uint8 *pBuf = buf;
   1187              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   1188              {
   1189                *pBuf++ = writeRspCmd->attrList[i].status;
   1190                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1191                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1192              }
   1193          
   1194              // If there's only a single status record and its status field is set to
   1195              // SUCCESS then omit the attribute ID field.
   1196              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1197              {
   1198                dataLen = 1;
   1199              }
   1200          
   1201              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1202                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1203              zcl_mem_free( buf );
   1204            }
   1205            else
   1206            {
   1207              status = ZMemError;
   1208            }
   1209          
   1210            return ( status );
   1211          }
   1212          #endif // ZCL_WRITE
   1213          
   1214          #ifdef ZCL_REPORT
   1215          /*********************************************************************
   1216           * @fn      zcl_SendConfigReportCmd
   1217           *
   1218           * @brief   Send a Configure Reporting command
   1219           *
   1220           * @param   dstAddr - destination address
   1221           * @param   clusterID - cluster ID
   1222           * @param   cfgReportCmd - configure reporting command to be sent
   1223           * @param   direction - direction of the command
   1224           * @param   seqNum - transaction sequence number
   1225           *
   1226           * @return  ZSuccess if OK
   1227           */
   1228          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1229                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1230                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1231          {
   1232            uint8 *buf;
   1233            uint16 dataLen = 0;
   1234            ZStatus_t status;
   1235            uint8 i;
   1236          
   1237            // Find out the data length
   1238            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1239            {
   1240              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1241          
   1242              dataLen += 1 + 2; // Direction + Attribute ID
   1243          
   1244              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1245              {
   1246                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1247          
   1248                // Find out the size of the Reportable Change field (for Analog data types)
   1249                if ( zclAnalogDataType( reportRec->dataType ) )
   1250                {
   1251                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1252                }
   1253              }
   1254              else
   1255              {
   1256                dataLen += 2; // Timeout Period
   1257              }
   1258            }
   1259          
   1260            buf = zcl_mem_alloc( dataLen );
   1261            if ( buf != NULL )
   1262            {
   1263              // Load the buffer - serially
   1264              uint8 *pBuf = buf;
   1265          
   1266              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1267              {
   1268                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1269          
   1270                *pBuf++ = reportRec->direction;
   1271                *pBuf++ = LO_UINT16( reportRec->attrID );
   1272                *pBuf++ = HI_UINT16( reportRec->attrID );
   1273          
   1274                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1275                {
   1276                  *pBuf++ = reportRec->dataType;
   1277                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1278                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1279                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1280                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1281          
   1282                  if ( zclAnalogDataType( reportRec->dataType ) )
   1283                  {
   1284                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1285                  }
   1286                }
   1287                else
   1288                {
   1289                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1290                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1291                }
   1292              } // for loop
   1293          
   1294              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1295                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1296              zcl_mem_free( buf );
   1297            }
   1298            else
   1299            {
   1300              status = ZMemError;
   1301            }
   1302          
   1303            return ( status );
   1304          }
   1305          
   1306          /*********************************************************************
   1307           * @fn      zcl_SendConfigReportRspCmd
   1308           *
   1309           * @brief   Send a Configure Reporting Response command
   1310           *
   1311           * @param   dstAddr - destination address
   1312           * @param   clusterID - cluster ID
   1313           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1314           * @param   direction - direction of the command
   1315           * @param   seqNum - transaction sequence number
   1316           *
   1317           * @return  ZSuccess if OK
   1318           */
   1319          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1320                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1321                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1322          {
   1323            uint16 dataLen;
   1324            uint8 *buf;
   1325            ZStatus_t status;
   1326          
   1327            // Atrribute list (Status, Direction and Attribute ID)
   1328            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1329          
   1330            buf = zcl_mem_alloc( dataLen );
   1331            if ( buf != NULL )
   1332            {
   1333              // Load the buffer - serially
   1334              uint8 *pBuf = buf;
   1335              uint8 i;
   1336          
   1337              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1338              {
   1339                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1340                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1341                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1342                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1343              }
   1344          
   1345              // If there's only a single status record and its status field is set to
   1346              // SUCCESS then omit the attribute ID field.
   1347              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1348              {
   1349                dataLen = 1;
   1350              }
   1351          
   1352              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1353                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1354                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1355              zcl_mem_free( buf );
   1356            }
   1357            else
   1358            {
   1359              status = ZMemError;
   1360            }
   1361          
   1362            return ( status );
   1363          }
   1364          
   1365          /*********************************************************************
   1366           * @fn      zcl_SendReadReportCfgCmd
   1367           *
   1368           * @brief   Send a Read Reporting Configuration command
   1369           *
   1370           * @param   dstAddr - destination address
   1371           * @param   clusterID - cluster ID
   1372           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1373           * @param   direction - direction of the command
   1374           * @param   seqNum - transaction sequence number
   1375           *
   1376           * @return  ZSuccess if OK
   1377           */
   1378          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1379                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1380                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1381          {
   1382            uint16 dataLen;
   1383            uint8 *buf;
   1384            ZStatus_t status;
   1385          
   1386            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1387          
   1388            buf = zcl_mem_alloc( dataLen );
   1389            if ( buf != NULL )
   1390            {
   1391              // Load the buffer - serially
   1392              uint8 *pBuf = buf;
   1393              uint8 i;
   1394          
   1395              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1396              {
   1397                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1398                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1399                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1400              }
   1401          
   1402              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1403                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1404              zcl_mem_free( buf );
   1405            }
   1406            else
   1407            {
   1408              status = ZMemError;
   1409            }
   1410          
   1411            return ( status );
   1412          }
   1413          
   1414          /*********************************************************************
   1415           * @fn      zcl_SendReadReportCfgRspCmd
   1416           *
   1417           * @brief   Send a Read Reporting Configuration Response command
   1418           *
   1419           * @param   dstAddr - destination address
   1420           * @param   clusterID - cluster ID
   1421           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1422           * @param   direction - direction of the command
   1423           * @param   seqNum - transaction sequence number
   1424           *
   1425           * @return  ZSuccess if OK
   1426           */
   1427          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1428                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1429                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1430          {
   1431            uint8 *buf;
   1432            uint16 dataLen = 0;
   1433            ZStatus_t status;
   1434            uint8 i;
   1435          
   1436            // Find out the data length
   1437            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1438            {
   1439              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1440          
   1441              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1442          
   1443              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1444              {
   1445                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1446                {
   1447                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1448          
   1449                  // Find out the size of the Reportable Change field (for Analog data types)
   1450                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1451                  {
   1452                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1453                  }
   1454                }
   1455                else
   1456                {
   1457                  dataLen += 2; // Timeout Period
   1458                }
   1459              }
   1460            }
   1461          
   1462            buf = zcl_mem_alloc( dataLen );
   1463            if ( buf != NULL )
   1464            {
   1465              // Load the buffer - serially
   1466              uint8 *pBuf = buf;
   1467          
   1468              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1469              {
   1470                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1471          
   1472                *pBuf++ = reportRspRec->status;
   1473                *pBuf++ = reportRspRec->direction;
   1474                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1475                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1476          
   1477                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1478                {
   1479                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1480                  {
   1481                    *pBuf++ = reportRspRec->dataType;
   1482                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1483                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1484                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1485                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1486          
   1487                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1488                    {
   1489                      pBuf = zclSerializeData( reportRspRec->dataType,
   1490                                               reportRspRec->reportableChange, pBuf );
   1491                    }
   1492                  }
   1493                  else
   1494                  {
   1495                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1496                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1497                  }
   1498                }
   1499              }
   1500          
   1501              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1502                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1503                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1504              zcl_mem_free( buf );
   1505            }
   1506            else
   1507            {
   1508              status = ZMemError;
   1509            }
   1510          
   1511            return ( status );
   1512          }
   1513          
   1514          /*********************************************************************
   1515           * @fn      zcl_SendReportCmd
   1516           *
   1517           * @brief   Send a Report command
   1518           *
   1519           * @param   dstAddr - destination address
   1520           * @param   clusterID - cluster ID
   1521           * @param   reportCmd - report command to be sent
   1522           * @param   direction - direction of the command
   1523           * @param   seqNum - transaction sequence number
   1524           *
   1525           * @return  ZSuccess if OK
   1526           */
   1527          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1528                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1529                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1530          {
   1531            uint16 dataLen = 0;
   1532            uint8 *buf;
   1533            ZStatus_t status;
   1534            uint8 i;
   1535          
   1536            // calculate the size of the command
   1537            for ( i = 0; i < reportCmd->numAttr; i++ )
   1538            {
   1539              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1540          
   1541              dataLen += 2 + 1; // Attribute ID + data type
   1542          
   1543              // Attribute Data
   1544              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1545            }
   1546          
   1547            buf = zcl_mem_alloc( dataLen );
   1548            if ( buf != NULL )
   1549            {
   1550              // Load the buffer - serially
   1551              uint8 *pBuf = buf;
   1552          
   1553              for ( i = 0; i < reportCmd->numAttr; i++ )
   1554              {
   1555                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1556          
   1557                *pBuf++ = LO_UINT16( reportRec->attrID );
   1558                *pBuf++ = HI_UINT16( reportRec->attrID );
   1559                *pBuf++ = reportRec->dataType;
   1560          
   1561                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1562              }
   1563          
   1564              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1565                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1566              zcl_mem_free( buf );
   1567            }
   1568            else
   1569            {
   1570              status = ZMemError;
   1571            }
   1572          
   1573            return ( status );
   1574          }
   1575          #endif // ZCL_REPORT
   1576          
   1577          /*********************************************************************
   1578           * @fn      zcl_SendDefaultRspCmd
   1579           *
   1580           * @brief   Send a Default Response command
   1581           *
   1582           *          Note: The manufacturer code field should be set if this
   1583           *          command is being sent in response to a manufacturer specific
   1584           *          command.
   1585           *
   1586           * @param   dstAddr - destination address
   1587           * @param   clusterID - cluster ID
   1588           * @param   defaultRspCmd - default response command to be sent
   1589           * @param   direction - direction of the command
   1590           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1591           * @param   seqNum - transaction sequence number
   1592           *
   1593           * @return  ZSuccess if OK
   1594           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1595          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1596                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1597                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1598          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine34 & 0xFFFF
   1599            uint8 buf[2]; // Command ID and Status;
   1600          
   1601            // Load the buffer - serially
   1602            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_59:
   \   000014   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000017   12....       LCALL   ?Subroutine14 & 0xFFFF
   1603            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_17:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1604          
   1605            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1606                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D   78..         MOV     R0,#?V0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V0,#0x2
   \   000035   75..00       MOV     ?V1,#0x0
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV     A,#0x15
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV     A,#0x16
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV     A,#0x16
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV     ?V0,#0x0
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV     ?V0,#0xb
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV     A,R6
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   02....       LJMP    ?Subroutine2 & 0xFFFF
   1607          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET
   1608          
   1609          #ifdef ZCL_DISCOVER
   1610          /*********************************************************************
   1611           * @fn      zcl_SendDiscoverCmdsCmd
   1612           *
   1613           * @brief   Send a Discover Commands command
   1614           *
   1615           * @param   dstAddr - destination address
   1616           * @param   clusterID - cluster ID
   1617           * @param   cmdType - requesting command ID
   1618           * @param   pDiscoverCmd - discover command to be sent
   1619           * @param   direction - direction of the command
   1620           * @param   seqNum - transaction sequence number
   1621           *
   1622           * @return  ZSuccess if OK
   1623           */
   1624          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1625                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1626                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1627          {
   1628            uint8 payload[2]; // size of startCmdID and maxCmdID
   1629            ZStatus_t status;
   1630          
   1631            payload[0] = pDiscoverCmd->startCmdID;
   1632            payload[1] = pDiscoverCmd->maxCmdID;
   1633          
   1634            // Send message for either commands received or generated
   1635            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1636            {
   1637              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1638                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1639            }
   1640            else  // generated
   1641            {
   1642              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1643                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1644            }
   1645          
   1646            return ( status );
   1647          }
   1648          
   1649          /*********************************************************************
   1650           * @fn      zcl_SendDiscoverCmdsRspCmd
   1651           *
   1652           * @brief   Send a Discover Commands Response command
   1653           *
   1654           * @param   dstAddr - destination address
   1655           * @param   clusterID - cluster ID
   1656           * @param   pDiscoverRspCmd - response command to be sent
   1657           * @param   direction - direction of the command
   1658           * @param   seqNum - transaction sequence number
   1659           *
   1660           * @return  ZSuccess if OK
   1661           */
   1662          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1663                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1664                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1665          {
   1666            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1667            uint8 *pCmdBuf;
   1668            uint8 i;
   1669            ZStatus_t status = ZSuccess;
   1670          
   1671            // allocate memory
   1672            pCmdBuf = zcl_mem_alloc( payloadSize );
   1673            if ( pCmdBuf != NULL )
   1674            {
   1675              uint8 *pBuf = pCmdBuf;
   1676          
   1677              // Load the buffer - serially
   1678              *pBuf++ = pDiscoverRspCmd->discComplete;
   1679              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1680              {
   1681                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1682              }
   1683          
   1684              // Send response message for either commands received or generated
   1685              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1686              {
   1687                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1688                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1689              }
   1690              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1691              {
   1692                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1693                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1694              }
   1695          
   1696              zcl_mem_free( pCmdBuf );
   1697            }
   1698            else
   1699            {
   1700              status = ZMemError;
   1701            }
   1702          
   1703            return ( status );
   1704          }
   1705          
   1706          /*********************************************************************
   1707           * @fn      zcl_SendDiscoverAttrsCmd
   1708           *
   1709           * @brief   Send a Discover Attributes command
   1710           *
   1711           * @param   dstAddr - destination address
   1712           * @param   clusterID - cluster ID
   1713           * @param   pDiscoverCmd - discover command to be sent
   1714           * @param   direction - direction of the command
   1715           * @param   seqNum - transaction sequence number
   1716           *
   1717           * @return  ZSuccess if OK
   1718           */
   1719          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1720                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1721                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1722          {
   1723            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1724            uint8 *buf;
   1725            ZStatus_t status;
   1726          
   1727            buf = zcl_mem_alloc( dataLen );
   1728            if ( buf != NULL )
   1729            {
   1730              // Load the buffer - serially
   1731              uint8 *pBuf = buf;
   1732              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1733              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1734              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1735          
   1736              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1737                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1738              zcl_mem_free( buf );
   1739            }
   1740            else
   1741            {
   1742              status = ZMemError;
   1743            }
   1744          
   1745            return ( status );
   1746          }
   1747          
   1748          /*********************************************************************
   1749           * @fn      zcl_SendDiscoverAttrsRspCmd
   1750           *
   1751           * @brief   Send a Discover Attributes Response command
   1752           *
   1753           * @param   dstAddr - destination address
   1754           * @param   clusterID - cluster ID
   1755           * @param   reportRspCmd - report response command to be sent
   1756           * @param   direction - direction of the command
   1757           * @param   seqNum - transaction sequence number
   1758           *
   1759           * @return  ZSuccess if OK
   1760           */
   1761          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1762                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1763                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1764          {
   1765            uint16 dataLen = 1; // Discovery complete
   1766            uint8 *buf;
   1767            ZStatus_t status;
   1768          
   1769            // calculate the size of the command
   1770            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1771          
   1772            buf = zcl_mem_alloc( dataLen );
   1773            if ( buf != NULL )
   1774            {
   1775              // Load the buffer - serially
   1776              uint8 i;
   1777              uint8 *pBuf = buf;
   1778          
   1779              *pBuf++ = pDiscoverRspCmd->discComplete;
   1780          
   1781              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1782              {
   1783                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1784                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1785                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1786              }
   1787          
   1788              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1789                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1790              zcl_mem_free( buf );
   1791            }
   1792            else
   1793            {
   1794              status = ZMemError;
   1795            }
   1796          
   1797            return ( status );
   1798          }
   1799          
   1800          /*********************************************************************
   1801           * @fn      zcl_SendDiscoverAttrsExt
   1802           *
   1803           * @brief   Send a Discover Attributes Extended command
   1804           *
   1805           * @param   dstAddr - destination address
   1806           * @param   clusterID - cluster ID
   1807           * @param   pDiscoverAttrsExt:
   1808           *            - startAttrID: the first attribute to be selected
   1809           *            - maxAttrIDs: maximum number of returned attributes
   1810           * @param   direction - direction of the command
   1811           * @param   seqNum - transaction sequence number
   1812           *
   1813           * @return  ZSuccess if OK
   1814           */
   1815          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1816                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1817                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1818          {
   1819            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1820            ZStatus_t status;
   1821          
   1822            // Load the buffer - serially
   1823            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1824            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1825            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1826          
   1827            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1828                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1829          
   1830            return ( status );
   1831          }
   1832          
   1833          /*********************************************************************
   1834           * @fn      zcl_SendDiscoverAttrsExtRsp
   1835           *
   1836           * @brief   Send a Discover Attributes Extended Response command
   1837           *
   1838           * @param   dstAddr - destination address
   1839           * @param   clusterID - cluster ID
   1840           * @param   pDiscoverRspCmd:
   1841           *            - discComplete: indicates whether all requested attributes returned
   1842           *            - attrID: attribute ID
   1843           *            - attrDataType: data type of the given attribute
   1844           *            - attrAccessControl: access control of the given attribute
   1845           * @param   direction - direction of the command
   1846           * @param   seqNum - transaction sequence number
   1847           *
   1848           * @return  ZSuccess if OK
   1849           */
   1850          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1851                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1852                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1853          {
   1854            uint8 *buf;
   1855            uint8 i;
   1856            uint16 dataLen = 1; // Discovery complete
   1857            ZStatus_t status;
   1858          
   1859            // calculate the size of the command
   1860            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1861          
   1862            buf = zcl_mem_alloc( dataLen );
   1863            if ( buf != NULL )
   1864            {
   1865              // Load the buffer - serially
   1866              uint8 *pBuf = buf;
   1867              *pBuf++ = pDiscoverRspCmd->discComplete;
   1868              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1869              {
   1870                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1871                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1872                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1873                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1874              }
   1875          
   1876              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1877                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1878              zcl_mem_free( buf );
   1879            }
   1880            else
   1881            {
   1882              status = ZMemError;
   1883            }
   1884          
   1885            return ( status );
   1886          }
   1887          #endif // ZCL_DISCOVER
   1888          
   1889          /*********************************************************************
   1890           * @fn      zcl_ProcessMessageMSG
   1891           *
   1892           * @brief   Data message processor callback.  This function processes
   1893           *          any incoming data - probably from other devices.  So, based
   1894           *          on cluster ID, perform the intended action.
   1895           *
   1896           * @param   pkt - incoming message
   1897           *
   1898           * @return  zclProcMsgStatus_t
   1899           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F583         MOV     DPH,A
   \   000006                REQUIRE ??Subroutine49_0
   \   000006                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1900          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1901          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1902            endPointDesc_t *epDesc;
   1903            zclIncoming_t inMsg;
   1904            zclLibPlugin_t *pInPlugin;
   1905            zclDefaultRspCmd_t defautlRspCmd;
   1906            uint8 options;
   1907            uint8 securityEnable;
   1908            uint8 interPanMsg;
   1909            ZStatus_t status = ZFailure;
   1910            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   1911          
   1912            if ( pkt->cmd.DataLength == 0 )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   F582         MOV     DPL,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   F583         MOV     DPH,A
   \   00001A   12....       LCALL   ??Subroutine53_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   00001D   7005         JNZ     ??zcl_ProcessMessageMSG_0
   1913            {
   1914              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   00001F   7901         MOV     R1,#0x1
   \   000021   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1915            }
   1916          
   1917            // Initialize
   1918            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000024   90....       MOV     DPTR,#rawAFMsg
   \   000027   EE           MOV     A,R6
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EF           MOV     A,R7
   \   00002B   F0           MOVX    @DPTR,A
   1919            inMsg.msg = pkt;
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   EE           MOV     A,R6
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   EF           MOV     A,R7
   \   000036   F0           MOVX    @DPTR,A
   1920            inMsg.attrCmd = NULL;
   \   000037   740C         MOV     A,#0xc
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1921            inMsg.pData = NULL;
   \   000040   7408         MOV     A,#0x8
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E4           CLR     A
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   F0           MOVX    @DPTR,A
   1922            inMsg.pDataLen = 0;
   \   000049   740A         MOV     A,#0xa
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   E4           CLR     A
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \   000051   F0           MOVX    @DPTR,A
   1923          
   1924            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000052   EE           MOV     A,R6
   \   000053   2422         ADD     A,#0x22
   \   000055   F8           MOV     R0,A
   \   000056   E4           CLR     A
   \   000057   3F           ADDC    A,R7
   \   000058   F9           MOV     R1,A
   \   000059   88..         MOV     ?V2,R0
   \   00005B   89..         MOV     ?V3,R1
   \   00005D                ; Setup parameters for call to function zclParseHdr
   \   00005D   8882         MOV     DPL,R0
   \   00005F   F583         MOV     DPH,A
   \   000061   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000064   7402         MOV     A,#0x2
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   AA82         MOV     R2,DPL
   \   00006B   AB83         MOV     R3,DPH
   \   00006D   12....       LCALL   `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000070   8A..         MOV     ?V4,R2
   \   000072   8B..         MOV     ?V5,R3
   \   000074   A8..         MOV     R0,?V4
   \   000076   A9..         MOV     R1,?V5
   \   000078   7408         MOV     A,#0x8
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   12....       LCALL   ?Subroutine13 & 0xFFFF
   1925            inMsg.pDataLen = pkt->cmd.DataLength;
   1926            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_106:
   \   000080   EE           MOV     A,R6
   \   000081   2420         ADD     A,#0x20
   \   000083   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000086   EA           MOV     A,R2
   \   000087   C3           CLR     C
   \   000088   98           SUBB    A,R0
   \   000089   F8           MOV     R0,A
   \   00008A   EB           MOV     A,R3
   \   00008B   99           SUBB    A,R1
   \   00008C   F9           MOV     R1,A
   \   00008D   85..82       MOV     DPL,?V2
   \   000090   85..83       MOV     DPH,?V3
   \   000093   E0           MOVX    A,@DPTR
   \   000094   28           ADD     A,R0
   \   000095   F8           MOV     R0,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   39           ADDC    A,R1
   \   000099   F9           MOV     R1,A
   \   00009A   740A         MOV     A,#0xa
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   12....       LCALL   ?Subroutine13 & 0xFFFF
   1927          
   1928            // Temporary workaround to allow callback functions access to the 
   1929            // transaction sequence number.  Callback functions will call 
   1930            // zcl_getParsedTransSeqNum() to retrieve this number.
   1931            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_107:
   \   0000A2   7406         MOV     A,#0x6
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000AB   F0           MOVX    @DPTR,A
   1932            
   1933            // Find the wanted endpoint
   1934            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000AC                ; Setup parameters for call to function afFindEndPointDesc
   \   0000AC   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   0000AF   F9           MOV     R1,A
   \   0000B0   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   1935            if ( epDesc == NULL )
   \   0000B3   EA           MOV     A,R2
   \   0000B4   4B           ORL     A,R3
   \   0000B5   700C         JNZ     ??zcl_ProcessMessageMSG_2
   1936            {
   1937              rawAFMsg = NULL;
   \   0000B7   90....       MOV     DPTR,#rawAFMsg
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   F0           MOVX    @DPTR,A
   1938              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000BE   7902         MOV     R1,#0x2
   \   0000C0   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1939            }
   1940          
   1941            if ( ( epDesc->simpleDesc == NULL ) ||
   1942                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1943                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C3   8A82         MOV     DPL,R2
   \   0000C5   8B83         MOV     DPH,R3
   \   0000C7   A3           INC     DPTR
   \   0000C8   12....       LCALL   ??Subroutine52_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   0000CB   602F         JZ      ??zcl_ProcessMessageMSG_3
   \   0000CD                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000CD   8A82         MOV     DPL,R2
   \   0000CF   8B83         MOV     DPH,R3
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   F583         MOV     DPH,A
   \   0000D8   8882         MOV     DPL,R0
   \   0000DA   A3           INC     DPTR
   \   0000DB   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000DE   7409         MOV     A,#0x9
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   FD           MOV     R5,A
   \   0000E5   7404         MOV     A,#0x4
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   5403         ANL     A,#0x3
   \   0000ED   FC           MOV     R4,A
   \   0000EE   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000F1   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000F4   7402         MOV     A,#0x2
   \   0000F6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F9   E9           MOV     A,R1
   \   0000FA   700C         JNZ     ??zcl_ProcessMessageMSG_4
   1944            {
   1945              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000FC   90....       MOV     DPTR,#rawAFMsg
   \   0000FF   E4           CLR     A
   \   000100   F0           MOVX    @DPTR,A
   \   000101   A3           INC     DPTR
   \   000102   F0           MOVX    @DPTR,A
   1946              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   000103   7903         MOV     R1,#0x3
   \   000105   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1947            }
   1948          
   1949          #if defined ( INTER_PAN )
   1950            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   \                     ??zcl_ProcessMessageMSG_4:
   \   000108                ; Setup parameters for call to function StubAPS_InterPan
   \   000108   EE           MOV     A,R6
   \   000109   240F         ADD     A,#0xf
   \   00010B   F582         MOV     DPL,A
   \   00010D   E4           CLR     A
   \   00010E   3F           ADDC    A,R7
   \   00010F   F583         MOV     DPH,A
   \   000111   E0           MOVX    A,@DPTR
   \   000112   F9           MOV     R1,A
   \   000113   EE           MOV     A,R6
   \   000114   2410         ADD     A,#0x10
   \   000116   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000119   12....       LCALL   `??StubAPS_InterPan::?relay`; Banked call to: StubAPS_InterPan
   \   00011C   E9           MOV     A,R1
   \   00011D   601D         JZ      ??zcl_ProcessMessageMSG_5
   1951            {
   1952              // No foundation command is supported thru Inter-PAN communication.
   1953              // But the Light Link cluster uses a different Frame Control format
   1954              // for it's Inter-PAN messages, where the messages could be confused
   1955              // with the foundation commands.
   1956              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \   00011F   7402         MOV     A,#0x2
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E0           MOVX    A,@DPTR
   \   000125   5403         ANL     A,#0x3
   \   000127   700C         JNZ     ??zcl_ProcessMessageMSG_6
   1957              {
   1958                rawAFMsg = NULL;
   \   000129   90....       MOV     DPTR,#rawAFMsg
   \   00012C   E4           CLR     A
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   F0           MOVX    @DPTR,A
   1959                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   \   000130   7904         MOV     R1,#0x4
   \   000132   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1960              }
   1961          
   1962              interPanMsg = TRUE;
   \                     ??zcl_ProcessMessageMSG_6:
   \   000135   75..01       MOV     ?V1,#0x1
   1963              options = AF_TX_OPTIONS_NONE;
   \   000138   7A00         MOV     R2,#0x0
   \   00013A   800B         SJMP    ??zcl_ProcessMessageMSG_7
   1964            }
   1965            else
   1966          #endif
   1967            {
   1968              interPanMsg = FALSE;
   \                     ??zcl_ProcessMessageMSG_5:
   \   00013C   75..00       MOV     ?V1,#0x0
   1969              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   00013F                ; Setup parameters for call to function zclGetClusterOption
   \   00013F   12....       LCALL   ?Subroutine22 & 0xFFFF
   1970            }
   \                     ??CrossCallReturnLabel_38:
   \   000142   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   000145   E9           MOV     A,R1
   \   000146   FA           MOV     R2,A
   1971          
   1972            // Find the appropriate plugin
   1973            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \                     ??zcl_ProcessMessageMSG_7:
   \   000147   8E82         MOV     DPL,R6
   \   000149   8F83         MOV     DPH,R7
   \   00014B   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00014E   90....       MOV     DPTR,#plugins
   \   000151   8004         SJMP    ??zcl_ProcessMessageMSG_8
   \                     ??zcl_ProcessMessageMSG_9:
   \   000153   8882         MOV     DPL,R0
   \   000155   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_8:
   \   000157   12....       LCALL   ??Subroutine53_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00015A   7003         JNZ     $+5
   \   00015C   02....       LJMP    ??zcl_ProcessMessageMSG_10 & 0xFFFF
   \   00015F   8882         MOV     DPL,R0
   \   000161   8983         MOV     DPH,R1
   \   000163   A3           INC     DPTR
   \   000164   A3           INC     DPTR
   \   000165   E0           MOVX    A,@DPTR
   \   000166   F5..         MOV     ?V2,A
   \   000168   A3           INC     DPTR
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F5..         MOV     ?V3,A
   \   00016C   C3           CLR     C
   \   00016D   EC           MOV     A,R4
   \   00016E   95..         SUBB    A,?V2
   \   000170   ED           MOV     A,R5
   \   000171   95..         SUBB    A,?V3
   \   000173   40DE         JC      ??zcl_ProcessMessageMSG_9
   \   000175   8882         MOV     DPL,R0
   \   000177   8983         MOV     DPH,R1
   \   000179   A3           INC     DPTR
   \   00017A   A3           INC     DPTR
   \   00017B   A3           INC     DPTR
   \   00017C   A3           INC     DPTR
   \   00017D   C3           CLR     C
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   9C           SUBB    A,R4
   \   000180   A3           INC     DPTR
   \   000181   E0           MOVX    A,@DPTR
   \   000182   9D           SUBB    A,R5
   \   000183   40CE         JC      ??zcl_ProcessMessageMSG_9
   \   000185   7402         MOV     A,#0x2
   \   000187   12....       LCALL   ?XSTACK_DISP0_8
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   5407         ANL     A,#0x7
   \   00018D   700D         JNZ     ??zcl_ProcessMessageMSG_11
   \   00018F   7407         MOV     A,#0x7
   \   000191   12....       LCALL   ?XSTACK_DISP0_8
   \   000194   E0           MOVX    A,@DPTR
   \   000195   640B         XRL     A,#0xb
   \   000197   7003         JNZ     $+5
   \   000199   02....       LJMP    ??zcl_ProcessMessageMSG_12 & 0xFFFF
   1974          
   1975            // Local and remote Security options must match except for Default Response command
   1976            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1977            {
   1978              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_11:
   \   00019C   EA           MOV     A,R2
   \   00019D   A2E6         MOV     C,0xE0 /* A   */.6
   \   00019F   4003         JC      $+5
   \   0001A1   02....       LJMP    ??zcl_ProcessMessageMSG_12 & 0xFFFF
   \   0001A4   EE           MOV     A,R6
   \   0001A5   2419         ADD     A,#0x19
   \   0001A7   F582         MOV     DPL,A
   \   0001A9   E4           CLR     A
   \   0001AA   3F           ADDC    A,R7
   \   0001AB   F583         MOV     DPH,A
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   6003         JZ      $+5
   \   0001B0   02....       LJMP    ??zcl_ProcessMessageMSG_12 & 0xFFFF
   1979          
   1980              // Make sure that Clusters specifically defined to use security are received secure,
   1981              // any other cluster that wants to use APS security will be allowed
   1982              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1983              {
   1984                if ( UNICAST_MSG( inMsg.msg ) )
   \   0001B3   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0001B6   6003         JZ      $+5
   \   0001B8   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   \   0001BB   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   0001BE   6003         JZ      $+5
   \   0001C0   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   1985                {
   1986                  // Send a Default Response command back with no Application Link Key security
   1987                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0001C3   EE           MOV     A,R6
   \   0001C4   2404         ADD     A,#0x4
   \   0001C6   F5..         MOV     ?V0,A
   \   0001C8   E4           CLR     A
   \   0001C9   3F           ADDC    A,R7
   \   0001CA   F5..         MOV     ?V1,A
   \   0001CC   EE           MOV     A,R6
   \   0001CD   2414         ADD     A,#0x14
   \   0001CF   FE           MOV     R6,A
   \   0001D0   5001         JNC     ??zcl_ProcessMessageMSG_14
   \   0001D2   0F           INC     R7
   \                     ??zcl_ProcessMessageMSG_14:
   \   0001D3                ; Setup parameters for call to function zclSetSecurityOption
   \   0001D3   7C00         MOV     R4,#0x0
   \   0001D5   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0001D8   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   1988          
   1989                  defautlRspCmd.statusCode = status;
   \   0001DB   740F         MOV     A,#0xf
   \   0001DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E0   7401         MOV     A,#0x1
   \   0001E2   F0           MOVX    @DPTR,A
   1990                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001E3   7407         MOV     A,#0x7
   \   0001E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   C0E0         PUSH    A
   \   0001EB   740E         MOV     A,#0xe
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   D0E0         POP     A
   \   0001F2   F0           MOVX    @DPTR,A
   1991                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1992                                         inMsg.msg->clusterId, &defautlRspCmd,
   1993                                         !inMsg.hdr.fc.direction, true,
   1994                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0001F3                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   0001F3   7406         MOV     A,#0x6
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   E0           MOVX    A,@DPTR
   \   0001F9   F5..         MOV     ?V2,A
   \   0001FB   78..         MOV     R0,#?V2
   \   0001FD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000200   7405         MOV     A,#0x5
   \   000202   12....       LCALL   ?XSTACK_DISP0_8
   \   000205   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000208   75..01       MOV     ?V2,#0x1
   \   00020B   78..         MOV     R0,#?V2
   \   00020D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000210   7406         MOV     A,#0x6
   \   000212   12....       LCALL   ?XSTACK_DISP0_8
   \   000215   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000218   F5..         MOV     ?V2,A
   \   00021A   78..         MOV     R0,#?V2
   \   00021C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00021F   7413         MOV     A,#0x13
   \   000221   12....       LCALL   ?XSTACK_DISP100_8
   \   000224   88..         MOV     ?V2,R0
   \   000226   89..         MOV     ?V3,R1
   \   000228   78..         MOV     R0,#?V2
   \   00022A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022D   7407         MOV     A,#0x7
   \   00022F   12....       LCALL   ?XSTACK_DISP0_8
   \   000232   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000235   12....       LCALL   ?XSTACK_DISP0_8
   \   000238   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00023B   12....       LCALL   ?XSTACK_DISP0_8
   \   00023E   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000241   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   000244   7407         MOV     A,#0x7
   \   000246   12....       LCALL   ?DEALLOC_XSTACK8
   1995          
   1996                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000249                ; Setup parameters for call to function zclSetSecurityOption
   \   000249   7C01         MOV     R4,#0x1
   \   00024B   12....       LCALL   ?Subroutine28 & 0xFFFF
   1997                }
   \                     ??CrossCallReturnLabel_50:
   \   00024E   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   1998          
   1999                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_13:
   \   000251   90....       MOV     DPTR,#rawAFMsg
   \   000254   E4           CLR     A
   \   000255   F0           MOVX    @DPTR,A
   \   000256   A3           INC     DPTR
   \   000257   F0           MOVX    @DPTR,A
   2000                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000258   7905         MOV     R1,#0x5
   \   00025A   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2001              }
   2002            }
   \                     ??zcl_ProcessMessageMSG_10:
   \   00025D   7800         MOV     R0,#0x0
   \   00025F   7900         MOV     R1,#0x0
   2003          
   2004            // Is this a foundation type message
   2005            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   000261   E5..         MOV     A,?V1
   \   000263   A2E0         MOV     C,0xE0 /* A   */.0
   \   000265   5003         JNC     $+5
   \   000267   02....       LJMP    ??zcl_ProcessMessageMSG_15 & 0xFFFF
   \   00026A   7402         MOV     A,#0x2
   \   00026C   12....       LCALL   ?XSTACK_DISP0_8
   \   00026F   E0           MOVX    A,@DPTR
   \   000270   5403         ANL     A,#0x3
   \   000272   6003         JZ      $+5
   \   000274   02....       LJMP    ??zcl_ProcessMessageMSG_15 & 0xFFFF
   2006            {
   2007              if ( inMsg.hdr.fc.manuSpecific )
   \   000277   E0           MOVX    A,@DPTR
   \   000278   5404         ANL     A,#0x4
   \   00027A   6005         JZ      ??zcl_ProcessMessageMSG_16
   2008              {
   2009                // We don't support any manufacturer specific command
   2010                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   00027C   7E84         MOV     R6,#-0x7c
   \   00027E   02....       LJMP    ??zcl_ProcessMessageMSG_17 & 0xFFFF
   2011              }
   2012              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2013                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_16:
   \   000281   7407         MOV     A,#0x7
   \   000283   12....       LCALL   ?XSTACK_DISP0_8
   \   000286   E0           MOVX    A,@DPTR
   \   000287   C3           CLR     C
   \   000288   9417         SUBB    A,#0x17
   \   00028A   4003         JC      $+5
   \   00028C   02....       LJMP    ??zcl_ProcessMessageMSG_18 & 0xFFFF
   \   00028F   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000292   12....       LCALL   ?S_SHL
   \   000295   74..         MOV     A,#zclCmdTable & 0xff
   \   000297   25..         ADD     A,?V2
   \   000299   F582         MOV     DPL,A
   \   00029B   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00029D   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0002A0   7003         JNZ     $+5
   \   0002A2   02....       LJMP    ??zcl_ProcessMessageMSG_18 & 0xFFFF
   2014              {
   2015                zclParseCmd_t parseCmd;
   2016          
   2017                parseCmd.endpoint = pkt->endPoint;
   \   0002A5   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0002A8   C0E0         PUSH    A
   \   0002AA   7410         MOV     A,#0x10
   \   0002AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AF   D0E0         POP     A
   \   0002B1   F0           MOVX    @DPTR,A
   2018                parseCmd.dataLen = inMsg.pDataLen;
   \   0002B2   740A         MOV     A,#0xa
   \   0002B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B7   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0002BA   7411         MOV     A,#0x11
   \   0002BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BF   12....       LCALL   ?Subroutine13 & 0xFFFF
   2019                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_108:
   \   0002C2   7408         MOV     A,#0x8
   \   0002C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C7   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0002CA   7413         MOV     A,#0x13
   \   0002CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CF   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   0002D2                ; Setup parameters for indirect call
   \   0002D2   7410         MOV     A,#0x10
   \   0002D4   12....       LCALL   ?XSTACK_DISP101_8
   \   0002D7   7407         MOV     A,#0x7
   \   0002D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DC   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   0002DF   12....       LCALL   ?S_SHL
   \   0002E2   74..         MOV     A,#zclCmdTable & 0xff
   \   0002E4   25..         ADD     A,?V2
   \   0002E6   F582         MOV     DPL,A
   \   0002E8   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002EA   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0002ED   C0E0         PUSH    A
   \   0002EF   7401         MOV     A,#0x1
   \   0002F1   93           MOVC    A,@A+DPTR
   \   0002F2   F583         MOV     DPH,A
   \   0002F4   D082         POP     DPL
   2020          
   2021                // Parse the command, remember that the return value is a pointer to allocated memory
   2022                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   0002F6   12....       LCALL   ?CALL_IND
   \   0002F9   8A..         MOV     ?V2,R2
   \   0002FB   8B..         MOV     ?V3,R3
   \   0002FD   A8..         MOV     R0,?V2
   \   0002FF   A9..         MOV     R1,?V3
   \   000301   740C         MOV     A,#0xc
   \   000303   12....       LCALL   ?XSTACK_DISP0_8
   \   000306   12....       LCALL   ?Subroutine13 & 0xFFFF
   2023                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_110:
   \   000309   E8           MOV     A,R0
   \   00030A   49           ORL     A,R1
   \   00030B   6053         JZ      ??zcl_ProcessMessageMSG_19
   \   00030D   7407         MOV     A,#0x7
   \   00030F   12....       LCALL   ?XSTACK_DISP0_8
   \   000312   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000315   12....       LCALL   ?S_SHL
   \   000318   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   00031A   25..         ADD     A,?V2
   \   00031C   F582         MOV     DPL,A
   \   00031E   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   000320   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000323   6030         JZ      ??zcl_ProcessMessageMSG_20
   2024                {
   2025                  // Process the command
   2026                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000325                ; Setup parameters for indirect call
   \   000325   AA..         MOV     R2,?XSP + 0
   \   000327   AB..         MOV     R3,?XSP + 1
   \   000329   7407         MOV     A,#0x7
   \   00032B   12....       LCALL   ?XSTACK_DISP0_8
   \   00032E   12....       LCALL   ?Subroutine19 & 0xFFFF
   2027                  {
   2028                    // Couldn't find attribute in the table.
   2029                  }
   2030                }
   \                     ??CrossCallReturnLabel_29:
   \   000331   12....       LCALL   ?S_SHL
   \   000334   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   000336   25..         ADD     A,?V2
   \   000338   F582         MOV     DPL,A
   \   00033A   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   00033C   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00033F   C0E0         PUSH    A
   \   000341   7401         MOV     A,#0x1
   \   000343   93           MOVC    A,@A+DPTR
   \   000344   F583         MOV     DPH,A
   \   000346   D082         POP     DPL
   \   000348   12....       LCALL   ?CALL_IND
   2031          
   2032                // Free the buffer
   2033                if ( inMsg.attrCmd )
   \   00034B   740C         MOV     A,#0xc
   \   00034D   12....       LCALL   ?XSTACK_DISP0_8
   \   000350   12....       LCALL   ??Subroutine53_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000353   600B         JZ      ??zcl_ProcessMessageMSG_19
   2034                {
   2035                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_20:
   \   000355                ; Setup parameters for call to function osal_mem_free
   \   000355   740C         MOV     A,#0xc
   \   000357   12....       LCALL   ?XSTACK_DISP0_8
   \   00035A   12....       LCALL   ??Subroutine49_0 & 0xFFFF
   2036                }
   \                     ??CrossCallReturnLabel_97:
   \   00035D   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2037          
   2038                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000360   7407         MOV     A,#0x7
   \   000362   12....       LCALL   ?XSTACK_DISP0_8
   \   000365   E0           MOVX    A,@DPTR
   \   000366   606B         JZ      ??zcl_ProcessMessageMSG_21
   \   000368   6402         XRL     A,#0x2
   \   00036A   6067         JZ      ??zcl_ProcessMessageMSG_21
   \   00036C   E0           MOVX    A,@DPTR
   \   00036D   6403         XRL     A,#0x3
   \   00036F   6062         JZ      ??zcl_ProcessMessageMSG_21
   \   000371   E0           MOVX    A,@DPTR
   \   000372   6406         XRL     A,#0x6
   \   000374   605D         JZ      ??zcl_ProcessMessageMSG_21
   \   000376   E0           MOVX    A,@DPTR
   \   000377   6408         XRL     A,#0x8
   \   000379   6058         JZ      ??zcl_ProcessMessageMSG_21
   \   00037B   E0           MOVX    A,@DPTR
   \   00037C   640C         XRL     A,#0xc
   \   00037E   6053         JZ      ??zcl_ProcessMessageMSG_21
   \   000380   E0           MOVX    A,@DPTR
   \   000381   6411         XRL     A,#0x11
   \   000383   604E         JZ      ??zcl_ProcessMessageMSG_21
   \   000385   E0           MOVX    A,@DPTR
   \   000386   6413         XRL     A,#0x13
   \   000388   6049         JZ      ??zcl_ProcessMessageMSG_21
   \   00038A   E0           MOVX    A,@DPTR
   \   00038B   6415         XRL     A,#0x15
   \   00038D   6044         JZ      ??zcl_ProcessMessageMSG_21
   \   00038F   E0           MOVX    A,@DPTR
   \   000390   640B         XRL     A,#0xb
   \   000392   603F         JZ      ??zcl_ProcessMessageMSG_21
   2039                {
   2040                  rawAFMsg = NULL;
   2041                  return ( ZCL_PROC_SUCCESS ); // We're done
   2042                }
   2043          
   2044                status = ZSuccess;
   \   000394   7E00         MOV     R6,#0x0
   \   000396   805B         SJMP    ??zcl_ProcessMessageMSG_17
   2045              }
   2046              else
   2047              {
   2048                // Unsupported message
   2049                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_18:
   \   000398   7E82         MOV     R6,#-0x7e
   \   00039A   8057         SJMP    ??zcl_ProcessMessageMSG_17
   2050              }
   2051            }
   2052            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2053            {
   2054              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_15:
   \   00039C   E8           MOV     A,R0
   \   00039D   49           ORL     A,R1
   \   00039E   6043         JZ      ??zcl_ProcessMessageMSG_22
   \   0003A0   8882         MOV     DPL,R0
   \   0003A2   8983         MOV     DPH,R1
   \   0003A4   A3           INC     DPTR
   \   0003A5   A3           INC     DPTR
   \   0003A6   A3           INC     DPTR
   \   0003A7   A3           INC     DPTR
   \   0003A8   A3           INC     DPTR
   \   0003A9   A3           INC     DPTR
   \   0003AA   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0003AD   6034         JZ      ??zcl_ProcessMessageMSG_22
   2055              {
   2056                // The return value of the plugin function will be
   2057                //  ZSuccess - Supported and need default response
   2058                //  ZFailure - Unsupported
   2059                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2060                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2061                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2062                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2063                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   0003AF                ; Setup parameters for indirect call
   \   0003AF   AA..         MOV     R2,?XSP + 0
   \   0003B1   AB..         MOV     R3,?XSP + 1
   \   0003B3   8882         MOV     DPL,R0
   \   0003B5   8983         MOV     DPH,R1
   \   0003B7   A3           INC     DPTR
   \   0003B8   A3           INC     DPTR
   \   0003B9   A3           INC     DPTR
   \   0003BA   A3           INC     DPTR
   \   0003BB   A3           INC     DPTR
   \   0003BC   A3           INC     DPTR
   \   0003BD   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0003C0   12....       LCALL   ?CALL_IND
   \   0003C3   E9           MOV     A,R1
   \   0003C4   FE           MOV     R6,A
   2064                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   0003C5   74FF         MOV     A,#-0x1
   \   0003C7   6E           XRL     A,R6
   \   0003C8   6009         JZ      ??zcl_ProcessMessageMSG_21
   \   0003CA   E5..         MOV     A,?V1
   \   0003CC   A2E0         MOV     C,0xE0 /* A   */.0
   \   0003CE   500E         JNC     ??zcl_ProcessMessageMSG_23
   \   0003D0   EE           MOV     A,R6
   \   0003D1   700B         JNZ     ??zcl_ProcessMessageMSG_23
   2065                {
   2066                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   0003D3   90....       MOV     DPTR,#rawAFMsg
   \   0003D6   E4           CLR     A
   \   0003D7   F0           MOVX    @DPTR,A
   \   0003D8   A3           INC     DPTR
   \   0003D9   F0           MOVX    @DPTR,A
   2067                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   0003DA   F9           MOV     R1,A
   \   0003DB   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2068                }
   2069              }
   2070          
   2071              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_23:
   \   0003DE   7401         MOV     A,#0x1
   \   0003E0   6E           XRL     A,R6
   \   0003E1   7010         JNZ     ??zcl_ProcessMessageMSG_17
   2072              {
   2073                // Unsupported message
   2074                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_22:
   \   0003E3   7402         MOV     A,#0x2
   \   0003E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E8   E0           MOVX    A,@DPTR
   \   0003E9   5404         ANL     A,#0x4
   \   0003EB   6004         JZ      ??zcl_ProcessMessageMSG_24
   2075                {
   2076                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   0003ED   7E83         MOV     R6,#-0x7d
   \   0003EF   8002         SJMP    ??zcl_ProcessMessageMSG_17
   2077                }
   2078                else
   2079                {
   2080                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_24:
   \   0003F1   7E81         MOV     R6,#-0x7f
   2081                }
   2082              }
   2083            }
   2084          
   2085            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_17:
   \   0003F3   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0003F6   707D         JNZ     ??zcl_ProcessMessageMSG_25
   \   0003F8   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   0003FB   7078         JNZ     ??zcl_ProcessMessageMSG_25
   \   0003FD   7402         MOV     A,#0x2
   \   0003FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000402   E0           MOVX    A,@DPTR
   \   000403   5410         ANL     A,#0x10
   \   000405   706E         JNZ     ??zcl_ProcessMessageMSG_25
   2086            {
   2087              // Send a Default Response command back
   2088              defautlRspCmd.statusCode = status;
   \   000407   740F         MOV     A,#0xf
   \   000409   12....       LCALL   ?XSTACK_DISP0_8
   \   00040C   EE           MOV     A,R6
   \   00040D   F0           MOVX    @DPTR,A
   2089              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00040E   7407         MOV     A,#0x7
   \   000410   12....       LCALL   ?XSTACK_DISP0_8
   \   000413   E0           MOVX    A,@DPTR
   \   000414   C0E0         PUSH    A
   \   000416   740E         MOV     A,#0xe
   \   000418   12....       LCALL   ?XSTACK_DISP0_8
   \   00041B   D0E0         POP     A
   \   00041D   F0           MOVX    @DPTR,A
   2090              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2091                                     inMsg.msg->clusterId, &defautlRspCmd,
   2092                                     !inMsg.hdr.fc.direction, true,
   2093                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   00041E                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   00041E   7406         MOV     A,#0x6
   \   000420   12....       LCALL   ?XSTACK_DISP0_8
   \   000423   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000426   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000429   7405         MOV     A,#0x5
   \   00042B   12....       LCALL   ?XSTACK_DISP0_8
   \   00042E   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000431   75..01       MOV     ?V0,#0x1
   \   000434   78..         MOV     R0,#?V0
   \   000436   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000439   7406         MOV     A,#0x6
   \   00043B   12....       LCALL   ?XSTACK_DISP0_8
   \   00043E   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000441   F5..         MOV     ?V0,A
   \   000443   78..         MOV     R0,#?V0
   \   000445   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000448   7413         MOV     A,#0x13
   \   00044A   12....       LCALL   ?XSTACK_DISP100_8
   \   00044D   88..         MOV     ?V0,R0
   \   00044F   89..         MOV     ?V1,R1
   \   000451   78..         MOV     R0,#?V0
   \   000453   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000456   7407         MOV     A,#0x7
   \   000458   12....       LCALL   ?XSTACK_DISP0_8
   \   00045B   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00045E   12....       LCALL   ?XSTACK_DISP0_8
   \   000461   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000464   12....       LCALL   ?XSTACK_DISP0_8
   \   000467   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00046A   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   00046D   7407         MOV     A,#0x7
   \   00046F   12....       LCALL   ?DEALLOC_XSTACK8
   2094              defaultResponseSent = TRUE;
   \   000472   75..01       MOV     ?V0,#0x1
   2095            }
   2096          
   2097            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_25:
   \   000475   90....       MOV     DPTR,#rawAFMsg
   \   000478   E4           CLR     A
   \   000479   F0           MOVX    @DPTR,A
   \   00047A   A3           INC     DPTR
   \   00047B   F0           MOVX    @DPTR,A
   2098            if ( status == ZSuccess )
   \   00047C   EE           MOV     A,R6
   \   00047D   7004         JNZ     ??zcl_ProcessMessageMSG_26
   2099            {
   2100              return ( ZCL_PROC_SUCCESS );
   \   00047F   7900         MOV     R1,#0x0
   \   000481   801F         SJMP    ??zcl_ProcessMessageMSG_1
   2101            }
   2102            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_26:
   \   000483   7484         MOV     A,#-0x7c
   \   000485   6E           XRL     A,R6
   \   000486   700E         JNZ     ??zcl_ProcessMessageMSG_27
   2103            {
   2104              if ( defaultResponseSent )
   \   000488   E5..         MOV     A,?V0
   \   00048A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00048C   5004         JNC     ??zcl_ProcessMessageMSG_28
   2105              {
   2106                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00048E   7907         MOV     R1,#0x7
   \   000490   8010         SJMP    ??zcl_ProcessMessageMSG_1
   2107              }
   2108              else
   2109              {
   2110                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_28:
   \   000492   7906         MOV     R1,#0x6
   \   000494   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2111              }
   2112            }
   2113            else
   2114            {
   2115              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_27:
   \   000496   E5..         MOV     A,?V0
   \   000498   A2E0         MOV     C,0xE0 /* A   */.0
   \   00049A   5004         JNC     ??zcl_ProcessMessageMSG_29
   2116              {
   2117                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   00049C   7909         MOV     R1,#0x9
   \   00049E   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2118              }
   2119              else
   2120              {
   2121                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_29:
   \   0004A0   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   0004A2   7415         MOV     A,#0x15
   \   0004A4   12....       LCALL   ?DEALLOC_XSTACK8
   2122              }
   2123            }
   \   0004A7   02....       LJMP    ?Subroutine3 & 0xFFFF
   2124          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000003   F8           MOV     R0,A
   \   000004   7401         MOV     A,#0x1
   \   000006   93           MOVC    A,@A+DPTR
   \   000007   F9           MOV     R1,A
   \   000008   E8           MOV     A,R0
   \   000009   49           ORL     A,R1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   35..         ADDC    A,?V3
   \   000002   F583         MOV     DPH,A
   \   000004   E4           CLR     A
   \   000005   93           MOVC    A,@A+DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   EE           MOV     A,R6
   \   000001   2414         ADD     A,#0x14
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7407         MOV     A,#0x7
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F8           MOV     R0,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   C8           XCH     A,R0
   \   00000B   2415         ADD     A,#0x15
   \   00000D   F582         MOV     DPL,A
   \   00000F   E4           CLR     A
   \   000010   38           ADDC    A,R0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   00000B   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00000E   F9           MOV     R1,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FC           MOV     R4,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FD           MOV     R5,A
   \   00000C   7407         MOV     A,#0x7
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   75..00       MOV     ?V3,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000009                REQUIRE ??Subroutine52_0
   \   000009                ; // Fall through to label ??Subroutine52_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
   2125          
   2126          /*********************************************************************
   2127           * PRIVATE FUNCTIONS
   2128           *********************************************************************/
   2129          
   2130          /*********************************************************************
   2131           * @fn      zclParseHdr
   2132           *
   2133           * @brief   Parse header of the ZCL format
   2134           *
   2135           * @param   hdr - place to put the frame control information
   2136           * @param   pData - incoming buffer to parse
   2137           *
   2138           * @return  pointer past the header
   2139           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2140          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2141          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2142            // Clear the header
   2143            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2144          
   2145            // Parse the Frame Control
   2146            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   F8           MOV     R0,A
   \   00002B   EA           MOV     A,R2
   \   00002C   48           ORL     A,R0
   \   00002D   F8           MOV     R0,A
   \   00002E   EB           MOV     A,R3
   \   00002F   F9           MOV     R1,A
   \   000030   85..82       MOV     DPL,?V0
   \   000033   85..83       MOV     DPH,?V1
   \   000036   12....       LCALL   ?Subroutine13 & 0xFFFF
   2147            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_111:
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   A2E2         MOV     C,0xE0 /* A   */.2
   \   000040   5004         JNC     ??zclParseHdr_0
   \   000042   D2F0         SETB    B.0
   \   000044   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000046   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   000048   85..82       MOV     DPL,?V0
   \   00004B   85..83       MOV     DPH,?V1
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   54FB         ANL     A,#0xfb
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A2F0         MOV     C,B.0
   \   000054   E4           CLR     A
   \   000055   33           RLC     A
   \   000056   F5..         MOV     ?V2,A
   \   000058   75..00       MOV     ?V3,#0x0
   \   00005B   7402         MOV     A,#0x2
   \   00005D   78..         MOV     R0,#?V2
   \   00005F   12....       LCALL   ?S_SHL
   \   000062   E0           MOVX    A,@DPTR
   \   000063   45..         ORL     A,?V2
   \   000065   12....       LCALL   ?Subroutine15 & 0xFFFF
   2148            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_19:
   \   000068   E0           MOVX    A,@DPTR
   \   000069   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006B   85..82       MOV     DPL,?V0
   \   00006E   85..83       MOV     DPH,?V1
   \   000071   E0           MOVX    A,@DPTR
   \   000072   5004         JNC     ??zclParseHdr_2
   2149            {
   2150              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000074   4408         ORL     A,#0x8
   \   000076   8002         SJMP    ??zclParseHdr_3
   2151            }
   2152            else
   2153            {
   2154              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000078   54F7         ANL     A,#0xf7
   2155            }
   \                     ??zclParseHdr_3:
   \   00007A   12....       LCALL   ?Subroutine15 & 0xFFFF
   2156          
   2157            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_20:
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   A2E4         MOV     C,0xE0 /* A   */.4
   \   000080   5004         JNC     ??zclParseHdr_4
   \   000082   D2F0         SETB    B.0
   \   000084   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000086   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000088   85..82       MOV     DPL,?V0
   \   00008B   85..83       MOV     DPH,?V1
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   54EF         ANL     A,#0xef
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A2F0         MOV     C,B.0
   \   000094   E4           CLR     A
   \   000095   33           RLC     A
   \   000096   F5..         MOV     ?V2,A
   \   000098   7404         MOV     A,#0x4
   \   00009A   78..         MOV     R0,#?V2
   \   00009C   12....       LCALL   ?S_SHL
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   45..         ORL     A,?V2
   \   0000A2   12....       LCALL   ?Subroutine11 & 0xFFFF
   2158            pData++;  // move past the frame control field
   \                     ??CrossCallReturnLabel_11:
   \   0000A5   AE82         MOV     R6,DPL
   \   0000A7   AF83         MOV     R7,DPH
   2159          
   2160            // parse the manfacturer code
   2161            if ( hdr->fc.manuSpecific )
   \   0000A9   85..82       MOV     DPL,?V0
   \   0000AC   85..83       MOV     DPH,?V1
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   5404         ANL     A,#0x4
   \   0000B2   601C         JZ      ??zclParseHdr_6
   2162            {
   2163              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000B4   8E82         MOV     DPL,R6
   \   0000B6   8F83         MOV     DPH,R7
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   FA           MOV     R2,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F9           MOV     R1,A
   \   0000BD   EA           MOV     A,R2
   \   0000BE   85..82       MOV     DPL,?V0
   \   0000C1   85..83       MOV     DPH,?V1
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   2164              pData += 2;
   \                     ??CrossCallReturnLabel_104:
   \   0000C9   EE           MOV     A,R6
   \   0000CA   2402         ADD     A,#0x2
   \   0000CC   FE           MOV     R6,A
   \   0000CD   5001         JNC     ??zclParseHdr_6
   \   0000CF   0F           INC     R7
   2165            }
   2166          
   2167            // parse the Transaction Sequence Number
   2168            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000D0   8E82         MOV     DPL,R6
   \   0000D2   8F83         MOV     DPH,R7
   \   0000D4   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000D7   12....       LCALL   ?Subroutine11 & 0xFFFF
   2169          
   2170            // parse the Cluster's command ID
   2171            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_12:
   \   0000DA   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000DD   A3           INC     DPTR
   \   0000DE   F0           MOVX    @DPTR,A
   2172          
   2173            // Should point to the frame payload
   2174            return ( pData );
   \   0000DF   EE           MOV     A,R6
   \   0000E0   2402         ADD     A,#0x2
   \   0000E2   FA           MOV     R2,A
   \   0000E3   E4           CLR     A
   \   0000E4   3F           ADDC    A,R7
   \   0000E5   FB           MOV     R3,A
   \   0000E6   02....       LJMP    ?Subroutine1 & 0xFFFF
   2175          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET
   2176          
   2177          /*********************************************************************
   2178           * @fn      zclBuildHdr
   2179           *
   2180           * @brief   Build header of the ZCL format
   2181           *
   2182           * @param   hdr - outgoing header information
   2183           * @param   pData - outgoing header space
   2184           *
   2185           * @return  pointer past the header
   2186           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2187          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2188          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2189            // Build the Frame Control byte
   2190            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine54_0 & 0xFFFF
   2191            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_128:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine16 & 0xFFFF
   2192            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_126:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine16 & 0xFFFF
   2193            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_127:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   F0           MOVX    @DPTR,A
   2194            pData++;  // move past the frame control field
   \   000027   A3           INC     DPTR
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   2195          
   2196            // Add the manfacturer code
   2197            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   E0           MOVX    A,@DPTR
   \   000031   5404         ANL     A,#0x4
   \   000033   601A         JZ      ??zclBuildHdr_0
   2198            {
   2199              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   EA           MOV     A,R2
   \   000036   2402         ADD     A,#0x2
   \   000038   F8           MOV     R0,A
   \   000039   E4           CLR     A
   \   00003A   3B           ADDC    A,R3
   \   00003B   F9           MOV     R1,A
   \   00003C   8882         MOV     DPL,R0
   \   00003E   8983         MOV     DPH,R1
   \   000040   E0           MOVX    A,@DPTR
   \   000041   8C82         MOV     DPL,R4
   \   000043   8D83         MOV     DPH,R5
   \   000045   12....       LCALL   ?Subroutine14 & 0xFFFF
   2200              *pData++ = HI_UINT16( hdr->manuCode );
   2201            }
   \                     ??CrossCallReturnLabel_18:
   \   000048   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00004B   FC           MOV     R4,A
   \   00004C   5001         JNC     ??zclBuildHdr_0
   \   00004E   0D           INC     R5
   2202          
   2203            // Add the Transaction Sequence Number
   2204            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   8C82         MOV     DPL,R4
   \   00005A   8D83         MOV     DPH,R5
   \   00005C   F0           MOVX    @DPTR,A
   2205          
   2206            // Add the Cluster's command ID
   2207            *pData++ = hdr->commandID;
   \   00005D   8A82         MOV     DPL,R2
   \   00005F   8B83         MOV     DPH,R3
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   12....       LCALL   ?Subroutine33 & 0xFFFF
   2208          
   2209            // Should point to the frame payload
   2210            return ( pData );
   \                     ??CrossCallReturnLabel_57:
   \   000069   FA           MOV     R2,A
   \   00006A   E4           CLR     A
   \   00006B   3D           ADDC    A,R5
   \   00006C   FB           MOV     R3,A
   \   00006D                REQUIRE ?Subroutine4
   \   00006D                ; // Fall through to label ?Subroutine4
   2211          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   EC           MOV     A,R4
   \   000008   2402         ADD     A,#0x2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine54_0
   \   000007                ; // Fall through to label ??Subroutine54_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine54_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   2212          
   2213          /*********************************************************************
   2214           * @fn      zclCalcHdrSize
   2215           *
   2216           * @brief   Calculate the number of bytes needed for an outgoing
   2217           *          ZCL header.
   2218           *
   2219           * @param   hdr - outgoing header information
   2220           *
   2221           * @return  returns the number of bytes needed
   2222           */
   2223          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2224          {
   2225            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2226          
   2227            // Add the manfacturer code
   2228            if ( hdr->fc.manuSpecific )
   2229            {
   2230              needed += 2;
   2231            }
   2232          
   2233            return ( needed );
   2234          }
   2235          
   2236          /*********************************************************************
   2237           * @fn      zclFindPlugin
   2238           *
   2239           * @brief   Find the right plugin for a cluster ID
   2240           *
   2241           * @param   clusterID - cluster ID to look for
   2242           * @param   profileID - profile ID
   2243           *
   2244           * @return  pointer to plugin, NULL if not found
   2245           */
   2246          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2247          {
   2248            zclLibPlugin_t *pLoop = plugins;
   2249          
   2250            (void)profileID;  // Intentionally unreferenced parameter
   2251          
   2252            while ( pLoop != NULL )
   2253            {
   2254              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2255              {
   2256                return ( pLoop );
   2257              }
   2258          
   2259              pLoop = pLoop->next;
   2260            }
   2261          
   2262            return ( (zclLibPlugin_t *)NULL );
   2263          }
   2264          
   2265          #ifdef ZCL_DISCOVER
   2266          /*********************************************************************
   2267           * @fn      zclFindCmdRecsList
   2268           *
   2269           * @brief   Find the right command record list for an endpoint
   2270           *
   2271           * @param   endpoint - endpoint to look for
   2272           *
   2273           * @return  pointer to record list, NULL if not found
   2274           */
   2275          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2276          {
   2277            zclCmdRecsList_t *pLoop = gpCmdList;
   2278          
   2279            while ( pLoop != NULL )
   2280            {
   2281              if ( pLoop->endpoint == endpoint )
   2282              {
   2283                return ( pLoop );
   2284              }
   2285          
   2286              pLoop = pLoop->pNext;
   2287            }
   2288          
   2289            return ( NULL );
   2290          }
   2291          
   2292          /*********************************************************************
   2293           * @fn      zclFindCmdRec
   2294           *
   2295           * @brief   Find the command record that matchs the parameters
   2296           *
   2297           * @param   endpoint - Application's endpoint
   2298           * @param   clusterID - cluster ID
   2299           * @param   attrId - attribute looking for
   2300           * @param   pAttr - attribute record to be returned
   2301           *
   2302           * @return  TRUE if record found. FALSE, otherwise.
   2303           */
   2304          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2305          {
   2306            uint8 i;
   2307            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2308          
   2309            if ( pRec != NULL )
   2310            {
   2311              for ( i = 0; i < pRec->numCommands; i++ )
   2312              {
   2313                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2314                {
   2315                  *pCmd = pRec->pCmdRecs[i];
   2316          
   2317                  return ( TRUE ); // EMBEDDED RETURN
   2318                }
   2319              }
   2320            }
   2321          
   2322            return ( FALSE );
   2323          }
   2324          #endif // ZCL_DISCOVER
   2325          
   2326          /*********************************************************************
   2327           * @fn      zclFindAttrRecsList
   2328           *
   2329           * @brief   Find the right attribute record list for an endpoint
   2330           *
   2331           * @param   clusterID - endpointto look for
   2332           *
   2333           * @return  pointer to record list, NULL if not found
   2334           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2335          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2336          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2337            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2338          
   2339            while ( pLoop != NULL )
   2340            {
   2341              if ( pLoop->endpoint == endpoint )
   2342              {
   2343                return ( pLoop );
   2344              }
   2345          
   2346              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2347            }
   2348          
   2349            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2350          }
   2351          
   2352          /*********************************************************************
   2353           * @fn      zclFindAttrRec
   2354           *
   2355           * @brief   Find the attribute record that matchs the parameters
   2356           *
   2357           * @param   endpoint - Application's endpoint
   2358           * @param   clusterID - cluster ID
   2359           * @param   attrId - attribute looking for
   2360           * @param   pAttr - attribute record to be returned
   2361           *
   2362           * @return  TRUE if record found. FALSE, otherwise.
   2363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2364          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2365          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2366            uint8 x;
   2367            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   2368          
   2369            if ( pRec != NULL )
   \   000010   EA           MOV     A,R2
   \   000011   4B           ORL     A,R3
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??zclFindAttrRec_0 & 0xFFFF
   2370            {
   2371              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000017   75..00       MOV     ?V0,#0x0
   \   00001A   8002         SJMP    ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001C   05..         INC     ?V0
   \                     ??zclFindAttrRec_1:
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   E5..         MOV     A,?V0
   \   00002D   C3           CLR     C
   \   00002E   98           SUBB    A,R0
   \   00002F   507D         JNC     ??zclFindAttrRec_0
   2372              {
   2373                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000031   85....       MOV     ?V6,?V0
   \   000034   75..00       MOV     ?V7,#0x0
   \   000037   7403         MOV     A,#0x3
   \   000039   78..         MOV     R0,#?V6
   \   00003B   12....       LCALL   ?S_SHL
   \   00003E   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000041   E4           CLR     A
   \   000042   93           MOVC    A,@A+DPTR
   \   000043   F8           MOV     R0,A
   \   000044   7401         MOV     A,#0x1
   \   000046   93           MOVC    A,@A+DPTR
   \   000047   F9           MOV     R1,A
   \   000048   E5..         MOV     A,?V2
   \   00004A   68           XRL     A,R0
   \   00004B   7003         JNZ     ??zclFindAttrRec_3
   \   00004D   E5..         MOV     A,?V3
   \   00004F   69           XRL     A,R1
   \                     ??zclFindAttrRec_3:
   \   000050   70CA         JNZ     ??zclFindAttrRec_2
   \   000052   85....       MOV     ?V6,?V0
   \   000055   75..00       MOV     ?V7,#0x0
   \   000058   7403         MOV     A,#0x3
   \   00005A   78..         MOV     R0,#?V6
   \   00005C   12....       LCALL   ?S_SHL
   \   00005F   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E4           CLR     A
   \   000065   93           MOVC    A,@A+DPTR
   \   000066   F8           MOV     R0,A
   \   000067   7401         MOV     A,#0x1
   \   000069   93           MOVC    A,@A+DPTR
   \   00006A   F9           MOV     R1,A
   \   00006B   EE           MOV     A,R6
   \   00006C   68           XRL     A,R0
   \   00006D   7002         JNZ     ??zclFindAttrRec_4
   \   00006F   EF           MOV     A,R7
   \   000070   69           XRL     A,R1
   \                     ??zclFindAttrRec_4:
   \   000071   70A9         JNZ     ??zclFindAttrRec_2
   2374                {
   2375                  *pAttr = pRec->attrs[x];
   \   000073   75..00       MOV     ?V1,#0x0
   \   000076   7403         MOV     A,#0x3
   \   000078   78..         MOV     R0,#?V0
   \   00007A   12....       LCALL   ?S_SHL
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   8B83         MOV     DPH,R3
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   25..         ADD     A,?V0
   \   00008C   F8           MOV     R0,A
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   35..         ADDC    A,?V1
   \   000091   8882         MOV     DPL,R0
   \   000093   F583         MOV     DPH,A
   \   000095   C082         PUSH    DPL
   \   000097   C083         PUSH    DPH
   \   000099   7410         MOV     A,#0x10
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0000A1   D083         POP     DPH
   \   0000A3   D082         POP     DPL
   \   0000A5   7408         MOV     A,#0x8
   \   0000A7   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   2376          
   2377                  return ( TRUE ); // EMBEDDED RETURN
   \   0000AA   7901         MOV     R1,#0x1
   \   0000AC   8002         SJMP    ??zclFindAttrRec_5
   2378                }
   2379              }
   2380            }
   2381          
   2382            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   0000AE   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   0000B0                REQUIRE ?Subroutine5
   \   0000B0                ; // Fall through to label ?Subroutine5
   2383          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   25..         ADD     A,?V6
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   35..         ADDC    A,?V7
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   22           RET
   2384          
   2385          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2386          /*********************************************************************
   2387           * @fn      zclGetReadWriteCB
   2388           *
   2389           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2390           *
   2391           * @param   endpoint - Application's endpoint
   2392           *
   2393           * @return  Read/Write CB, NULL if not found
   2394           */
   2395          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   2396          {
   2397            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2398          
   2399            if ( pRec != NULL )
   2400            {
   2401              return ( pRec->pfnReadWriteCB );
   2402            }
   2403          
   2404            return ( NULL );
   2405          }
   2406          
   2407          /*********************************************************************
   2408           * @fn      zclGetAuthorizeCB
   2409           *
   2410           * @brief   Get the Read/Write Authorization callback function pointer
   2411           *          for a given endpoint.
   2412           *
   2413           * @param   endpoint - Application's endpoint
   2414           *
   2415           * @return  Authorization CB, NULL if not found
   2416           */
   2417          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   2418          {
   2419            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2420          
   2421            if ( pRec != NULL )
   2422            {
   2423              return ( pRec->pfnAuthorizeCB );
   2424            }
   2425          
   2426            return ( NULL );
   2427          }
   2428          #endif // ZCL_READ || ZCL_WRITE
   2429          
   2430          /*********************************************************************
   2431           * @fn      zclFindClusterOption
   2432           *
   2433           * @brief   Find the option record that matchs the cluster id
   2434           *
   2435           * @param   endpoint - Application's endpoint
   2436           * @param   clusterID - cluster ID looking for
   2437           *
   2438           * @return  pointer to clutser option, NULL if not found
   2439           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2440          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2441          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2442            zclClusterOptionList *pLoop;
   2443          
   2444            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   800A         SJMP    ??zclFindClusterOption_0
   2445            while ( pLoop != NULL )
   2446            {
   2447              if ( pLoop->endpoint == endpoint )
   2448              {
   2449                uint8 x;
   2450                for ( x = 0; x < pLoop->numOptions; x++ )
   2451                {
   2452                  if ( pLoop->options[x].clusterID == clusterID )
   2453                  {
   2454                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2455                  }
   2456                }
   2457              }
   2458          
   2459              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \                     ??zclFindClusterOption_0:
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   4B           ORL     A,R3
   \   000021   6056         JZ      ??zclFindClusterOption_2
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6F           XRL     A,R7
   \   00002B   70E7         JNZ     ??zclFindClusterOption_1
   \   00002D   7E00         MOV     R6,#0x0
   \   00002F   8001         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000031   0E           INC     R6
   \                     ??zclFindClusterOption_3:
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   EE           MOV     A,R6
   \   00003C   C3           CLR     C
   \   00003D   98           SUBB    A,R0
   \   00003E   50D4         JNC     ??zclFindClusterOption_1
   \   000040   EE           MOV     A,R6
   \   000041   75F003       MOV     B,#0x3
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   85F0..       MOV     ?V0,B
   \   000049   A9..         MOV     R1,?V0
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   28           ADD     A,R0
   \   000055   F5..         MOV     ?V0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   39           ADDC    A,R1
   \   00005A   85..82       MOV     DPL,?V0
   \   00005D   F583         MOV     DPH,A
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6C           XRL     A,R4
   \   000061   7003         JNZ     ??zclFindClusterOption_5
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   6D           XRL     A,R5
   \                     ??zclFindClusterOption_5:
   \   000066   70C9         JNZ     ??zclFindClusterOption_4
   \   000068   8A82         MOV     DPL,R2
   \   00006A   8B83         MOV     DPH,R3
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   28           ADD     A,R0
   \   000072   FA           MOV     R2,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   39           ADDC    A,R1
   \   000076   FB           MOV     R3,A
   \   000077   8004         SJMP    ??zclFindClusterOption_6
   2460            }
   2461          
   2462            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000079   7A00         MOV     R2,#0x0
   \   00007B   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   00007D   02....       LJMP    ?Subroutine4 & 0xFFFF
   2463          }
   2464          
   2465          /*********************************************************************
   2466           * @fn      zclGetClusterOption
   2467           *
   2468           * @brief   Get the option record that matchs the cluster id
   2469           *
   2470           * @param   endpoint - Application's endpoint
   2471           * @param   clusterID - cluster ID looking for
   2472           *
   2473           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2474           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2475          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2476          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2477            uint8 option;
   2478            zclOptionRec_t *pOption;
   2479          
   2480            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2481            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6006         JZ      ??zclGetClusterOption_0
   2482            {
   2483              option = pOption->option;
   2484              if ( !ZG_SECURE_ENABLED )
   2485              {
   2486                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2487              }
   2488          
   2489              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   8002         SJMP    ??zclGetClusterOption_1
   2490            }
   2491          
   2492            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A                REQUIRE ?Subroutine2
   \   00001A                ; // Fall through to label ?Subroutine2
   2493          }
   2494          
   2495          /*********************************************************************
   2496           * @fn      zclSetSecurityOption
   2497           *
   2498           * @brief   Set the security option for the cluster id
   2499           *
   2500           * @param   endpoint - Application's endpoint
   2501           * @param   clusterID - cluster ID looking for
   2502           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2503           *
   2504           * @return  none
   2505           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2506          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2507          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2508            zclOptionRec_t *pOption;
   2509          
   2510            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   2511            if ( pOption != NULL )
   \   00000E   E582         MOV     A,DPL
   \   000010   4583         ORL     A,DPH
   \   000012   600E         JZ      ??zclSetSecurityOption_0
   2512            {
   2513              if ( enable )
   \   000014   EF           MOV     A,R7
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   6005         JZ      ??zclSetSecurityOption_1
   2514              {
   2515                pOption->option |= AF_EN_SECURITY;
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   D2E6         SETB    0xE0 /* A   */.6
   \   00001C   8003         SJMP    ??zclSetSecurityOption_2
   2516              }
   2517              else
   2518              {
   2519                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   000021   F0           MOVX    @DPTR,A
   2520              }
   2521            }
   2522          }
   \                     ??zclSetSecurityOption_0:
   \   000022   80..         SJMP    ?Subroutine2
   2523          
   2524          #ifdef ZCL_DISCOVER
   2525          /*********************************************************************
   2526           * @fn      zclFindNextCmdRec
   2527           *
   2528           * @brief   Find the command (or next) record that matchs the parameters
   2529           *
   2530           * @param   endpoint - Application's endpoint
   2531           * @param   clusterID - cluster ID
   2532           * @param   commandID - command ID from requesting command
   2533           * @param   direction- direction of received command
   2534           * @param   pCmdID - command looking for
   2535           * @param   pCmd - command information within command record list
   2536           *
   2537           * @return  pointer to command record, NULL no more records of this cluster
   2538           */
   2539          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2540                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2541          {
   2542            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2543            uint8 i;
   2544          
   2545            if ( pRec != NULL )
   2546            {
   2547              for ( i = 0; i < pRec->numCommands; i++ )
   2548              {
   2549                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2550                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2551                {
   2552                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2553                  {
   2554                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2555                    {
   2556                      *pCmd = pRec->pCmdRecs[i];
   2557          
   2558                      // Update command ID
   2559                      *pCmdID = pCmd->cmdID;
   2560          
   2561                      return ( TRUE ); // EMBEDDED RETURN
   2562                    }
   2563                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2564                    {
   2565                      *pCmd = pRec->pCmdRecs[i];
   2566          
   2567                      // Update command ID
   2568                      *pCmdID = pCmd->cmdID;
   2569          
   2570                      return ( TRUE ); // EMBEDDED RETURN
   2571                    }
   2572                  }
   2573                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2574                  {
   2575                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2576                    {
   2577                      *pCmd = pRec->pCmdRecs[i];
   2578          
   2579                      // Update command ID
   2580                      *pCmdID = pCmd->cmdID;
   2581          
   2582                      return ( TRUE ); // EMBEDDED RETURN
   2583                    }
   2584                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2585                    {
   2586                      *pCmd = pRec->pCmdRecs[i];
   2587          
   2588                      // Update command ID
   2589                      *pCmdID = pCmd->cmdID;
   2590          
   2591                      return ( TRUE ); // EMBEDDED RETURN
   2592                    }
   2593                  }
   2594                  else
   2595                  {
   2596                    return ( FALSE ); // Incorrect Command ID
   2597                  }
   2598                }
   2599              }
   2600            }
   2601          
   2602            return ( FALSE );
   2603          }
   2604          
   2605          /*********************************************************************
   2606           * @fn      zclFindNextAttrRec
   2607           *
   2608           * @brief   Find the attribute (or next) record that matchs the parameters
   2609           *
   2610           * @param   endpoint - Application's endpoint
   2611           * @param   clusterID - cluster ID
   2612           * @param   attr - attribute looking for
   2613           *
   2614           * @return  pointer to attribute record, NULL if not found
   2615           */
   2616          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2617                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2618          {
   2619            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2620            uint8 attrDir;
   2621          
   2622            if ( pRec != NULL )
   2623            {
   2624              uint16 x;
   2625          
   2626              for ( x = 0; x < pRec->numAttributes; x++ )
   2627              {
   2628                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2629                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2630                {
   2631                  // also make sure direction is right
   2632                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2633                  if ( attrDir == direction )
   2634                  {
   2635                    // return attribute and found attribute ID
   2636                    *pAttr = pRec->attrs[x];
   2637                    *attrId = pAttr->attr.attrId;
   2638          
   2639                    return ( TRUE ); // EMBEDDED RETURN
   2640                  }
   2641                }
   2642              }
   2643            }
   2644          
   2645            return ( FALSE );
   2646          }
   2647          #endif // ZCL_DISCOVER
   2648          
   2649          /*********************************************************************
   2650           * @fn      zclSerializeData
   2651           *
   2652           * @brief   Builds a buffer from the attribute data to sent out over
   2653           *          the air.
   2654           *          NOTE - Not compatible with application's attributes callbacks.
   2655           *
   2656           * @param   dataType - data types defined in zcl.h
   2657           * @param   attrData - pointer to the attribute data
   2658           * @param   buf - where to put the serialized data
   2659           *
   2660           * @return  pointer to end of destination buffer
   2661           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2662          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2663          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   2664            uint8 *pStr;
   2665            uint16 len;
   2666          
   2667            if ( attrData == NULL )
   \   00000D   EE           MOV     A,R6
   \   00000E   4F           ORL     A,R7
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2668            {
   2669              return ( buf );
   2670            }
   2671          
   2672            switch ( dataType )
   \   000014   E9           MOV     A,R1
   \   000015   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000018   04           DB        4
   \   000019   41           DB        65
   \   00001A   42           DB        66
   \   00001B   ....         DW        ??zclSerializeData_1
   \   00001D   43           DB        67
   \   00001E   44           DB        68
   \   00001F   ....         DW        ??zclSerializeData_2
   \   000021   E0           DB        224
   \   000022   E2           DB        226
   \   000023   ....         DW        ??zclSerializeData_3
   \   000025   E8           DB        232
   \   000026   E9           DB        233
   \   000027   ....         DW        ??zclSerializeData_4
   \   000029   1A           DB        26
   \   00002A   08           DB        8
   \   00002B   ....         DW        ??zclSerializeData_5
   \   00002D   09           DB        9
   \   00002E   ....         DW        ??zclSerializeData_4
   \   000030   0A           DB        10
   \   000031   ....         DW        ??zclSerializeData_6
   \   000033   0B           DB        11
   \   000034   ....         DW        ??zclSerializeData_3
   \   000036   10           DB        16
   \   000037   ....         DW        ??zclSerializeData_5
   \   000039   18           DB        24
   \   00003A   ....         DW        ??zclSerializeData_5
   \   00003C   19           DB        25
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   1A           DB        26
   \   000040   ....         DW        ??zclSerializeData_6
   \   000042   1B           DB        27
   \   000043   ....         DW        ??zclSerializeData_3
   \   000045   20           DB        32
   \   000046   ....         DW        ??zclSerializeData_5
   \   000048   21           DB        33
   \   000049   ....         DW        ??zclSerializeData_4
   \   00004B   22           DB        34
   \   00004C   ....         DW        ??zclSerializeData_6
   \   00004E   23           DB        35
   \   00004F   ....         DW        ??zclSerializeData_3
   \   000051   24           DB        36
   \   000052   ....         DW        ??zclSerializeData_7
   \   000054   25           DB        37
   \   000055   ....         DW        ??zclSerializeData_8
   \   000057   28           DB        40
   \   000058   ....         DW        ??zclSerializeData_5
   \   00005A   29           DB        41
   \   00005B   ....         DW        ??zclSerializeData_4
   \   00005D   2A           DB        42
   \   00005E   ....         DW        ??zclSerializeData_6
   \   000060   2B           DB        43
   \   000061   ....         DW        ??zclSerializeData_3
   \   000063   30           DB        48
   \   000064   ....         DW        ??zclSerializeData_5
   \   000066   31           DB        49
   \   000067   ....         DW        ??zclSerializeData_4
   \   000069   38           DB        56
   \   00006A   ....         DW        ??zclSerializeData_4
   \   00006C   39           DB        57
   \   00006D   ....         DW        ??zclSerializeData_3
   \   00006F   EA           DB        234
   \   000070   ....         DW        ??zclSerializeData_3
   \   000072   F0           DB        240
   \   000073   ....         DW        ??zclSerializeData_9
   \   000075   F1           DB        241
   \   000076   ....         DW        ??zclSerializeData_10
   \   000078   ....         DW        ??zclSerializeData_0
   2673            {
   2674              case ZCL_DATATYPE_DATA8:
   2675              case ZCL_DATATYPE_BOOLEAN:
   2676              case ZCL_DATATYPE_BITMAP8:
   2677              case ZCL_DATATYPE_INT8:
   2678              case ZCL_DATATYPE_UINT8:
   2679              case ZCL_DATATYPE_ENUM8:
   2680                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   00007A   8E82         MOV     DPL,R6
   \   00007C   8F83         MOV     DPH,R7
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   8A82         MOV     DPL,R2
   \   000081   8B83         MOV     DPH,R3
   \   000083   F0           MOVX    @DPTR,A
   \   000084   A3           INC     DPTR
   \   000085   AA82         MOV     R2,DPL
   \   000087   AB83         MOV     R3,DPH
   2681                 break;
   \   000089   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2682          
   2683              case ZCL_DATATYPE_DATA16:
   2684              case ZCL_DATATYPE_BITMAP16:
   2685              case ZCL_DATATYPE_UINT16:
   2686              case ZCL_DATATYPE_INT16:
   2687              case ZCL_DATATYPE_ENUM16:
   2688              case ZCL_DATATYPE_SEMI_PREC:
   2689              case ZCL_DATATYPE_CLUSTER_ID:
   2690              case ZCL_DATATYPE_ATTR_ID:
   2691                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   00008C   12....       LCALL   ?Subroutine8 & 0xFFFF
   2692                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_4:
   \   00008F   EA           MOV     A,R2
   \   000090   2402         ADD     A,#0x2
   \   000092   FA           MOV     R2,A
   \   000093   5001         JNC     ??zclSerializeData_11
   \   000095   0B           INC     R3
   2693                break;
   \                     ??zclSerializeData_11:
   \   000096   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2694          
   2695              case ZCL_DATATYPE_DATA24:
   2696              case ZCL_DATATYPE_BITMAP24:
   2697              case ZCL_DATATYPE_UINT24:
   2698              case ZCL_DATATYPE_INT24:
   2699                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   000099   8E82         MOV     DPL,R6
   \   00009B   8F83         MOV     DPH,R7
   \   00009D   78..         MOV     R0,#?V4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   8A82         MOV     DPL,R2
   \   0000A4   8B83         MOV     DPH,R3
   \   0000A6   E5..         MOV     A,?V4
   \   0000A8   12....       LCALL   ?Subroutine15 & 0xFFFF
   2700                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_21:
   \   0000AB   78..         MOV     R0,#?V4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   E5..         MOV     A,?V5
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   8B83         MOV     DPH,R3
   \   0000B6   A3           INC     DPTR
   \   0000B7   12....       LCALL   ?Subroutine15 & 0xFFFF
   2701                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_22:
   \   0000BA   78..         MOV     R0,#?V4
   \   0000BC   12....       LCALL   ?L_MOV_X
   \   0000BF   7410         MOV     A,#0x10
   \   0000C1   78..         MOV     R0,#?V4
   \   0000C3   12....       LCALL   ?UL_SHR
   \   0000C6   8A82         MOV     DPL,R2
   \   0000C8   8B83         MOV     DPH,R3
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   E5..         MOV     A,?V4
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   EA           MOV     A,R2
   \   0000D0   2403         ADD     A,#0x3
   \   0000D2   FA           MOV     R2,A
   \   0000D3   5001         JNC     ??zclSerializeData_12
   \   0000D5   0B           INC     R3
   2702                break;
   \                     ??zclSerializeData_12:
   \   0000D6   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2703          
   2704              case ZCL_DATATYPE_DATA32:
   2705              case ZCL_DATATYPE_BITMAP32:
   2706              case ZCL_DATATYPE_UINT32:
   2707              case ZCL_DATATYPE_INT32:
   2708              case ZCL_DATATYPE_SINGLE_PREC:
   2709              case ZCL_DATATYPE_TOD:
   2710              case ZCL_DATATYPE_DATE:
   2711              case ZCL_DATATYPE_UTC:
   2712              case ZCL_DATATYPE_BAC_OID:
   2713                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000D9                ; Setup parameters for call to function osal_buffer_uint32
   \   0000D9   8E82         MOV     DPL,R6
   \   0000DB   8F83         MOV     DPH,R7
   \   0000DD   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000E0   12....       LCALL   `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   0000E3   7404         MOV     A,#0x4
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   2714                break;
   \   0000E8   807A         SJMP    ??zclSerializeData_0
   2715          
   2716              case ZCL_DATATYPE_UINT40:
   2717                pStr = (uint8*)attrData;
   2718                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   0000EA                ; Setup parameters for call to function osal_memcpy
   \   0000EA   8E..         MOV     ?V4,R6
   \   0000EC   8F..         MOV     ?V5,R7
   \   0000EE   75..00       MOV     ?V6,#0x0
   \   0000F1   78..         MOV     R0,#?V4
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F6   7C05         MOV     R4,#0x5
   \   0000F8   8060         SJMP    ??zclSerializeData_13
   2719                break;
   2720          
   2721              case ZCL_DATATYPE_UINT48:
   2722                pStr = (uint8*)attrData;
   2723                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   0000FA                ; Setup parameters for call to function osal_memcpy
   \   0000FA   8E..         MOV     ?V4,R6
   \   0000FC   8F..         MOV     ?V5,R7
   \   0000FE   75..00       MOV     ?V6,#0x0
   \   000101   78..         MOV     R0,#?V4
   \   000103   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000106   7C06         MOV     R4,#0x6
   \   000108   8050         SJMP    ??zclSerializeData_13
   2724                break;
   2725          
   2726              case ZCL_DATATYPE_IEEE_ADDR:
   2727                pStr = (uint8*)attrData;
   2728                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   00010A                ; Setup parameters for call to function osal_memcpy
   \   00010A   8E..         MOV     ?V4,R6
   \   00010C   8F..         MOV     ?V5,R7
   \   00010E   75..00       MOV     ?V6,#0x0
   \   000111   78..         MOV     R0,#?V4
   \   000113   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000116   7C08         MOV     R4,#0x8
   \   000118   8040         SJMP    ??zclSerializeData_13
   2729                break;
   2730          
   2731              case ZCL_DATATYPE_CHAR_STR:
   2732              case ZCL_DATATYPE_OCTET_STR:
   2733                pStr = (uint8*)attrData;
   2734                len = *pStr;
   2735                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   00011A                ; Setup parameters for call to function osal_memcpy
   \   00011A   8E..         MOV     ?V4,R6
   \   00011C   8F..         MOV     ?V5,R7
   \   00011E   75..00       MOV     ?V6,#0x0
   \   000121   78..         MOV     R0,#?V4
   \   000123   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000126   8E82         MOV     DPL,R6
   \   000128   8F83         MOV     DPH,R7
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   2401         ADD     A,#0x1
   \   00012D   FC           MOV     R4,A
   \   00012E   E4           CLR     A
   \   00012F   3400         ADDC    A,#0x0
   \   000131   8016         SJMP    ??zclSerializeData_14
   2736                break;
   2737          
   2738              case ZCL_DATATYPE_LONG_CHAR_STR:
   2739              case ZCL_DATATYPE_LONG_OCTET_STR:
   2740                pStr = (uint8*)attrData;
   2741                len = BUILD_UINT16( pStr[0], pStr[1] );
   2742                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   000133                ; Setup parameters for call to function osal_memcpy
   \   000133   8E..         MOV     ?V4,R6
   \   000135   8F..         MOV     ?V5,R7
   \   000137   75..00       MOV     ?V6,#0x0
   \   00013A   78..         MOV     R0,#?V4
   \   00013C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00013F   8E82         MOV     DPL,R6
   \   000141   8F83         MOV     DPH,R7
   \   000143   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000146   FC           MOV     R4,A
   \   000147   E4           CLR     A
   \   000148   39           ADDC    A,R1
   \                     ??zclSerializeData_14:
   \   000149   FD           MOV     R5,A
   \   00014A   8010         SJMP    ??zclSerializeData_15
   2743                break;
   2744          
   2745              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2746                pStr = (uint8*)attrData;
   2747                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   00014C                ; Setup parameters for call to function osal_memcpy
   \   00014C   8E..         MOV     ?V4,R6
   \   00014E   8F..         MOV     ?V5,R7
   \   000150   75..00       MOV     ?V6,#0x0
   \   000153   78..         MOV     R0,#?V4
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000158   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_13:
   \   00015A   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_15:
   \   00015C   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00015F   7403         MOV     A,#0x3
   \   000161   12....       LCALL   ?DEALLOC_XSTACK8
   2748                break;
   2749          
   2750              case ZCL_DATATYPE_NO_DATA:
   2751              case ZCL_DATATYPE_UNKNOWN:
   2752                // Fall through
   2753          
   2754              default:
   2755                break;
   2756            }
   2757          
   2758            return ( buf );
   \                     ??zclSerializeData_0:
   \   000164   02....       LJMP    ?Subroutine5 & 0xFFFF
   2759          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   EC           MOV     A,R4
   \   000006   2402         ADD     A,#0x2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   8E82         MOV     DPL,R6
   \   00000C   8F83         MOV     DPH,R7
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
   \   000016   22           RET
   2760          
   2761          #ifdef ZCL_REPORT
   2762          /*********************************************************************
   2763           * @fn      zclAnalogDataType
   2764           *
   2765           * @brief   Checks to see if Data Type is Analog
   2766           *
   2767           * @param   dataType - data type
   2768           *
   2769           * @return  TRUE if data type is analog
   2770           */
   2771          uint8 zclAnalogDataType( uint8 dataType )
   2772          {
   2773            uint8 analog;
   2774          
   2775            switch ( dataType )
   2776            {
   2777              case ZCL_DATATYPE_UINT8:
   2778              case ZCL_DATATYPE_UINT16:
   2779              case ZCL_DATATYPE_UINT24:
   2780              case ZCL_DATATYPE_UINT32:
   2781              case ZCL_DATATYPE_UINT40:
   2782              case ZCL_DATATYPE_UINT48:
   2783              case ZCL_DATATYPE_UINT56:
   2784              case ZCL_DATATYPE_UINT64:
   2785              case ZCL_DATATYPE_INT8:
   2786              case ZCL_DATATYPE_INT16:
   2787              case ZCL_DATATYPE_INT24:
   2788              case ZCL_DATATYPE_INT32:
   2789              case ZCL_DATATYPE_INT40:
   2790              case ZCL_DATATYPE_INT48:
   2791              case ZCL_DATATYPE_INT56:
   2792              case ZCL_DATATYPE_INT64:
   2793              case ZCL_DATATYPE_SEMI_PREC:
   2794              case ZCL_DATATYPE_SINGLE_PREC:
   2795              case ZCL_DATATYPE_DOUBLE_PREC:
   2796              case ZCL_DATATYPE_TOD:
   2797              case ZCL_DATATYPE_DATE:
   2798              case ZCL_DATATYPE_UTC:
   2799                analog = TRUE;
   2800                break;
   2801          
   2802              default:
   2803                analog = FALSE;
   2804                break;
   2805            }
   2806          
   2807            return ( analog );
   2808          }
   2809          
   2810          /*********************************************************************
   2811           * @fn      zclIsLittleEndianMachine
   2812           *
   2813           * @brief   Verifies endianness in system.
   2814           *
   2815           * @param   none
   2816           *
   2817           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2818           */
   2819          static int zclIsLittleEndianMachine(void)
   2820          {
   2821            uint16 test = 0x0001;
   2822          
   2823            return (*((uint8 *)(&test)));
   2824          }
   2825          
   2826          /*********************************************************************
   2827           * @fn      zcl_BuildAnalogData
   2828           *
   2829           * @brief   Build an analog arribute out of sequential bytes.
   2830           *
   2831           * @param   dataType - type of data
   2832           * @param   pData - pointer to data
   2833           * @param   pBuf - where to put the data
   2834           *
   2835           * @return  none
   2836           */
   2837          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   2838          {
   2839            int current_byte_index;
   2840            int remaining_bytes;
   2841            int step;
   2842          
   2843            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   2844          
   2845            // decide if move forward or backwards to copy data
   2846            if ( zclIsLittleEndianMachine() )
   2847            {
   2848              step = 1;
   2849              current_byte_index = 0;
   2850            }
   2851            else
   2852            {
   2853              step = -1;
   2854              current_byte_index = remaining_bytes - 1;
   2855            }
   2856          
   2857            while ( remaining_bytes-- )
   2858            {
   2859              pData[current_byte_index] = *(pBuf++);
   2860              current_byte_index += step;
   2861            }
   2862          }
   2863          #endif // ZCL_REPORT
   2864          
   2865          /*********************************************************************
   2866           * @fn      zclGetDataTypeLength
   2867           *
   2868           * @brief   Return the length of the datatype in octet.
   2869           *
   2870           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2871           *                ZCL_DATATYPE_CHAR_STR data types.
   2872           *
   2873           * @param   dataType - data type
   2874           *
   2875           * @return  length of data
   2876           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2877          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2878          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   2879            uint8 len;
   2880          
   2881            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   2882            {
   2883              case ZCL_DATATYPE_DATA8:
   2884              case ZCL_DATATYPE_BOOLEAN:
   2885              case ZCL_DATATYPE_BITMAP8:
   2886              case ZCL_DATATYPE_INT8:
   2887              case ZCL_DATATYPE_UINT8:
   2888              case ZCL_DATATYPE_ENUM8:
   2889                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   2890                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   2891          
   2892              case ZCL_DATATYPE_DATA16:
   2893              case ZCL_DATATYPE_BITMAP16:
   2894              case ZCL_DATATYPE_UINT16:
   2895              case ZCL_DATATYPE_INT16:
   2896              case ZCL_DATATYPE_ENUM16:
   2897              case ZCL_DATATYPE_SEMI_PREC:
   2898              case ZCL_DATATYPE_CLUSTER_ID:
   2899              case ZCL_DATATYPE_ATTR_ID:
   2900                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   2901                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   2902          
   2903              case ZCL_DATATYPE_DATA24:
   2904              case ZCL_DATATYPE_BITMAP24:
   2905              case ZCL_DATATYPE_UINT24:
   2906              case ZCL_DATATYPE_INT24:
   2907                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   2908                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   2909          
   2910              case ZCL_DATATYPE_DATA32:
   2911              case ZCL_DATATYPE_BITMAP32:
   2912              case ZCL_DATATYPE_UINT32:
   2913              case ZCL_DATATYPE_INT32:
   2914              case ZCL_DATATYPE_SINGLE_PREC:
   2915              case ZCL_DATATYPE_TOD:
   2916              case ZCL_DATATYPE_DATE:
   2917              case ZCL_DATATYPE_UTC:
   2918              case ZCL_DATATYPE_BAC_OID:
   2919                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   2920                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   2921          
   2922             case ZCL_DATATYPE_UINT40:
   2923             case ZCL_DATATYPE_INT40:
   2924                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   2925                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   2926          
   2927             case ZCL_DATATYPE_UINT48:
   2928             case ZCL_DATATYPE_INT48:
   2929                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   2930                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   2931          
   2932             case ZCL_DATATYPE_UINT56:
   2933             case ZCL_DATATYPE_INT56:
   2934                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   2935                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   2936          
   2937             case ZCL_DATATYPE_DOUBLE_PREC:
   2938             case ZCL_DATATYPE_IEEE_ADDR:
   2939             case ZCL_DATATYPE_UINT64:
   2940             case ZCL_DATATYPE_INT64:
   2941               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   2942               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   2943          
   2944              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2945               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   2946               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   2947          
   2948              case ZCL_DATATYPE_NO_DATA:
   2949              case ZCL_DATATYPE_UNKNOWN:
   2950                // Fall through
   2951          
   2952              default:
   2953                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   2954                break;
   2955            }
   2956          
   2957            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   2958          }
   2959          
   2960          /*********************************************************************
   2961           * @fn      zclGetAttrDataLength
   2962           *
   2963           * @brief   Return the length of the attribute.
   2964           *
   2965           * @param   dataType - data type
   2966           * @param   pData - pointer to data
   2967           *
   2968           * @return  returns atrribute length
   2969           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2970          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2971          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2972            uint16 dataLen = 0;
   2973          
   2974            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   2975            {
   2976              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine37 & 0xFFFF
   2977            }
   \                     ??CrossCallReturnLabel_70:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   2978            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   2979            {
   2980              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   2981            }
   2982            else
   2983            {
   2984              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   2985            }
   2986          
   2987            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ?Subroutine4 & 0xFFFF
   2988          }
   2989          
   2990          #ifdef ZCL_READ
   2991          /*********************************************************************
   2992           * @fn      zclReadAttrData
   2993           *
   2994           * @brief   Read the attribute's current value into pAttrData.
   2995           *          NOTE - Not compatible with application's attributes callbacks.
   2996           *
   2997           * @param   pAttrData - where to put attribute data
   2998           * @param   pAttr - pointer to attribute
   2999           * @param   pDataLen - where to put attribute data length
   3000           *
   3001           * @return Success
   3002           */
   3003          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   3004          {
   3005            uint16 dataLen;
   3006          
   3007            if ( pAttr->attr.dataPtr == NULL )
   3008            {
   3009              return ( ZCL_STATUS_FAILURE );
   3010            }
   3011          
   3012            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   3013            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   3014          
   3015            if ( pDataLen != NULL )
   3016            {
   3017              *pDataLen = dataLen;
   3018            }
   3019          
   3020            return ( ZCL_STATUS_SUCCESS );
   3021          }
   3022          
   3023          /*********************************************************************
   3024           * @fn      zcl_ReadAttrData
   3025           *
   3026           * @brief   Read the attribute's current value into pAttrData.
   3027           *          Use application's callback function if assigned to this attribute.
   3028           *
   3029           * @param   endpoint - application's endpoint
   3030           * @param   clusterId - cluster that attribute belongs to
   3031           * @param   attrId - attribute id
   3032           * @param   pAttrData - where to put attribute data
   3033           * @param   pDataLen - where to put attribute data length
   3034           *
   3035           * @return  Successful if data was read
   3036           */
   3037          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   3038                                                   uint8 *pAttrData, uint16 *pDataLen )
   3039          {
   3040            zclAttrRec_t attrRec;
   3041          
   3042            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   3043            {
   3044              return ( ZCL_STATUS_FAILURE );
   3045            }
   3046          
   3047            if ( attrRec.attr.dataPtr != NULL )
   3048            {
   3049              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   3050            }
   3051            else
   3052            {
   3053              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   3054            }
   3055          }
   3056          
   3057          /*********************************************************************
   3058           * @fn      zclGetAttrDataLengthUsingCB
   3059           *
   3060           * @brief   Use application's callback to get the length of the attribute's
   3061           *          current value stored in the database.
   3062           *
   3063           * @param   endpoint - application's endpoint
   3064           * @param   clusterId - cluster that attribute belongs to
   3065           * @param   attrId - attribute id
   3066           *
   3067           * @return  returns attribute length
   3068           */
   3069          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   3070          {
   3071            uint16 dataLen = 0;
   3072            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   3073          
   3074            if ( pfnReadWriteCB != NULL )
   3075            {
   3076              // Only get the attribute length
   3077              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   3078            }
   3079          
   3080            return ( dataLen );
   3081          }
   3082          
   3083          /*********************************************************************
   3084           * @fn      zclReadAttrDataUsingCB
   3085           *
   3086           * @brief   Use application's callback to read the attribute's current
   3087           *          value stored in the database.
   3088           *
   3089           * @param   endpoint - application's endpoint
   3090           * @param   clusterId - cluster that attribute belongs to
   3091           * @param   attrId - attribute id
   3092           * @param   pAttrData - where to put attribute data
   3093           * @param   pDataLen - where to put attribute data length
   3094           *
   3095           * @return  Successful if data was read
   3096           */
   3097          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   3098                                                   uint8 *pAttrData, uint16 *pDataLen )
   3099          {
   3100            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   3101          
   3102            if ( pDataLen != NULL )
   3103            {
   3104              *pDataLen = 0; // Always initialize it to 0
   3105            }
   3106          
   3107            if ( pfnReadWriteCB != NULL )
   3108            {
   3109              // Read the attribute value and its length
   3110              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   3111            }
   3112          
   3113            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   3114          }
   3115          
   3116          /*********************************************************************
   3117           * @fn      zclAuthorizeRead
   3118           *
   3119           * @brief   Use application's callback to authorize a Read operation
   3120           *          on a given attribute.
   3121           *
   3122           * @param   endpoint - application's endpoint
   3123           * @param   srcAddr - source Address
   3124           * @param   pAttr - pointer to attribute
   3125           *
   3126           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3127           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3128           */
   3129          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3130          {
   3131            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3132            {
   3133              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3134          
   3135              if ( pfnAuthorizeCB != NULL )
   3136              {
   3137                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3138              }
   3139            }
   3140          
   3141            return ( ZCL_STATUS_SUCCESS );
   3142          }
   3143          #endif // ZCL_READ
   3144          
   3145          #ifdef ZCL_WRITE
   3146          /*********************************************************************
   3147           * @fn      zclWriteAttrData
   3148           *
   3149           * @brief   Write the received data.
   3150           *
   3151           * @param   endpoint - application's endpoint
   3152           * @param   pAttr - where to write data to
   3153           * @param   pWriteRec - data to be written
   3154           *
   3155           * @return  Successful if data was written
   3156           */
   3157          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   3158                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3159          {
   3160            uint8 status;
   3161          
   3162            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   3163            {
   3164              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   3165              if ( status == ZCL_STATUS_SUCCESS )
   3166              {
   3167                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   3168                {
   3169                  // Write the attribute value
   3170                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   3171                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   3172          
   3173                  status = ZCL_STATUS_SUCCESS;
   3174                }
   3175                else
   3176                {
   3177                  status = ZCL_STATUS_INVALID_VALUE;
   3178                }
   3179              }
   3180            }
   3181            else
   3182            {
   3183              status = ZCL_STATUS_READ_ONLY;
   3184            }
   3185          
   3186            return ( status );
   3187          }
   3188          
   3189          /*********************************************************************
   3190           * @fn      zclWriteAttrDataUsingCB
   3191           *
   3192           * @brief   Use application's callback to write the attribute's current
   3193           *          value stored in the database.
   3194           *
   3195           * @param   endpoint - application's endpoint
   3196           * @param   pAttr - where to write data to
   3197           * @param   pAttrData - data to be written
   3198           *
   3199           * @return  Successful if data was written
   3200           */
   3201          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   3202                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3203          {
   3204            uint8 status;
   3205          
   3206            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   3207            {
   3208              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   3209              if ( status == ZCL_STATUS_SUCCESS )
   3210              {
   3211                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   3212                if ( pfnReadWriteCB != NULL )
   3213                {
   3214                  // Write the attribute value
   3215                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3216                                              ZCL_OPER_WRITE, pAttrData, NULL );
   3217                }
   3218                else
   3219                {
   3220                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   3221                }
   3222              }
   3223            }
   3224            else
   3225            {
   3226              status = ZCL_STATUS_READ_ONLY;
   3227            }
   3228          
   3229            return ( status );
   3230          }
   3231          
   3232          /*********************************************************************
   3233           * @fn      zclAuthorizeWrite
   3234           *
   3235           * @brief   Use application's callback to authorize a Write operation
   3236           *          on a given attribute.
   3237           *
   3238           * @param   endpoint - application's endpoint
   3239           * @param   srcAddr - source Address
   3240           * @param   pAttr - pointer to attribute
   3241           *
   3242           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3243           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3244           */
   3245          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3246          {
   3247            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   3248            {
   3249              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3250          
   3251              if ( pfnAuthorizeCB != NULL )
   3252              {
   3253                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   3254              }
   3255            }
   3256          
   3257            return ( ZCL_STATUS_SUCCESS );
   3258          }
   3259          #endif // ZCL_WRITE
   3260          
   3261          #ifdef ZCL_READ
   3262          /*********************************************************************
   3263           * @fn      zclParseInReadCmd
   3264           *
   3265           * @brief   Parse the "Profile" Read Commands
   3266           *
   3267           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3268           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3269           *
   3270           * @param   pCmd - pointer to incoming data to parse
   3271           *
   3272           * @return  pointer to the parsed command structure
   3273           */
   3274          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   3275          {
   3276            zclReadCmd_t *readCmd;
   3277            uint8 *pBuf = pCmd->pData;
   3278          
   3279            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   3280            if ( readCmd != NULL )
   3281            {
   3282              uint8 i;
   3283              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   3284              for ( i = 0; i < readCmd->numAttr; i++ )
   3285              {
   3286                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   3287                pBuf += 2;
   3288              }
   3289            }
   3290          
   3291            return ( (void *)readCmd );
   3292          }
   3293          
   3294          /*********************************************************************
   3295           * @fn      zclParseInReadRspCmd
   3296           *
   3297           * @brief   Parse the "Profile" Read Response Commands
   3298           *
   3299           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3300           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3301           *
   3302           * @param   pCmd - pointer to incoming data to parse
   3303           *
   3304           * @return  pointer to the parsed command structure
   3305           */
   3306          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   3307          {
   3308            zclReadRspCmd_t *readRspCmd;
   3309            uint8 *pBuf = pCmd->pData;
   3310            uint8 *dataPtr;
   3311            uint8 numAttr = 0;
   3312            uint8 hdrLen;
   3313            uint16 dataLen = 0;
   3314            uint16 attrDataLen;
   3315          
   3316            // find out the number of attributes and the length of attribute data
   3317            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3318            {
   3319              uint8 status;
   3320          
   3321              numAttr++;
   3322              pBuf += 2; // move pass attribute id
   3323          
   3324              status = *pBuf++;
   3325              if ( status == ZCL_STATUS_SUCCESS )
   3326              {
   3327                uint8 dataType = *pBuf++;
   3328          
   3329                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3330                pBuf += attrDataLen; // move pass attribute data
   3331          
   3332                // add padding if needed
   3333                if ( PADDING_NEEDED( attrDataLen ) )
   3334                {
   3335                  attrDataLen++;
   3336                }
   3337          
   3338                dataLen += attrDataLen;
   3339              }
   3340            }
   3341          
   3342            // calculate the length of the response header
   3343            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   3344          
   3345            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3346            if ( readRspCmd != NULL )
   3347            {
   3348              uint8 i;
   3349              pBuf = pCmd->pData;
   3350              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   3351          
   3352              readRspCmd->numAttr = numAttr;
   3353              for ( i = 0; i < numAttr; i++ )
   3354              {
   3355                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   3356          
   3357                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3358                pBuf += 2;
   3359          
   3360                statusRec->status = *pBuf++;
   3361                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   3362                {
   3363                  statusRec->dataType = *pBuf++;
   3364          
   3365                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   3366                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   3367                  statusRec->data = dataPtr;
   3368          
   3369                  pBuf += attrDataLen; // move pass attribute data
   3370          
   3371                  // advance attribute data pointer
   3372                  if ( PADDING_NEEDED( attrDataLen ) )
   3373                  {
   3374                    attrDataLen++;
   3375                  }
   3376          
   3377                  dataPtr += attrDataLen;
   3378                }
   3379              }
   3380            }
   3381          
   3382            return ( (void *)readRspCmd );
   3383          }
   3384          #endif // ZCL_READ
   3385          
   3386          #ifdef ZCL_WRITE
   3387          /*********************************************************************
   3388           * @fn      zclParseInWriteCmd
   3389           *
   3390           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3391           *          Response Commands
   3392           *
   3393           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3394           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3395           *
   3396           * @param   pCmd - pointer to incoming data to parse
   3397           *
   3398           * @return  pointer to the parsed command structure
   3399           */
   3400          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   3401          {
   3402            zclWriteCmd_t *writeCmd;
   3403            uint8 *pBuf = pCmd->pData;
   3404            uint16 attrDataLen;
   3405            uint8 *dataPtr;
   3406            uint8 numAttr = 0;
   3407            uint8 hdrLen;
   3408            uint16 dataLen = 0;
   3409          
   3410            // find out the number of attributes and the length of attribute data
   3411            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3412            {
   3413              uint8 dataType;
   3414          
   3415              numAttr++;
   3416              pBuf += 2; // move pass attribute id
   3417          
   3418              dataType = *pBuf++;
   3419          
   3420              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3421              pBuf += attrDataLen; // move pass attribute data
   3422          
   3423              // add padding if needed
   3424              if ( PADDING_NEEDED( attrDataLen ) )
   3425              {
   3426                attrDataLen++;
   3427              }
   3428          
   3429              dataLen += attrDataLen;
   3430            }
   3431          
   3432            // calculate the length of the response header
   3433            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   3434          
   3435            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3436            if ( writeCmd != NULL )
   3437            {
   3438              uint8 i;
   3439              pBuf = pCmd->pData;
   3440              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3441          
   3442              writeCmd->numAttr = numAttr;
   3443              for ( i = 0; i < numAttr; i++ )
   3444              {
   3445                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3446          
   3447                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3448                pBuf += 2;
   3449                statusRec->dataType = *pBuf++;
   3450          
   3451                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   3452                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   3453                statusRec->attrData = dataPtr;
   3454          
   3455                pBuf += attrDataLen; // move pass attribute data
   3456          
   3457                // advance attribute data pointer
   3458                if ( PADDING_NEEDED( attrDataLen ) )
   3459                {
   3460                  attrDataLen++;
   3461                }
   3462          
   3463                dataPtr += attrDataLen;
   3464              }
   3465            }
   3466          
   3467            return ( (void *)writeCmd );
   3468          }
   3469          
   3470          /*********************************************************************
   3471           * @fn      zclParseInWriteRspCmd
   3472           *
   3473           * @brief   Parse the "Profile" Write Response Commands
   3474           *
   3475           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3476           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3477           *
   3478           * @param   pCmd - pointer to incoming data to parse
   3479           *
   3480           * @return  pointer to the parsed command structure
   3481           */
   3482          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   3483          {
   3484            zclWriteRspCmd_t *writeRspCmd;
   3485            uint8 *pBuf = pCmd->pData;
   3486            uint8 i = 0;
   3487          
   3488            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   3489            if ( writeRspCmd != NULL )
   3490            {
   3491              if ( pCmd->dataLen == 1 )
   3492              {
   3493                // special case when all writes were successfull
   3494                writeRspCmd->attrList[i++].status = *pBuf;
   3495              }
   3496              else
   3497              {
   3498                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3499                {
   3500                  writeRspCmd->attrList[i].status = *pBuf++;
   3501                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3502                  pBuf += 2;
   3503                }
   3504              }
   3505          
   3506              writeRspCmd->numAttr = i;
   3507            }
   3508          
   3509            return ( (void *)writeRspCmd );
   3510          }
   3511          #endif // ZCL_WRITE
   3512          
   3513          #ifdef ZCL_REPORT
   3514          /*********************************************************************
   3515           * @fn      zclParseInConfigReportCmd
   3516           *
   3517           * @brief   Parse the "Profile" Configure Reporting Command
   3518           *
   3519           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3520           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3521           *
   3522           * @param   pCmd - pointer to incoming data to parse
   3523           *
   3524           * @return  pointer to the parsed command structure
   3525           */
   3526          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   3527          {
   3528            zclCfgReportCmd_t *cfgReportCmd;
   3529            uint8 *pBuf = pCmd->pData;
   3530            uint8 *dataPtr;
   3531            uint8 numAttr = 0;
   3532            uint8 dataType;
   3533            uint8 hdrLen;
   3534            uint16 dataLen = 0;
   3535            uint8 reportChangeLen; // length of Reportable Change field
   3536          
   3537            // Calculate the length of the Request command
   3538            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3539            {
   3540              uint8 direction;
   3541          
   3542              numAttr++;
   3543              direction = *pBuf++;
   3544              pBuf += 2; // move pass the attribute ID
   3545          
   3546              // Is there a Reportable Change field?
   3547              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3548              {
   3549                dataType = *pBuf++;
   3550                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3551          
   3552                // For attributes of 'discrete' data types this field is omitted
   3553                if ( zclAnalogDataType( dataType ) )
   3554                {
   3555                  reportChangeLen = zclGetDataTypeLength( dataType );
   3556                  pBuf += reportChangeLen;
   3557          
   3558                  // add padding if needed
   3559                  if ( PADDING_NEEDED( reportChangeLen ) )
   3560                  {
   3561                    reportChangeLen++;
   3562                  }
   3563          
   3564                  dataLen += reportChangeLen;
   3565                }
   3566                else
   3567                {
   3568                  pBuf++; // move past reportable change field
   3569                }
   3570              }
   3571              else
   3572              {
   3573                pBuf += 2; // move pass the Timeout Period
   3574              }
   3575            } // while loop
   3576          
   3577            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   3578          
   3579            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3580            if ( cfgReportCmd != NULL )
   3581            {
   3582              uint8 i;
   3583              pBuf = pCmd->pData;
   3584              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   3585          
   3586              cfgReportCmd->numAttr = numAttr;
   3587              for ( i = 0; i < numAttr; i++ )
   3588              {
   3589                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3590          
   3591                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3592          
   3593                reportRec->direction = *pBuf++;
   3594                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3595                pBuf += 2;
   3596                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3597                {
   3598                  // Attribute to be reported
   3599                  reportRec->dataType = *pBuf++;
   3600                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3601                  pBuf += 2;
   3602                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3603                  pBuf += 2;
   3604          
   3605                  // For attributes of 'discrete' data types this field is omitted
   3606                  if ( zclAnalogDataType( reportRec->dataType ) )
   3607                  {
   3608                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3609                    reportRec->reportableChange = dataPtr;
   3610          
   3611                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3612                    pBuf += reportChangeLen;
   3613          
   3614                    // advance attribute data pointer
   3615                    if ( PADDING_NEEDED( reportChangeLen ) )
   3616                    {
   3617                      reportChangeLen++;
   3618                    }
   3619          
   3620                    dataPtr += reportChangeLen;
   3621                  }
   3622                }
   3623                else
   3624                {
   3625                  // Attribute reports to be received
   3626                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3627                  pBuf += 2;
   3628                }
   3629              } // while loop
   3630            }
   3631          
   3632            return ( (void *)cfgReportCmd );
   3633          }
   3634          
   3635          /*********************************************************************
   3636           * @fn      zclParseInConfigReportRspCmd
   3637           *
   3638           * @brief   Parse the "Profile" Configure Reporting Response Command
   3639           *
   3640           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3641           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3642           *
   3643           * @param   pCmd - pointer to incoming data to parse
   3644           *
   3645           * @return  pointer to the parsed command structure
   3646           */
   3647          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3648          {
   3649            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3650            uint8 *pBuf = pCmd->pData;
   3651            uint8 numAttr;
   3652          
   3653            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3654          
   3655            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3656                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3657            if ( cfgReportRspCmd != NULL )
   3658            {
   3659              uint8 i;
   3660              cfgReportRspCmd->numAttr = numAttr;
   3661              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3662              {
   3663                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3664                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3665                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3666                pBuf += 2;
   3667              }
   3668            }
   3669          
   3670            return ( (void *)cfgReportRspCmd );
   3671          }
   3672          
   3673          /*********************************************************************
   3674           * @fn      zclParseInReadReportCfgCmd
   3675           *
   3676           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3677           *
   3678           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3679           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3680           *
   3681           * @param   pCmd - pointer to incoming data to parse
   3682           *
   3683           * @return  pointer to the parsed command structure
   3684           */
   3685          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   3686          {
   3687            zclReadReportCfgCmd_t *readReportCfgCmd;
   3688            uint8 *pBuf = pCmd->pData;
   3689            uint8 numAttr;
   3690          
   3691            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   3692          
   3693            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3694                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   3695            if ( readReportCfgCmd != NULL )
   3696            {
   3697              uint8 i;
   3698              readReportCfgCmd->numAttr = numAttr;
   3699              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   3700              {
   3701                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   3702                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3703                pBuf += 2;
   3704              }
   3705            }
   3706          
   3707            return ( (void *)readReportCfgCmd );
   3708          }
   3709          
   3710          /*********************************************************************
   3711           * @fn      zclParseInReadReportCfgRspCmd
   3712           *
   3713           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3714           *
   3715           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3716           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3717           *
   3718           * @param   pCmd - pointer to incoming data to parse
   3719           *
   3720           * @return  pointer to the parsed command structure
   3721           */
   3722          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   3723          {
   3724            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3725            uint8 reportChangeLen;
   3726            uint8 *pBuf = pCmd->pData;
   3727            uint8 *dataPtr;
   3728            uint8 numAttr = 0;
   3729            uint8 hdrLen;
   3730            uint16 dataLen = 0;
   3731          
   3732            // Calculate the length of the response command
   3733            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3734            {
   3735              uint8 status;
   3736              uint8 direction;
   3737          
   3738              numAttr++;
   3739              status = *pBuf++;
   3740              direction = *pBuf++;
   3741              pBuf += 2; // move pass the attribute ID
   3742          
   3743              if ( status == ZCL_STATUS_SUCCESS )
   3744              {
   3745                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3746                {
   3747                  uint8 dataType = *pBuf++;
   3748                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3749          
   3750                  // For attributes of 'discrete' data types this field is omitted
   3751                  if ( zclAnalogDataType( dataType ) )
   3752                  {
   3753                    reportChangeLen = zclGetDataTypeLength( dataType );
   3754                    pBuf += reportChangeLen;
   3755          
   3756                    // add padding if needed
   3757                    if ( PADDING_NEEDED( reportChangeLen ) )
   3758                    {
   3759                      reportChangeLen++;
   3760                    }
   3761          
   3762                    dataLen += reportChangeLen;
   3763                  }
   3764                }
   3765                else
   3766                {
   3767                  pBuf += 2; // move pass the Timeout field
   3768                }
   3769              }
   3770            } // while loop
   3771          
   3772            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   3773          
   3774            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3775            if ( readReportCfgRspCmd != NULL )
   3776            {
   3777              uint8 i;
   3778              pBuf = pCmd->pData;
   3779              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   3780          
   3781              readReportCfgRspCmd->numAttr = numAttr;
   3782              for ( i = 0; i < numAttr; i++ )
   3783              {
   3784                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3785          
   3786                reportRspRec->status = *pBuf++;
   3787                reportRspRec->direction = *pBuf++;
   3788                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3789                pBuf += 2;
   3790          
   3791                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3792                {
   3793                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3794                  {
   3795                    reportRspRec->dataType = *pBuf++;
   3796                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3797                    pBuf += 2;
   3798                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3799                    pBuf += 2;
   3800          
   3801                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3802                    {
   3803                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3804                      reportRspRec->reportableChange = dataPtr;
   3805          
   3806                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3807                      pBuf += reportChangeLen;
   3808          
   3809                      // advance attribute data pointer
   3810                      if ( PADDING_NEEDED( reportChangeLen ) )
   3811                      {
   3812                        reportChangeLen++;
   3813                      }
   3814          
   3815                      dataPtr += reportChangeLen;
   3816                    }
   3817                  }
   3818                  else
   3819                  {
   3820                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3821                    pBuf += 2;
   3822                  }
   3823                }
   3824              }
   3825            }
   3826          
   3827            return ( (void *)readReportCfgRspCmd );
   3828          }
   3829          
   3830          /*********************************************************************
   3831           * @fn      zclParseInReportCmd
   3832           *
   3833           * @brief   Parse the "Profile" Report Command
   3834           *
   3835           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3836           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3837           *
   3838           * @param   pCmd - pointer to incoming data to parse
   3839           *
   3840           * @return  pointer to the parsed command structure
   3841           */
   3842          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   3843          {
   3844            zclReportCmd_t *reportCmd;
   3845            uint8 *pBuf = pCmd->pData;
   3846            uint16 attrDataLen;
   3847            uint8 *dataPtr;
   3848            uint8 numAttr = 0;
   3849            uint8 hdrLen;
   3850            uint16 dataLen = 0;
   3851          
   3852            // find out the number of attributes and the length of attribute data
   3853            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3854            {
   3855              uint8 dataType;
   3856          
   3857              numAttr++;
   3858              pBuf += 2; // move pass attribute id
   3859          
   3860              dataType = *pBuf++;
   3861          
   3862              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3863              pBuf += attrDataLen; // move pass attribute data
   3864          
   3865              // add padding if needed
   3866              if ( PADDING_NEEDED( attrDataLen ) )
   3867              {
   3868                attrDataLen++;
   3869              }
   3870          
   3871              dataLen += attrDataLen;
   3872            }
   3873          
   3874            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   3875          
   3876            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3877            if (reportCmd != NULL )
   3878            {
   3879              uint8 i;
   3880              pBuf = pCmd->pData;
   3881              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3882          
   3883              reportCmd->numAttr = numAttr;
   3884              for ( i = 0; i < numAttr; i++ )
   3885              {
   3886                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   3887          
   3888                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3889                pBuf += 2;
   3890                reportRec->dataType = *pBuf++;
   3891          
   3892                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   3893                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   3894                reportRec->attrData = dataPtr;
   3895          
   3896                pBuf += attrDataLen; // move pass attribute data
   3897          
   3898                // advance attribute data pointer
   3899                if ( PADDING_NEEDED( attrDataLen ) )
   3900                {
   3901                  attrDataLen++;
   3902                }
   3903          
   3904                dataPtr += attrDataLen;
   3905              }
   3906            }
   3907          
   3908            return ( (void *)reportCmd );
   3909          }
   3910          #endif // ZCL_REPORT
   3911          
   3912          /*********************************************************************
   3913           * @fn      zclParseInDefaultRspCmd
   3914           *
   3915           * @brief   Parse the "Profile" Default Response Command
   3916           *
   3917           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3918           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3919           *
   3920           * @param   pCmd - pointer to incoming data to parse
   3921           *
   3922           * @return  pointer to the parsed command structure
   3923           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3924          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3925          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3926            zclDefaultRspCmd_t *defaultRspCmd;
   3927            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00000F   E8           MOV     A,R0
   \   000010   FE           MOV     R6,A
   \   000011   E9           MOV     A,R1
   \   000012   FF           MOV     R7,A
   3928          
   3929            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000013                ; Setup parameters for call to function osal_mem_alloc
   \   000013   7A02         MOV     R2,#0x2
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3930            if ( defaultRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   6003         JZ      ??CrossCallReturnLabel_5
   3931            {
   3932              defaultRspCmd->commandID = *pBuf++;
   \   00001E   12....       LCALL   ?Subroutine8 & 0xFFFF
   3933              defaultRspCmd->statusCode = *pBuf;
   3934            }
   3935          
   3936            return ( (void *)defaultRspCmd );
   \                     ??CrossCallReturnLabel_5:
   \   000021   02....       LJMP    ?Subroutine2 & 0xFFFF
   3937          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd
   3938          
   3939          #ifdef ZCL_DISCOVER
   3940          /*********************************************************************
   3941           * @fn      zclParseInDiscAttrsCmd
   3942           *
   3943           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3944           *
   3945           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3946           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3947           *
   3948           * @param   pCmd - pointer to incoming data to parse
   3949           *
   3950           * @return  pointer to the parsed command structure
   3951           */
   3952          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3953          {
   3954            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3955            uint8 *pBuf = pCmd->pData;
   3956          
   3957            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3958            if ( pDiscoverCmd != NULL )
   3959            {
   3960              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3961              pBuf += 2;
   3962              pDiscoverCmd->maxAttrIDs = *pBuf;
   3963            }
   3964          
   3965            return ( (void *)pDiscoverCmd );
   3966          }
   3967          
   3968          /*********************************************************************
   3969           * @fn      zclParseInDiscAttrsRspCmd
   3970           *
   3971           * @brief   Parse the "Profile" Discovery Response Commands
   3972           *
   3973           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3974           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3975           *
   3976           * @param   pCmd - pointer to incoming data to parse
   3977           *
   3978           * @return  pointer to the parsed command structure
   3979           */
   3980          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3981          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3982          {
   3983            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3984            uint8 *pBuf = pCmd->pData;
   3985            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3986          
   3987            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3988                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3989          
   3990            if ( pDiscoverRspCmd != NULL )
   3991            {
   3992              uint8 i;
   3993          
   3994              pDiscoverRspCmd->discComplete = *pBuf++;
   3995              pDiscoverRspCmd->numAttr = numAttr;
   3996          
   3997              for ( i = 0; i < numAttr; i++ )
   3998              {
   3999                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4000                pBuf += 2;
   4001                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4002              }
   4003            }
   4004          
   4005            return ( (void *)pDiscoverRspCmd );
   4006          }
   4007          
   4008          /*********************************************************************
   4009           * @fn      zclParseInDiscCmdsCmd
   4010           *
   4011           * @brief   Parse the "Profile" Discovery Commands
   4012           *
   4013           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4014           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4015           *
   4016           * @param   pCmd - pointer to incoming data to parse
   4017           *
   4018           * @return  pointer to the parsed command structure
   4019           */
   4020          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4021          {
   4022            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4023            uint8 *pBuf = pCmd->pData;
   4024          
   4025            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4026            if ( pDiscoverCmd != NULL )
   4027            {
   4028              pDiscoverCmd->startCmdID = *pBuf++;
   4029              pDiscoverCmd->maxCmdID = *pBuf++;
   4030            }
   4031          
   4032            return ( (void *)pDiscoverCmd );
   4033          }
   4034          
   4035          /*********************************************************************
   4036           * @fn      zclParseInDiscCmdsRspCmd
   4037           *
   4038           * @brief   Parse the Discover Commands Response Command
   4039           *
   4040           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4041           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4042           *
   4043           * @param   pCmd - pointer to incoming data to parse
   4044           *
   4045           * @return  pointer to the parsed command structure
   4046           */
   4047          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4048          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4049          {
   4050            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4051            uint8 *pBuf = pCmd->pData;
   4052            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4053          
   4054              // allocate memory for size of structure plus variable array
   4055            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4056                              ( numCmds * sizeof(uint8) ) );
   4057            if ( pDiscoverRspCmd != NULL )
   4058            {
   4059              uint8 i;
   4060              pDiscoverRspCmd->discComplete = *pBuf++;
   4061              pDiscoverRspCmd->numCmd = numCmds;
   4062          
   4063              for ( i = 0; i < numCmds; i++ )
   4064              {
   4065                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4066              }
   4067            }
   4068          
   4069            return ( (void *)pDiscoverRspCmd );
   4070          }
   4071          
   4072          /*********************************************************************
   4073           * @fn      zclParseInDiscAttrsExtRspCmd
   4074           *
   4075           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4076           *
   4077           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4078           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4079           *
   4080           * @param   pCmd - pointer to incoming data to parse
   4081           *
   4082           * @return  pointer to the parsed command structure
   4083           */
   4084          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4085          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4086          {
   4087            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4088            uint8 i;
   4089            uint8 *pBuf = pCmd->pData;
   4090            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4091          
   4092            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4093                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4094          
   4095            if ( pDiscoverRspCmd != NULL )
   4096            {
   4097              pDiscoverRspCmd->discComplete = *pBuf++;
   4098              pDiscoverRspCmd->numAttr = numAttrs;
   4099          
   4100              for ( i = 0; i < numAttrs; i++ )
   4101              {
   4102                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4103                pBuf += 2;
   4104                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4105                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4106              }
   4107            }
   4108          
   4109            return ( (void *)pDiscoverRspCmd );
   4110          }
   4111          #endif // ZCL_DISCOVER
   4112          
   4113          #ifdef ZCL_READ
   4114          /*********************************************************************
   4115           * @fn      zclProcessInReadCmd
   4116           *
   4117           * @brief   Process the "Profile" Read Command
   4118           *
   4119           * @param   pInMsg - incoming message to process
   4120           *
   4121           * @return  TRUE if command processed. FALSE, otherwise.
   4122           */
   4123          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   4124          {
   4125            zclReadCmd_t *readCmd;
   4126            zclReadRspCmd_t *readRspCmd;
   4127            zclAttrRec_t attrRec;
   4128            uint16 len;
   4129            uint8 i;
   4130          
   4131            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   4132          
   4133            // calculate the length of the response status record
   4134            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4135          
   4136            readRspCmd = zcl_mem_alloc( len );
   4137            if ( readRspCmd == NULL )
   4138            {
   4139              return FALSE; // EMBEDDED RETURN
   4140            }
   4141          
   4142            readRspCmd->numAttr = readCmd->numAttr;
   4143            for ( i = 0; i < readCmd->numAttr; i++ )
   4144            {
   4145              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4146          
   4147              statusRec->attrID = readCmd->attrID[i];
   4148          
   4149              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4150                                   readCmd->attrID[i], &attrRec ) )
   4151              {
   4152                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4153                {
   4154                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4155                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4156                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4157                  {
   4158                    statusRec->data = attrRec.attr.dataPtr;
   4159                    statusRec->dataType = attrRec.attr.dataType;
   4160                  }
   4161                }
   4162                else
   4163                {
   4164                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4165                }
   4166              }
   4167              else
   4168              {
   4169                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4170              }
   4171            }
   4172          
   4173            // Build and send Read Response command
   4174            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4175                             readRspCmd, !pInMsg->hdr.fc.direction,
   4176                             true, pInMsg->hdr.transSeqNum );
   4177            zcl_mem_free( readRspCmd );
   4178          
   4179            return TRUE;
   4180          }
   4181          #endif // ZCL_READ
   4182          
   4183          #ifdef ZCL_WRITE
   4184          /*********************************************************************
   4185           * @fn      processInWriteCmd
   4186           *
   4187           * @brief   Process the "Profile" Write and Write No Response Commands
   4188           *
   4189           * @param   pInMsg - incoming message to process
   4190           *
   4191           * @return  TRUE if command processed. FALSE, otherwise.
   4192           */
   4193          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   4194          {
   4195            zclWriteCmd_t *writeCmd;
   4196            zclWriteRspCmd_t *writeRspCmd;
   4197            uint8 sendRsp = FALSE;
   4198            uint8 j = 0;
   4199            uint8 i;
   4200          
   4201            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   4202            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   4203            {
   4204              // We need to send a response back - allocate space for it
   4205              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4206                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   4207              if ( writeRspCmd == NULL )
   4208              {
   4209                return FALSE; // EMBEDDED RETURN
   4210              }
   4211          
   4212              sendRsp = TRUE;
   4213            }
   4214          
   4215            for ( i = 0; i < writeCmd->numAttr; i++ )
   4216            {
   4217              zclAttrRec_t attrRec;
   4218              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4219          
   4220              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4221                                   statusRec->attrID, &attrRec ) )
   4222              {
   4223                if ( statusRec->dataType == attrRec.attr.dataType )
   4224                {
   4225                  uint8 status;
   4226          
   4227                  // Write the new attribute value
   4228                  if ( attrRec.attr.dataPtr != NULL )
   4229                  {
   4230                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4231                                               &attrRec, statusRec );
   4232                  }
   4233                  else // Use CB
   4234                  {
   4235                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4236                                                      &attrRec, statusRec->attrData );
   4237                  }
   4238          
   4239                  // If successful, a write attribute status record shall NOT be generated
   4240                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4241                  {
   4242                    // Attribute is read only - move on to the next write attribute record
   4243                    writeRspCmd->attrList[j].status = status;
   4244                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4245                  }
   4246                }
   4247                else
   4248                {
   4249                  // Attribute data type is incorrect - move on to the next write attribute record
   4250                  if ( sendRsp )
   4251                  {
   4252                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4253                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4254                  }
   4255                }
   4256              }
   4257              else
   4258              {
   4259                // Attribute is not supported - move on to the next write attribute record
   4260                if ( sendRsp )
   4261                {
   4262                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4263                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4264                }
   4265              }
   4266            } // for loop
   4267          
   4268            if ( sendRsp )
   4269            {
   4270              writeRspCmd->numAttr = j;
   4271              if ( writeRspCmd->numAttr == 0 )
   4272              {
   4273                // Since all records were written successful, include a single status record
   4274                // in the resonse command with the status field set to SUCCESS and the
   4275                // attribute ID field omitted.
   4276                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   4277                writeRspCmd->numAttr = 1;
   4278              }
   4279          
   4280              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4281                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4282                                true, pInMsg->hdr.transSeqNum );
   4283              zcl_mem_free( writeRspCmd );
   4284            }
   4285          
   4286            return TRUE;
   4287          }
   4288          
   4289          /*********************************************************************
   4290           * @fn      zclRevertWriteUndividedCmd
   4291           *
   4292           * @brief   Revert the "Profile" Write Undevided Command
   4293           *
   4294           * @param   pInMsg - incoming message to process
   4295           * @param   curWriteRec - old data
   4296           * @param   numAttr - number of attributes to be reverted
   4297           *
   4298           * @return  none
   4299           */
   4300          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   4301                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4302          {
   4303            uint8 i;
   4304          
   4305            for ( i = 0; i < numAttr; i++ )
   4306            {
   4307              zclAttrRec_t attrRec;
   4308              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4309          
   4310              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4311                                    statusRec->attrID, &attrRec ) )
   4312              {
   4313                break; // should never happen
   4314              }
   4315          
   4316              if ( attrRec.attr.dataPtr != NULL )
   4317              {
   4318                // Just copy the old data back - no need to validate the data
   4319                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4320                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4321              }
   4322              else // Use CB
   4323              {
   4324                // Write the old data back
   4325                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4326                                         &attrRec, statusRec->attrData );
   4327              }
   4328            } // for loop
   4329          }
   4330          
   4331          /*********************************************************************
   4332           * @fn      zclProcessInWriteUndividedCmd
   4333           *
   4334           * @brief   Process the "Profile" Write Undivided Command
   4335           *
   4336           * @param   pInMsg - incoming message to process
   4337           *
   4338           * @return  TRUE if command processed. FALSE, otherwise.
   4339           */
   4340          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   4341          {
   4342            zclWriteCmd_t *writeCmd;
   4343            zclWriteRspCmd_t *writeRspCmd;
   4344            zclAttrRec_t attrRec;
   4345            uint16 dataLen;
   4346            uint16 curLen = 0;
   4347            uint8 j = 0;
   4348            uint8 i;
   4349          
   4350            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   4351          
   4352            // Allocate space for Write Response Command
   4353            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4354                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   4355            if ( writeRspCmd == NULL )
   4356            {
   4357              return FALSE; // EMBEDDED RETURN
   4358            }
   4359          
   4360            // If any attribute cannot be written, no attribute values are changed. Hence,
   4361            // make sure all the attributes are supported and writable
   4362            for ( i = 0; i < writeCmd->numAttr; i++ )
   4363            {
   4364              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4365          
   4366              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4367                                    statusRec->attrID, &attrRec ) )
   4368              {
   4369                // Attribute is not supported - stop here
   4370                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4371                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4372                break;
   4373              }
   4374          
   4375              if ( statusRec->dataType != attrRec.attr.dataType )
   4376              {
   4377                // Attribute data type is incorrect - stope here
   4378                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4379                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4380                break;
   4381              }
   4382          
   4383              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4384              {
   4385                // Attribute is not writable - stop here
   4386                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4387                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4388                break;
   4389              }
   4390          
   4391              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4392              {
   4393                // Not authorized to write - stop here
   4394                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4395                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4396                break;
   4397              }
   4398          
   4399              // Attribute Data length
   4400              if ( attrRec.attr.dataPtr != NULL )
   4401              {
   4402                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4403              }
   4404              else // Use CB
   4405              {
   4406                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4407                                                       statusRec->attrID );
   4408              }
   4409          
   4410              // add padding if needed
   4411              if ( PADDING_NEEDED( dataLen ) )
   4412              {
   4413                dataLen++;
   4414              }
   4415          
   4416              curLen += dataLen;
   4417            } // for loop
   4418          
   4419            writeRspCmd->numAttr = j;
   4420            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   4421            {
   4422              uint8 *curDataPtr;
   4423              zclWriteRec_t *curWriteRec;
   4424          
   4425              // calculate the length of the current data header
   4426              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   4427          
   4428              // Allocate space to keep a copy of the current data
   4429              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   4430              if ( curWriteRec == NULL )
   4431              {
   4432                zcl_mem_free(writeRspCmd );
   4433                return FALSE; // EMBEDDED RETURN
   4434              }
   4435          
   4436              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   4437          
   4438              // Write the new data over
   4439              for ( i = 0; i < writeCmd->numAttr; i++ )
   4440              {
   4441                uint8 status;
   4442                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4443                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4444          
   4445                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4446                                      statusRec->attrID, &attrRec ) )
   4447                {
   4448                  break; // should never happen
   4449                }
   4450          
   4451                // Keep a copy of the current data before before writing the new data over
   4452                curStatusRec->attrID = statusRec->attrID;
   4453                curStatusRec->attrData = curDataPtr;
   4454          
   4455                if ( attrRec.attr.dataPtr != NULL )
   4456                {
   4457                  // Read the current value
   4458                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4459          
   4460                  // Write the new attribute value
   4461                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4462                                             &attrRec, statusRec );
   4463                }
   4464                else // Use CBs
   4465                {
   4466                  // Read the current value
   4467                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4468                                          statusRec->attrID, curDataPtr, &dataLen );
   4469                  // Write the new attribute value
   4470                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4471                                                    &attrRec, statusRec->attrData );
   4472                }
   4473          
   4474                // If successful, a write attribute status record shall NOT be generated
   4475                if ( status != ZCL_STATUS_SUCCESS )
   4476                {
   4477                  writeRspCmd->attrList[j].status = status;
   4478                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4479          
   4480                  // Since this write failed, we need to revert all the pervious writes
   4481                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4482                  break;
   4483                }
   4484          
   4485                // add padding if needed
   4486                if ( PADDING_NEEDED( dataLen ) )
   4487                {
   4488                  dataLen++;
   4489                }
   4490          
   4491                curDataPtr += dataLen;
   4492              } // for loop
   4493          
   4494              writeRspCmd->numAttr = j;
   4495              if ( writeRspCmd->numAttr  == 0 )
   4496              {
   4497                // Since all records were written successful, include a single status record
   4498                // in the resonse command with the status field set to SUCCESS and the
   4499                // attribute ID field omitted.
   4500                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   4501                writeRspCmd->numAttr = 1;
   4502              }
   4503          
   4504              zcl_mem_free( curWriteRec );
   4505            }
   4506          
   4507            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4508                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4509                              true, pInMsg->hdr.transSeqNum );
   4510            zcl_mem_free( writeRspCmd );
   4511          
   4512            return TRUE;
   4513          }
   4514          #endif // ZCL_WRITE
   4515          
   4516          #ifdef ZCL_DISCOVER
   4517          /*********************************************************************
   4518           * @fn      zclProcessInDiscAttrs
   4519           *
   4520           * @brief   Process the "Profile" Discover Attributes Commands
   4521           *
   4522           * @param   pInMsg - incoming message to process
   4523           *
   4524           * @return  TRUE if command processed. FALSE, otherwise.
   4525           */
   4526          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4527          {
   4528            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4529            zclAttrRec_t attrRec;
   4530            uint16 attrID;
   4531            uint8 numAttrs;
   4532            uint8 i;
   4533          
   4534            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4535          
   4536            // Find out the number of attributes supported within the specified range
   4537            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4538            {
   4539              // finds the next attribute on this endpoint/cluster after the range.
   4540              // attributes must be in numerical order in the list.
   4541              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4542              {
   4543                break;
   4544              }
   4545            }
   4546          
   4547            numAttrs = i;  // store range of attributes in buffer
   4548          
   4549              // Process message for either attributes or extended attributes
   4550            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4551            {
   4552              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4553            }
   4554            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4555            {
   4556              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4557            }
   4558          
   4559            return TRUE;
   4560          }
   4561          
   4562          /*********************************************************************
   4563           * @fn      zclProcessInDiscAttrsCmd
   4564           *
   4565           * @brief   Process the Discover Attributes Command
   4566           *
   4567           * @param   pInMsg - incoming message to process
   4568           *
   4569           * @param   pDiscoverCmd - structure from requesting command
   4570           *
   4571           * @param   attrLenBuf - describes the amount of attributes to be processed
   4572           *
   4573           * @return  none
   4574           */
   4575          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4576          {
   4577            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4578            uint8 discComplete = TRUE;
   4579            zclAttrRec_t attrRec;
   4580            uint16 attrID;
   4581            uint8 i;
   4582          
   4583            // Allocate space for the response command
   4584            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4585                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4586            if ( pDiscoverRsp == NULL )
   4587            {
   4588              return; // EMBEDDED RETURN
   4589            }
   4590          
   4591            if ( numAttrs != 0 )
   4592            {
   4593              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4594              {
   4595                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4596                {
   4597                  break; // should not happen, as numAttrs already calculated
   4598                }
   4599          
   4600                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4601                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4602              }
   4603          
   4604              // Are there more attributes to be discovered?
   4605              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4606              {
   4607                discComplete = FALSE;
   4608              }
   4609            }
   4610          
   4611            pDiscoverRsp->discComplete = discComplete;
   4612            pDiscoverRsp->numAttr = numAttrs;
   4613          
   4614            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4615                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4616                                         true, pInMsg->hdr.transSeqNum );
   4617            zcl_mem_free( pDiscoverRsp );
   4618          
   4619            return;
   4620          }
   4621          
   4622          /*********************************************************************
   4623           * @fn      zclProcessInDiscAttrsExtCmd
   4624           *
   4625           * @brief   Process the Discover Attributes Extended Command
   4626           *
   4627           * @param   pInMsg - incoming message to process
   4628           *
   4629           * @param   pDiscoverCmd - structure from requesting command
   4630           *
   4631           * @param   attrLenBuf - describes the amount of attributes to be processed
   4632           *
   4633           * @return  none
   4634           */
   4635          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4636          {
   4637            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4638            uint8 discComplete = TRUE;
   4639            zclAttrRec_t attrRec;
   4640            uint16 attrID;
   4641            uint8 i;
   4642          
   4643              // Allocate space for the response command
   4644            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4645                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4646            if ( pDiscoverExtRsp == NULL )
   4647            {
   4648              return; // EMBEDDED RETURN
   4649            }
   4650          
   4651          
   4652            if ( numAttrs != 0 )
   4653            {
   4654              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4655              {
   4656                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4657                {
   4658                  break; // Should not happen, as numAttrs already calculated
   4659                }
   4660          
   4661                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4662                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4663                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4664              }
   4665          
   4666              // Are there more attributes to be discovered?
   4667              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4668              {
   4669                discComplete = FALSE;
   4670              }
   4671            }
   4672          
   4673            pDiscoverExtRsp->discComplete = discComplete;
   4674            pDiscoverExtRsp->numAttr = numAttrs;
   4675          
   4676            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4677                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4678                                         true, pInMsg->hdr.transSeqNum );
   4679          
   4680            zcl_mem_free( pDiscoverExtRsp );
   4681          
   4682            return;
   4683          }
   4684          
   4685          /*********************************************************************
   4686           * @fn      zclProcessInDiscCmd
   4687           *
   4688           * @brief   Process the "Profile" Discover Command
   4689           *
   4690           * @param   pInMsg - incoming message to process
   4691           *
   4692           * @return  TRUE if command processed. FALSE, otherwise.
   4693           */
   4694          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4695          {
   4696            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4697            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4698            ZStatus_t status;
   4699            zclCommandRec_t cmdRec;
   4700            uint8 cmdID;
   4701            uint8 i;
   4702            uint8 j;
   4703          
   4704            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4705          
   4706            // Find out the number of commands supported within the specified range
   4707            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4708            {
   4709              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4710              {
   4711                break;  // Command not supported
   4712              }
   4713            }
   4714          
   4715            // Allocate space for the response command
   4716            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4717          
   4718            if ( cmdRsp.pCmdID == NULL )
   4719            {
   4720              return FALSE; // EMBEDDED RETURN
   4721            }
   4722          
   4723            if ( i != 0 )
   4724            {
   4725              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4726              {
   4727                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4728                {
   4729                  break; // Attribute not supported
   4730                }
   4731          
   4732                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4733              }
   4734            }
   4735          
   4736            // Are there more commands to be discovered?
   4737            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4738            {
   4739              cmdRsp.discComplete = FALSE;
   4740            }
   4741            else
   4742            {
   4743              cmdRsp.discComplete = TRUE;
   4744            }
   4745          
   4746            // pass the command requested
   4747            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4748          
   4749            // store number of commands returned
   4750            cmdRsp.numCmd = j;
   4751          
   4752            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4753                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4754                                                true, pInMsg->hdr.transSeqNum );
   4755          
   4756            zcl_mem_free( cmdRsp.pCmdID );
   4757          
   4758            if ( status == ZSuccess )
   4759            {
   4760              return TRUE;
   4761            }
   4762            else
   4763            {
   4764              return FALSE;
   4765            }
   4766          }
   4767          
   4768          #endif // ZCL_DISCOVER
   4769          
   4770          /*********************************************************************
   4771          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     39   zclBuildHdr
      2     38   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     19   zclFindClusterOption
      0      9   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     45   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0      9   zclGetDataTypeLength
      1     47   zclParseHdr
        0     12   -> osal_memset
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     20   zclSerializeData
        0     20   -> osal_buffer_uint32
        0     19   -> osal_memcpy
      0     45   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     59   zcl_DeviceOperational
        0     22   -> zclFindAttrRec
      1     10   zcl_HandleExternal
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   zcl_Init
      1     54   zcl_ProcessMessageMSG
        0     35   -> StubAPS_InterPan
        0     35   -> afFindEndPointDesc
        0     35   -> osal_mem_free
        0     35   -> zclGetClusterOption
        0     35   -> zclParseHdr
        0     35   -> zclSetSecurityOption
        0     37   -> zcl_DeviceOperational
        0     42   -> zcl_SendDefaultRspCmd
      1     62   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> StubAPS_InterPan
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     65   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      2      0   zcl_registerForMsg
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       4  ??Subroutine49_0
       5  ??Subroutine50_0
       6  ??Subroutine51_0
       2  ??Subroutine52_0
       8  ??Subroutine53_0
       7  ??Subroutine54_0
       7  ?Subroutine0
       5  ?Subroutine1
       4  ?Subroutine10
       7  ?Subroutine11
       8  ?Subroutine12
       1  ?Subroutine13
       4  ?Subroutine14
       6  ?Subroutine15
       7  ?Subroutine16
       9  ?Subroutine17
      18  ?Subroutine18
      11  ?Subroutine19
       5  ?Subroutine2
      15  ?Subroutine20
       6  ?Subroutine21
      16  ?Subroutine22
       8  ?Subroutine23
      21  ?Subroutine24
       5  ?Subroutine25
      25  ?Subroutine26
       4  ?Subroutine27
      16  ?Subroutine28
       6  ?Subroutine29
       5  ?Subroutine3
      12  ?Subroutine30
      12  ?Subroutine31
      11  ?Subroutine32
      11  ?Subroutine33
      10  ?Subroutine34
       6  ?Subroutine35
       6  ?Subroutine36
       9  ?Subroutine37
       4  ?Subroutine38
      11  ?Subroutine39
       5  ?Subroutine4
       6  ?Subroutine40
       4  ?Subroutine41
       9  ?Subroutine42
      13  ?Subroutine43
       6  ?Subroutine44
      11  ?Subroutine45
       7  ?Subroutine46
       6  ?Subroutine47
       7  ?Subroutine48
       5  ?Subroutine5
      17  ?Subroutine6
      12  ?Subroutine7
      23  ?Subroutine8
       6  ?Subroutine9
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
     109  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     176  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     128  zclFindClusterOption
       6  zclFindClusterOption::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
      26  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
     233  zclParseHdr
       6  zclParseHdr::?relay
      36  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
     359  zclSerializeData
       6  zclSerializeData::?relay
      36  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
      70  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     169  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
      12  zcl_Init
       6  zcl_Init::?relay
    1194  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
       1  zcl_RegisteredMsgTaskID
     499  zcl_SendCommand
       6  zcl_SendCommand::?relay
     136  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
       6  zcl_event_loop::?relay
       9  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      12  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
      80  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      68  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      24  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
     103  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      55  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      17  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 4 390 bytes in segment BANKED_CODE
   156 bytes in segment BANK_RELAYS
    92 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    14 bytes in segment XDATA_Z
 
 4 639 bytes of CODE  memory
    15 bytes of XDATA memory

Errors: none
Warnings: none
