###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Nov/2018  13:52:11
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\mt\MT_UTIL.c
#    Command line       =  
#        -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack
#        Mesh 1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\mt\MT_UTIL.c" -D FEATURE_SYSTEM_STATS -D POWER_SAVING
#        -lC "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" --diag_suppress
#        Pe001,Pa010 -o "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e --no_code_motion
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\MT_UTIL.lst
#    Object file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj\MT_UTIL.r51
#
###############################################################################

D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh 1.0.0\Components\mt\MT_UTIL.c
      1          /***************************************************************************************************
      2            Filename:       MT_UTIL.c
      3            Revised:        $Date: 2014-08-25 13:49:12 -0700 (Mon, 25 Aug 2014) $
      4            Revision:       $Revision: 39868 $
      5          
      6            Description:    MonitorTest Utility Functions
      7          
      8            Copyright 2007-2014 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License"). You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product. Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38           ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          
     45          #include "AddrMgr.h"
     46          
     47          #include "OnBoard.h"   /* This is here because of the key reading */

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     48          #include "hal_key.h"
     49          #include "hal_led.h"
     50          #include "OSAL_Nv.h"
     51          #include "osal.h"
     52          #include "NLMEDE.h"
     53          #include "MT.h"
     54          #include "MT_UTIL.h"
     55          #include "MT_MAC.h"
     56          #include "ssp.h"
     57          #if defined ZCL_KEY_ESTABLISH
     58          #include "zcl_key_establish.h"
     59          #if defined TC_LINKKEY_JOIN
     60          #include "zcl_se.h"
     61          #endif
     62          #endif
     63          
     64          #if !defined NONWK
     65          #include "MT_ZDO.h"
     66          #include "MT_SAPI.h"
     67          #include "MT_NWK.h"
     68          #include "MT_AF.h"
     69          #include "AssocList.h"
     70          #include "ZDApp.h"
     71          #include "ZDSecMgr.h"
     72          #endif
     73          
     74          #if defined MT_SRNG
     75          #include "hal_srng.h"
     76          #endif
     77          
     78          /***************************************************************************************************
     79           * CONSTANTS
     80           ***************************************************************************************************/
     81          #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
     82          #define MT_UTIL_STATUS_LEN    1
     83          #define MT_UTIL_FRM_CTR_LEN   4
     84          // Status + LinkKeyDataLen + Tx+Rx Frame counter.
     85          #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
     86          // Status + NV id
     87          #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
     88          
     89          /***************************************************************************************************
     90           * LOCAL VARIABLES
     91           ***************************************************************************************************/
     92          #if defined ZCL_KEY_ESTABLISH
     93          uint8 zcl_key_establish_task_id;
     94          #endif
     95          
     96          #ifdef FEATURE_GET_PRIMARY_IEEE
     97          /* This feature is not compatible with MSP430 or ARM platforms. */
     98          __no_init const __xdata char ieeeMac[1] @ 0x780C;
     99          #endif
    100          
    101          /***************************************************************************************************
    102           * LOCAL FUNCTIONS
    103           ***************************************************************************************************/
    104          #ifdef AUTO_PEND
    105          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
    106          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
    107          #endif
    108          
    109          #if defined (MT_UTIL_FUNC)
    110          void MT_UtilGetDeviceInfo(void);
    111          void MT_UtilGetNvInfo(void);
    112          void MT_UtilSetPanID(uint8 *pBuf);
    113          void MT_UtilSetChannels(uint8 *pBuf);
    114          void MT_UtilSetSecLevel(uint8 *pBuf);
    115          void MT_UtilSetPreCfgKey(uint8 *pBuf);
    116          void MT_UtilCallbackSub(uint8 *pData);
    117          void MT_UtilKeyEvent(uint8 *pBuf);
    118          void MT_UtilTimeAlive(void);
    119          void MT_UtilLedControl(uint8 *pBuf);
    120          void MT_UtilSrcMatchEnable (uint8 *pBuf);
    121          void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
    122          void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
    123          void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
    124          void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
    125          void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
    126          #ifdef MT_SRNG
    127          void MT_UtilSrngGen(void);
    128          #endif
    129          
    130          void MT_UtilGpioSetDirection(uint8 *pBuf);
    131          void MT_UtilGpioRead(uint8 *pBuf);
    132          void MT_UtilGpioWrite(uint8 *pBuf);
    133          
    134          #ifdef FEATURE_GET_PRIMARY_IEEE
    135          void MT_UtilGetPrimaryIEEE(void);
    136          #endif
    137          
    138          #if !defined NONWK
    139          void MT_UtilDataReq(uint8 *pBuf);
    140          static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf);
    141          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
    142          #if defined MT_SYS_KEY_MANAGEMENT
    143          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
    144          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
    145          #endif //MT_SYS_KEY_MANAGEMENT
    146          static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
    147          static void MT_UtilAssocCount(uint8 *pBuf);
    148          static void MT_UtilAssocFindDevice(uint8 *pBuf);
    149          static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
    150          static void MT_UtilBindAddEntry(uint8 *pBuf);
    151          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
    152          static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind);
    153          #if defined ZCL_KEY_ESTABLISH
    154          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
    155          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
    156          #endif // ZCL_KEY_ESTABLISH
    157          static void MT_UtilSync(void);
    158          #endif // !defined NONWK
    159          #endif // MT_UTIL_FUNC
    160          
    161          #if defined (MT_UTIL_FUNC)
    162          /***************************************************************************************************
    163          * @fn      MT_UtilProcessing
    164          *
    165          * @brief   Process all the DEBUG commands that are issued by test tool
    166          *
    167          * @param   pBuf  - pointer to received SPI data message
    168          *
    169          * @return  status
    170          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    171          uint8 MT_UtilCommandProcessing(uint8 *pBuf)
   \                     MT_UtilCommandProcessing:
    172          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 46
   \   000005   74D2         MOV     A,#-0x2e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    173            uint8 status = MT_RPC_SUCCESS;
   \   00000A   75..00       MOV     ?V0,#0x0
    174          
    175            switch (pBuf[MT_RPC_POS_CMD1])
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??MT_UtilCommandProcessing_0 & 0xFFFF
   \   000019   14           DEC     A
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??MT_UtilCommandProcessing_1 & 0xFFFF
   \   00001F   14           DEC     A
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??MT_UtilCommandProcessing_2 & 0xFFFF
   \   000025   14           DEC     A
   \   000026   7003         JNZ     $+5
   \   000028   02....       LJMP    ??MT_UtilCommandProcessing_3 & 0xFFFF
   \   00002B   14           DEC     A
   \   00002C   7003         JNZ     $+5
   \   00002E   02....       LJMP    ??MT_UtilCommandProcessing_4 & 0xFFFF
   \   000031   14           DEC     A
   \   000032   7003         JNZ     $+5
   \   000034   02....       LJMP    ??MT_UtilCommandProcessing_5 & 0xFFFF
   \   000037   14           DEC     A
   \   000038   7003         JNZ     $+5
   \   00003A   02....       LJMP    ??MT_UtilCommandProcessing_6 & 0xFFFF
   \   00003D   14           DEC     A
   \   00003E   7003         JNZ     $+5
   \   000040   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
   \   000043   24FE         ADD     A,#-0x2
   \   000045   7003         JNZ     $+5
   \   000047   02....       LJMP    ??MT_UtilCommandProcessing_8 & 0xFFFF
   \   00004A   14           DEC     A
   \   00004B   7003         JNZ     $+5
   \   00004D   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
   \   000050   24FA         ADD     A,#-0x6
   \   000052   7003         JNZ     $+5
   \   000054   02....       LJMP    ??MT_UtilCommandProcessing_9 & 0xFFFF
   \   000057   14           DEC     A
   \   000058   7003         JNZ     $+5
   \   00005A   02....       LJMP    ??MT_UtilCommandProcessing_10 & 0xFFFF
   \   00005D   24FD         ADD     A,#-0x3
   \   00005F   7003         JNZ     $+5
   \   000061   02....       LJMP    ??MT_UtilCommandProcessing_11 & 0xFFFF
   \   000064   14           DEC     A
   \   000065   7003         JNZ     $+5
   \   000067   02....       LJMP    ??MT_UtilCommandProcessing_12 & 0xFFFF
   \   00006A   14           DEC     A
   \   00006B   7003         JNZ     $+5
   \   00006D   02....       LJMP    ??MT_UtilCommandProcessing_13 & 0xFFFF
   \   000070   24F6         ADD     A,#-0xa
   \   000072   7003         JNZ     $+5
   \   000074   02....       LJMP    ??MT_UtilCommandProcessing_14 & 0xFFFF
   \   000077   14           DEC     A
   \   000078   7003         JNZ     $+5
   \   00007A   02....       LJMP    ??MT_UtilCommandProcessing_15 & 0xFFFF
   \   00007D   14           DEC     A
   \   00007E   7003         JNZ     $+5
   \   000080   02....       LJMP    ??MT_UtilCommandProcessing_16 & 0xFFFF
   \   000083   14           DEC     A
   \   000084   7003         JNZ     $+5
   \   000086   02....       LJMP    ??MT_UtilCommandProcessing_17 & 0xFFFF
   \   000089   14           DEC     A
   \   00008A   7003         JNZ     $+5
   \   00008C   02....       LJMP    ??MT_UtilCommandProcessing_18 & 0xFFFF
   \   00008F   14           DEC     A
   \   000090   7003         JNZ     $+5
   \   000092   02....       LJMP    ??MT_UtilCommandProcessing_19 & 0xFFFF
   \   000095   24E5         ADD     A,#-0x1b
   \   000097   7003         JNZ     $+5
   \   000099   02....       LJMP    ??MT_UtilCommandProcessing_20 & 0xFFFF
   \   00009C   14           DEC     A
   \   00009D   7003         JNZ     $+5
   \   00009F   02....       LJMP    ??MT_UtilCommandProcessing_21 & 0xFFFF
   \   0000A2   24F9         ADD     A,#-0x7
   \   0000A4   7003         JNZ     $+5
   \   0000A6   02....       LJMP    ??MT_UtilCommandProcessing_22 & 0xFFFF
   \   0000A9   14           DEC     A
   \   0000AA   7003         JNZ     $+5
   \   0000AC   02....       LJMP    ??MT_UtilCommandProcessing_23 & 0xFFFF
   \   0000AF   14           DEC     A
   \   0000B0   7003         JNZ     $+5
   \   0000B2   02....       LJMP    ??MT_UtilCommandProcessing_24 & 0xFFFF
   \   0000B5   14           DEC     A
   \   0000B6   7003         JNZ     $+5
   \   0000B8   02....       LJMP    ??MT_UtilCommandProcessing_25 & 0xFFFF
   \   0000BB   24FE         ADD     A,#-0x2
   \   0000BD   7003         JNZ     $+5
   \   0000BF   02....       LJMP    ??MT_UtilCommandProcessing_26 & 0xFFFF
   \   0000C2   246D         ADD     A,#0x6d
   \   0000C4   7003         JNZ     $+5
   \   0000C6   02....       LJMP    ??MT_UtilCommandProcessing_27 & 0xFFFF
   \   0000C9   02....       LJMP    ??MT_UtilCommandProcessing_28 & 0xFFFF
    176            {
    177              // CC253X MAC Network Processor does not have NV support
    178          #if !defined(CC253X_MACNP)
    179            case MT_UTIL_GET_DEVICE_INFO:
    180              MT_UtilGetDeviceInfo();
   \                     ??MT_UtilCommandProcessing_0:
   \   0000CC                ; Setup parameters for call to function MT_UtilGetDeviceInfo
   \   0000CC   12....       LCALL   `??MT_UtilGetDeviceInfo::?relay`; Banked call to: MT_UtilGetDeviceInfo
    181              break;
   \   0000CF   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    182          
    183            case MT_UTIL_GET_NV_INFO:
    184              MT_UtilGetNvInfo();
   \                     ??MT_UtilCommandProcessing_1:
   \   0000D2                ; Setup parameters for call to function MT_UtilGetNvInfo
   \   0000D2   12....       LCALL   `??MT_UtilGetNvInfo::?relay`; Banked call to: MT_UtilGetNvInfo
    185              break;
   \   0000D5   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    186          
    187            case MT_UTIL_SET_PANID:
    188              MT_UtilSetPanID(pBuf);
   \                     ??MT_UtilCommandProcessing_2:
   \   0000D8                ; Setup parameters for call to function MT_UtilSetPanID
   \   0000D8   12....       LCALL   `??MT_UtilSetPanID::?relay`; Banked call to: MT_UtilSetPanID
    189              break;
   \   0000DB   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    190          
    191            case MT_UTIL_SET_CHANNELS:
    192              MT_UtilSetChannels(pBuf);
   \                     ??MT_UtilCommandProcessing_3:
   \   0000DE                ; Setup parameters for call to function MT_UtilSetChannels
   \   0000DE   12....       LCALL   `??MT_UtilSetChannels::?relay`; Banked call to: MT_UtilSetChannels
    193              break;
   \   0000E1   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    194          
    195            case MT_UTIL_SET_SECLEVEL:
    196              MT_UtilSetSecLevel(pBuf);
   \                     ??MT_UtilCommandProcessing_4:
   \   0000E4                ; Setup parameters for call to function MT_UtilSetSecLevel
   \   0000E4   12....       LCALL   `??MT_UtilSetSecLevel::?relay`; Banked call to: MT_UtilSetSecLevel
    197              break;
   \   0000E7   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    198          
    199            case MT_UTIL_SET_PRECFGKEY:
    200              MT_UtilSetPreCfgKey(pBuf);
   \                     ??MT_UtilCommandProcessing_5:
   \   0000EA                ; Setup parameters for call to function MT_UtilSetPreCfgKey
   \   0000EA   12....       LCALL   `??MT_UtilSetPreCfgKey::?relay`; Banked call to: MT_UtilSetPreCfgKey
    201              break;
   \   0000ED   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    202          #endif
    203          
    204          #ifdef FEATURE_GET_PRIMARY_IEEE
    205            case MT_UTIL_GET_PRIMARY_IEEE:
    206              MT_UtilGetPrimaryIEEE();
    207              break;
    208          #endif 
    209          
    210            case MT_UTIL_CALLBACK_SUB_CMD:
    211              MT_UtilCallbackSub(pBuf);
   \                     ??MT_UtilCommandProcessing_6:
   \   0000F0                ; Setup parameters for call to function MT_UtilCallbackSub
   \   0000F0   12....       LCALL   `??MT_UtilCallbackSub::?relay`; Banked call to: MT_UtilCallbackSub
    212              break;
   \   0000F3   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    213          
    214            case MT_UTIL_KEY_EVENT:
    215          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    216              MT_UtilKeyEvent(pBuf);
    217          #endif
    218              break;
    219          
    220            case MT_UTIL_TIME_ALIVE:
    221              MT_UtilTimeAlive();
   \                     ??MT_UtilCommandProcessing_8:
   \   0000F6                ; Setup parameters for call to function MT_UtilTimeAlive
   \   0000F6   12....       LCALL   `??MT_UtilTimeAlive::?relay`; Banked call to: MT_UtilTimeAlive
    222              break;
   \   0000F9   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    223          
    224            case MT_UTIL_LED_CONTROL:
    225          #if (defined HAL_LED) && (HAL_LED == TRUE)
    226              MT_UtilLedControl(pBuf);
    227          #endif
    228              break;
    229          
    230            case MT_UTIL_SRC_MATCH_ENABLE:
    231              MT_UtilSrcMatchEnable(pBuf);
   \                     ??MT_UtilCommandProcessing_14:
   \   0000FC                ; Setup parameters for call to function MT_UtilSrcMatchEnable
   \   0000FC   12....       LCALL   `??MT_UtilSrcMatchEnable::?relay`; Banked call to: MT_UtilSrcMatchEnable
    232              break;
   \   0000FF   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    233          
    234            case MT_UTIL_SRC_MATCH_ADD_ENTRY:
    235              MT_UtilSrcMatchAddEntry(pBuf);
   \                     ??MT_UtilCommandProcessing_15:
   \   000102                ; Setup parameters for call to function MT_UtilSrcMatchAddEntry
   \   000102   12....       LCALL   `??MT_UtilSrcMatchAddEntry::?relay`; Banked call to: MT_UtilSrcMatchAddEntry
    236              break;
   \   000105   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    237          
    238            case MT_UTIL_SRC_MATCH_DEL_ENTRY:
    239              MT_UtilSrcMatchDeleteEntry(pBuf);
   \                     ??MT_UtilCommandProcessing_16:
   \   000108                ; Setup parameters for call to function MT_UtilSrcMatchDeleteEntry
   \   000108   12....       LCALL   `??MT_UtilSrcMatchDeleteEntry::?relay`; Banked call to: MT_UtilSrcMatchDeleteEntry
    240              break;
   \   00010B   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    241          
    242            case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
    243              MT_UtilSrcMatchCheckSrcAddr(pBuf);
   \                     ??MT_UtilCommandProcessing_17:
   \   00010E                ; Setup parameters for call to function MT_UtilSrcMatchCheckSrcAddr
   \   00010E   12....       LCALL   `??MT_UtilSrcMatchCheckSrcAddr::?relay`; Banked call to: MT_UtilSrcMatchCheckSrcAddr
    244              break;
   \   000111   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    245          
    246            case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
    247              MT_UtilSrcMatchAckAllPending(pBuf);
   \                     ??MT_UtilCommandProcessing_18:
   \   000114                ; Setup parameters for call to function MT_UtilSrcMatchAckAllPending
   \   000114   12....       LCALL   `??MT_UtilSrcMatchAckAllPending::?relay`; Banked call to: MT_UtilSrcMatchAckAllPending
    248              break;
   \   000117   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    249          
    250            case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
    251              MT_UtilSrcMatchCheckAllPending(pBuf);
   \                     ??MT_UtilCommandProcessing_19:
   \   00011A                ; Setup parameters for call to function MT_UtilSrcMatchCheckAllPending
   \   00011A   12....       LCALL   `??MT_UtilSrcMatchCheckAllPending::?relay`; Banked call to: MT_UtilSrcMatchCheckAllPending
    252              break;
   \   00011D   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    253          
    254            case MT_UTIL_TEST_LOOPBACK:
    255              MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
    256                                           pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
   \                     ??MT_UtilCommandProcessing_9:
   \   000120                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000120   EA           MOV     A,R2
   \   000121   2403         ADD     A,#0x3
   \   000123   FC           MOV     R4,A
   \   000124   E4           CLR     A
   \   000125   3B           ADDC    A,R3
   \   000126   FD           MOV     R5,A
   \   000127   8A82         MOV     DPL,R2
   \   000129   8B83         MOV     DPH,R3
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   FB           MOV     R3,A
   \   00012D   7A10         MOV     R2,#0x10
   \   00012F   02....       LJMP    ??MT_UtilCommandProcessing_29 & 0xFFFF
    257              break;
    258          
    259            case MT_UTIL_GPIO_SET_DIRECTION:
    260              MT_UtilGpioSetDirection(pBuf);
   \                     ??MT_UtilCommandProcessing_11:
   \   000132                ; Setup parameters for call to function MT_UtilGpioSetDirection
   \   000132   12....       LCALL   `??MT_UtilGpioSetDirection::?relay`; Banked call to: MT_UtilGpioSetDirection
    261              break;
   \   000135   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    262          	  
    263            case MT_UTIL_GPIO_READ:
    264              MT_UtilGpioRead(pBuf);
   \                     ??MT_UtilCommandProcessing_12:
   \   000138                ; Setup parameters for call to function MT_UtilGpioRead
   \   000138   12....       LCALL   `??MT_UtilGpioRead::?relay`; Banked call to: MT_UtilGpioRead
    265              break;
   \   00013B   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    266            
    267            case MT_UTIL_GPIO_WRITE:
    268              MT_UtilGpioWrite(pBuf);
   \                     ??MT_UtilCommandProcessing_13:
   \   00013E                ; Setup parameters for call to function MT_UtilGpioWrite
   \   00013E   12....       LCALL   `??MT_UtilGpioWrite::?relay`; Banked call to: MT_UtilGpioWrite
    269              break;
   \   000141   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    270            
    271          #if !defined NONWK
    272            case MT_UTIL_DATA_REQ:
    273              MT_UtilDataReq(pBuf);
   \                     ??MT_UtilCommandProcessing_10:
   \   000144                ; Setup parameters for call to function MT_UtilDataReq
   \   000144   12....       LCALL   `??MT_UtilDataReq::?relay`; Banked call to: MT_UtilDataReq
    274              break;
   \   000147   02....       LJMP    ??MT_UtilCommandProcessing_7 & 0xFFFF
    275          
    276            case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
    277              MT_UtilAddrMgrEntryLookupExt(pBuf);
   \                     ??MT_UtilCommandProcessing_20:
   \   00014A   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000150   7C08         MOV     R4,#0x8
   \   000152   7D00         MOV     R5,#0x0
   \   000154   7409         MOV     A,#0x9
   \   000156   12....       LCALL   ?XSTACK_DISP0_8
   \   000159   AA82         MOV     R2,DPL
   \   00015B   AB83         MOV     R3,DPH
   \   00015D   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000160   7403         MOV     A,#0x3
   \   000162   12....       LCALL   ?DEALLOC_XSTACK8
   \   000165                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000165   7403         MOV     A,#0x3
   \   000167   12....       LCALL   ?XSTACK_DISP101_8
   \   00016A   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00016D   7404         MOV     A,#0x4
   \   00016F   12....       LCALL   ?XSTACK_DISP0_8
   \   000172   E0           MOVX    A,@DPTR
   \   000173   F8           MOV     R0,A
   \   000174   A3           INC     DPTR
   \   000175   E0           MOVX    A,@DPTR
   \   000176   F9           MOV     R1,A
   \   000177   7401         MOV     A,#0x1
   \   000179   12....       LCALL   ?XSTACK_DISP0_8
   \   00017C   E8           MOV     A,R0
   \   00017D   F0           MOVX    @DPTR,A
   \   00017E   7402         MOV     A,#0x2
   \   000180   12....       LCALL   ?XSTACK_DISP0_8
   \   000183   E9           MOV     A,R1
   \   000184   F0           MOVX    @DPTR,A
   \   000185                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000185   7401         MOV     A,#0x1
   \   000187   12....       LCALL   ?XSTACK_DISP102_8
   \   00018A   7B02         MOV     R3,#0x2
   \   00018C   02....       LJMP    ??MT_UtilCommandProcessing_30 & 0xFFFF
    278              break;
    279          
    280            case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    281              MT_UtilAddrMgrEntryLookupNwk(pBuf);
   \                     ??MT_UtilCommandProcessing_21:
   \   00018F   8A82         MOV     DPL,R2
   \   000191   8B83         MOV     DPH,R3
   \   000193   A3           INC     DPTR
   \   000194   A3           INC     DPTR
   \   000195   E0           MOVX    A,@DPTR
   \   000196   FE           MOV     R6,A
   \   000197   EA           MOV     A,R2
   \   000198   2403         ADD     A,#0x3
   \   00019A   F582         MOV     DPL,A
   \   00019C   E4           CLR     A
   \   00019D   3B           ADDC    A,R3
   \   00019E   F583         MOV     DPH,A
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   FA           MOV     R2,A
   \   0001A2   A3           INC     DPTR
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F9           MOV     R1,A
   \   0001A5   EA           MOV     A,R2
   \   0001A6   F8           MOV     R0,A
   \   0001A7   7404         MOV     A,#0x4
   \   0001A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AC   E8           MOV     A,R0
   \   0001AD   F0           MOVX    @DPTR,A
   \   0001AE   A3           INC     DPTR
   \   0001AF   E9           MOV     A,R1
   \   0001B0   F0           MOVX    @DPTR,A
   \   0001B1                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   0001B1   7403         MOV     A,#0x3
   \   0001B3   12....       LCALL   ?XSTACK_DISP101_8
   \   0001B6   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0001B9                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0001B9   7406         MOV     A,#0x6
   \   0001BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BE   AC82         MOV     R4,DPL
   \   0001C0   AD83         MOV     R5,DPH
   \   0001C2   7B08         MOV     R3,#0x8
   \   0001C4   02....       LJMP    ??MT_UtilCommandProcessing_30 & 0xFFFF
    282              break;
    283          
    284          #if defined MT_SYS_KEY_MANAGEMENT
    285            case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    286              MT_UtilAPSME_LinkKeyDataGet(pBuf);
    287              break;
    288          
    289            case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    290              MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
    291              break;
    292          #endif // MT_SYS_KEY_MANAGEMENT
    293          
    294            case MT_UTIL_APSME_REQUEST_KEY_CMD:
    295              MT_UtilAPSME_RequestKeyCmd(pBuf);
   \                     ??MT_UtilCommandProcessing_25:
   \   0001C7   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0001CA   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001CD   7C08         MOV     R4,#0x8
   \   0001CF   7D00         MOV     R5,#0x0
   \   0001D1   7413         MOV     A,#0x13
   \   0001D3   12....       LCALL   ?XSTACK_DISP101_8
   \   0001D6   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001D9   7403         MOV     A,#0x3
   \   0001DB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001DE                ; Setup parameters for call to function ZDSecMgrRequestAppKey
   \   0001DE   7410         MOV     A,#0x10
   \   0001E0   12....       LCALL   ?XSTACK_DISP101_8
   \   0001E3   12....       LCALL   `??ZDSecMgrRequestAppKey::?relay`; Banked call to: ZDSecMgrRequestAppKey
   \   0001E6   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0001E9   8062         SJMP    ??MT_UtilCommandProcessing_30
    296              break;
    297          
    298            case MT_UTIL_ASSOC_COUNT:
    299              MT_UtilAssocCount(pBuf);
   \                     ??MT_UtilCommandProcessing_22:
   \   0001EB   8A82         MOV     DPL,R2
   \   0001ED   8B83         MOV     DPH,R3
   \   0001EF   A3           INC     DPTR
   \   0001F0   A3           INC     DPTR
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   F5..         MOV     ?V1,A
   \   0001F4   EA           MOV     A,R2
   \   0001F5   2403         ADD     A,#0x3
   \   0001F7   F8           MOV     R0,A
   \   0001F8   E4           CLR     A
   \   0001F9   3B           ADDC    A,R3
   \   0001FA   F9           MOV     R1,A
   \   0001FB   E8           MOV     A,R0
   \   0001FC   FE           MOV     R6,A
   \   0001FD   E9           MOV     A,R1
   \   0001FE   FF           MOV     R7,A
   \   0001FF   8E82         MOV     DPL,R6
   \   000201   8F83         MOV     DPH,R7
   \   000203   A3           INC     DPTR
   \   000204   8582..       MOV     ?V2,DPL
   \   000207   8583..       MOV     ?V3,DPH
   \   00020A                ; Setup parameters for call to function AssocCount
   \   00020A   E0           MOVX    A,@DPTR
   \   00020B   FA           MOV     R2,A
   \   00020C   8E82         MOV     DPL,R6
   \   00020E   8F83         MOV     DPH,R7
   \   000210   E0           MOVX    A,@DPTR
   \   000211   F9           MOV     R1,A
   \   000212   12....       LCALL   `??AssocCount::?relay`; Banked call to: AssocCount
   \   000215   8E82         MOV     DPL,R6
   \   000217   8F83         MOV     DPH,R7
   \   000219   EA           MOV     A,R2
   \   00021A   F0           MOVX    @DPTR,A
   \   00021B   85..82       MOV     DPL,?V2
   \   00021E   85..83       MOV     DPH,?V3
   \   000221   EB           MOV     A,R3
   \   000222   F0           MOVX    @DPTR,A
   \   000223                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000223   EE           MOV     A,R6
   \   000224   FC           MOV     R4,A
   \   000225   EF           MOV     A,R7
   \   000226   FD           MOV     R5,A
   \   000227   7B02         MOV     R3,#0x2
   \   000229   02....       LJMP    ??MT_UtilCommandProcessing_31 & 0xFFFF
    300              break;
    301          
    302            case MT_UTIL_ASSOC_FIND_DEVICE:
    303              MT_UtilAssocFindDevice(pBuf);
   \                     ??MT_UtilCommandProcessing_23:
   \   00022C   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   FA           MOV     R2,A
   \   000231   7B00         MOV     R3,#0x0
   \   000233   12....       LCALL   `??AssocFindDevice::?relay`; Banked call to: AssocFindDevice
   \   000236   8A..         MOV     ?V2,R2
   \   000238   8B..         MOV     ?V3,R3
   \   00023A   AC..         MOV     R4,?V2
   \   00023C   AD..         MOV     R5,?V3
   \   00023E                ; Setup parameters for call to function packDev_t
   \   00023E   7418         MOV     A,#0x18
   \   000240   12....       LCALL   ?XSTACK_DISP101_8
   \   000243   12....       LCALL   `??packDev_t::?relay`; Banked call to: packDev_t
   \   000246                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000246   7418         MOV     A,#0x18
   \   000248   12....       LCALL   ?XSTACK_DISP102_8
   \   00024B   7B16         MOV     R3,#0x16
   \                     ??MT_UtilCommandProcessing_30:
   \   00024D   EE           MOV     A,R6
   \   00024E   FA           MOV     R2,A
   \   00024F   8065         SJMP    ??MT_UtilCommandProcessing_29
    304              break;
    305          
    306            case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    307              MT_UtilAssocGetWithAddress(pBuf);
   \                     ??MT_UtilCommandProcessing_24:
   \   000251   8A82         MOV     DPL,R2
   \   000253   8B83         MOV     DPH,R3
   \   000255   A3           INC     DPTR
   \   000256   A3           INC     DPTR
   \   000257   E0           MOVX    A,@DPTR
   \   000258   F5..         MOV     ?V1,A
   \   00025A   EA           MOV     A,R2
   \   00025B   2403         ADD     A,#0x3
   \   00025D   FE           MOV     R6,A
   \   00025E   E4           CLR     A
   \   00025F   3B           ADDC    A,R3
   \   000260   FF           MOV     R7,A
   \   000261                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000261   0A           INC     R2
   \   000262   0A           INC     R2
   \   000263   0A           INC     R2
   \   000264   FB           MOV     R3,A
   \   000265   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000268   E9           MOV     A,R1
   \   000269   6006         JZ      ??MT_UtilCommandProcessing_32
   \   00026B   EE           MOV     A,R6
   \   00026C   FA           MOV     R2,A
   \   00026D   EF           MOV     A,R7
   \   00026E   FB           MOV     R3,A
   \   00026F   8004         SJMP    ??MT_UtilCommandProcessing_33
   \                     ??MT_UtilCommandProcessing_32:
   \   000271   7A00         MOV     R2,#0x0
   \   000273   7B00         MOV     R3,#0x0
   \                     ??MT_UtilCommandProcessing_33:
   \   000275                ; Setup parameters for call to function AssocGetWithAddress
   \   000275   8E82         MOV     DPL,R6
   \   000277   8F83         MOV     DPH,R7
   \   000279   A3           INC     DPTR
   \   00027A   A3           INC     DPTR
   \   00027B   A3           INC     DPTR
   \   00027C   A3           INC     DPTR
   \   00027D   A3           INC     DPTR
   \   00027E   A3           INC     DPTR
   \   00027F   A3           INC     DPTR
   \   000280   A3           INC     DPTR
   \   000281   E0           MOVX    A,@DPTR
   \   000282   FC           MOV     R4,A
   \   000283   8E82         MOV     DPL,R6
   \   000285   8F83         MOV     DPH,R7
   \   000287   A3           INC     DPTR
   \   000288   A3           INC     DPTR
   \   000289   A3           INC     DPTR
   \   00028A   A3           INC     DPTR
   \   00028B   A3           INC     DPTR
   \   00028C   A3           INC     DPTR
   \   00028D   A3           INC     DPTR
   \   00028E   A3           INC     DPTR
   \   00028F   A3           INC     DPTR
   \   000290   E0           MOVX    A,@DPTR
   \   000291   F8           MOV     R0,A
   \   000292   E4           CLR     A
   \   000293   C8           XCH     A,R0
   \   000294   F9           MOV     R1,A
   \   000295   EC           MOV     A,R4
   \   000296   28           ADD     A,R0
   \   000297   E4           CLR     A
   \   000298   39           ADDC    A,R1
   \   000299   FD           MOV     R5,A
   \   00029A   12....       LCALL   `??AssocGetWithAddress::?relay`; Banked call to: AssocGetWithAddress
   \   00029D   8A..         MOV     ?V2,R2
   \   00029F   8B..         MOV     ?V3,R3
   \   0002A1   AC..         MOV     R4,?V2
   \   0002A3   AD..         MOV     R5,?V3
   \   0002A5                ; Setup parameters for call to function packDev_t
   \   0002A5   7418         MOV     A,#0x18
   \   0002A7   12....       LCALL   ?XSTACK_DISP101_8
   \   0002AA   12....       LCALL   `??packDev_t::?relay`; Banked call to: packDev_t
   \   0002AD                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0002AD   7418         MOV     A,#0x18
   \   0002AF   12....       LCALL   ?XSTACK_DISP102_8
   \   0002B2   7B16         MOV     R3,#0x16
   \                     ??MT_UtilCommandProcessing_31:
   \   0002B4   AA..         MOV     R2,?V1
   \                     ??MT_UtilCommandProcessing_29:
   \   0002B6   7967         MOV     R1,#0x67
   \   0002B8   800F         SJMP    ??MT_UtilCommandProcessing_34
    308              break;
    309          
    310            case MT_UTIL_BIND_ADD_ENTRY:
    311              MT_UtilBindAddEntry(pBuf);
   \                     ??MT_UtilCommandProcessing_26:
   \   0002BA                ; Setup parameters for call to function MT_UtilBindAddEntry
   \   0002BA   12....       LCALL   `??MT_UtilBindAddEntry::?relay`; Banked call to: MT_UtilBindAddEntry
    312              break;
   \   0002BD   8012         SJMP    ??MT_UtilCommandProcessing_7
    313          
    314          #if defined ZCL_KEY_ESTABLISH
    315            case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    316              MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
    317              break;
    318          
    319            case MT_UTIL_ZCL_KEY_EST_SIGN:
    320              MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
    321              break;
    322          #endif
    323          
    324            case MT_UTIL_SYNC_REQ:
    325              MT_UtilSync();
   \                     ??MT_UtilCommandProcessing_27:
   \   0002BF                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0002BF   7C00         MOV     R4,#0x0
   \   0002C1   7D00         MOV     R5,#0x0
   \   0002C3   7B00         MOV     R3,#0x0
   \   0002C5   7AE0         MOV     R2,#-0x20
   \   0002C7   7947         MOV     R1,#0x47
   \                     ??MT_UtilCommandProcessing_34:
   \   0002C9   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    326              break;
   \   0002CC   8003         SJMP    ??MT_UtilCommandProcessing_7
    327          #endif /* !defined NONWK */
    328          
    329          #ifdef MT_SRNG
    330            case MT_UTIL_SRNG_GENERATE:
    331              MT_UtilSrngGen();
    332              break;
    333          #endif
    334          
    335            default:
    336              status = MT_RPC_ERR_COMMAND_ID;
   \                     ??MT_UtilCommandProcessing_28:
   \   0002CE   75..02       MOV     ?V0,#0x2
    337              break;
    338            }
    339          
    340            return status;
   \                     ??MT_UtilCommandProcessing_7:
   \   0002D1   A9..         MOV     R1,?V0
   \   0002D3   742E         MOV     A,#0x2e
   \   0002D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002D8   7F07         MOV     R7,#0x7
   \   0002DA   02....       LJMP    ?BANKED_LEAVE_XDATA
    341          }
    342          
    343          /***************************************************************************************************
    344          * @fn      MT_UtilGetDeviceInfo
    345          *
    346          * @brief   The Get Device Info serial message.
    347          *
    348          * @param   None.
    349          *
    350          * @return  void
    351          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          void MT_UtilGetDeviceInfo(void)
   \                     MT_UtilGetDeviceInfo:
    353          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    354            uint8  *buf;
    355            uint8  *pBuf;
    356            uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
   \   00000A   75..0E       MOV     ?V2,#0xe
    357            uint16 *assocList = NULL;
   \   00000D   7E00         MOV     R6,#0x0
   \   00000F   7F00         MOV     R7,#0x0
    358          
    359          #if !defined NONWK
    360            uint8  assocCnt = 0;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   E4           CLR     A
   \   000018   F0           MOVX    @DPTR,A
    361          
    362            if (ZG_DEVICE_RTR_TYPE)
   \   000019   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6004         JZ      ??MT_UtilGetDeviceInfo_0
   \   00001F   6401         XRL     A,#0x1
   \   000021   701C         JNZ     ??MT_UtilGetDeviceInfo_1
    363            {
    364              assocList = AssocMakeList( &assocCnt );
   \                     ??MT_UtilGetDeviceInfo_0:
   \   000023                ; Setup parameters for call to function AssocMakeList
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   `??AssocMakeList::?relay`; Banked call to: AssocMakeList
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   \   00002E   AE..         MOV     R6,?V0
   \   000030   AF..         MOV     R7,?V1
    365              bufLen += (assocCnt * sizeof(uint16));
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   C3           CLR     C
   \   00003A   33           RLC     A
   \   00003B   240E         ADD     A,#0xe
   \   00003D   F5..         MOV     ?V2,A
    366            }
    367          #endif
    368          
    369            buf = osal_mem_alloc( bufLen );
   \                     ??MT_UtilGetDeviceInfo_1:
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   AA..         MOV     R2,?V2
   \   000041   7B00         MOV     R3,#0x0
   \   000043   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000046   8A..         MOV     ?V0,R2
   \   000048   8B..         MOV     ?V1,R3
    370            if ( buf )
   \   00004A   EA           MOV     A,R2
   \   00004B   45..         ORL     A,?V1
   \   00004D   7003         JNZ     $+5
   \   00004F   02....       LJMP    ??MT_UtilGetDeviceInfo_2 & 0xFFFF
    371            {
    372              pBuf = buf;
    373          
    374              *pBuf++ = ZSUCCESS; // Status
   \   000052   8A82         MOV     DPL,R2
   \   000054   8B83         MOV     DPH,R3
   \   000056   E4           CLR     A
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   8582..       MOV     ?V4,DPL
   \   00005C   8583..       MOV     ?V5,DPH
    375          
    376              osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \   00005F                ; Setup parameters for call to function osal_nv_read
   \   00005F   78..         MOV     R0,#?V4
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   75..08       MOV     ?V6,#0x8
   \   000067   75..00       MOV     ?V7,#0x0
   \   00006A   78..         MOV     R0,#?V6
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   7C00         MOV     R4,#0x0
   \   000071   7D00         MOV     R5,#0x0
   \   000073   7A01         MOV     R2,#0x1
   \   000075   7B00         MOV     R3,#0x0
   \   000077   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
    377              pBuf += Z_EXTADDR_LEN;
    378          
    379          #if defined NONWK
    380              // Skip past ZStack only parameters for NONWK
    381              *pBuf++ = 0;
    382              *pBuf++ = 0;
    383              *pBuf++ = 0;
    384              *pBuf++ = 0;
    385              *pBuf = 0;
    386          #else
    387              {
    388                uint16 shortAddr = NLME_GetShortAddr();
   \   00007F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007F   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
    389                *pBuf++ = LO_UINT16( shortAddr );
   \   000082   85..82       MOV     DPL,?V4
   \   000085   85..83       MOV     DPH,?V5
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   EA           MOV     A,R2
   \   000091   12....       LCALL   ?Subroutine15 & 0xFFFF
    390                *pBuf++ = HI_UINT16( shortAddr );
    391              }
   \                     ??CrossCallReturnLabel_19:
   \   000094   EB           MOV     A,R3
   \   000095   12....       LCALL   ?Subroutine15 & 0xFFFF
    392          
    393              /* Return device type */
    394              *pBuf++ = ZSTACK_DEVICE_BUILD;
   \                     ??CrossCallReturnLabel_20:
   \   000098   A3           INC     DPTR
   \   000099   7407         MOV     A,#0x7
   \   00009B   F0           MOVX    @DPTR,A
    395          
    396              /*Return device state */
    397              *pBuf++ = (uint8)devState;
   \   00009C   90....       MOV     DPTR,#devState
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   C0E0         PUSH    A
   \   0000A2   E5..         MOV     A,?V4
   \   0000A4   240B         ADD     A,#0xb
   \   0000A6   F582         MOV     DPL,A
   \   0000A8   E4           CLR     A
   \   0000A9   35..         ADDC    A,?V5
   \   0000AB   F583         MOV     DPH,A
   \   0000AD   D0E0         POP     A
   \   0000AF   F0           MOVX    @DPTR,A
    398          
    399              if (ZG_DEVICE_RTR_TYPE)
   \   0000B0   90....       MOV     DPTR,#zgDeviceLogicalType
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   6004         JZ      ??MT_UtilGetDeviceInfo_3
   \   0000B6   6401         XRL     A,#0x1
   \   0000B8   7063         JNZ     ??MT_UtilGetDeviceInfo_4
    400              {
    401                *pBuf++ = assocCnt;
   \                     ??MT_UtilGetDeviceInfo_3:
   \   0000BA   85..82       MOV     DPL,?XSP + 0
   \   0000BD   85..83       MOV     DPH,?XSP + 1
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   C0E0         PUSH    A
   \   0000C3   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0000C6   D0E0         POP     A
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   E5..         MOV     A,?V4
   \   0000CB   240D         ADD     A,#0xd
   \   0000CD   F5..         MOV     ?V4,A
   \   0000CF   5002         JNC     ??MT_UtilGetDeviceInfo_5
   \   0000D1   05..         INC     ?V5
    402          
    403                if ( assocCnt )
   \                     ??MT_UtilGetDeviceInfo_5:
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   604A         JZ      ??MT_UtilGetDeviceInfo_6
    404                {
    405                  uint8 x;
    406                  uint16 *puint16 = assocList;
   \   0000DC   EE           MOV     A,R6
   \   0000DD   F8           MOV     R0,A
   \   0000DE   EF           MOV     A,R7
   \   0000DF   F9           MOV     R1,A
    407          
    408                  for ( x = 0; x < assocCnt; x++, puint16++ )
   \   0000E0   7C00         MOV     R4,#0x0
   \                     ??MT_UtilGetDeviceInfo_7:
   \   0000E2   85..82       MOV     DPL,?XSP + 0
   \   0000E5   85..83       MOV     DPH,?XSP + 1
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   FA           MOV     R2,A
   \   0000EA   EC           MOV     A,R4
   \   0000EB   C3           CLR     C
   \   0000EC   9A           SUBB    A,R2
   \   0000ED   5037         JNC     ??MT_UtilGetDeviceInfo_6
    409                  {
    410                    *pBuf++ = LO_UINT16( *puint16 );
   \   0000EF   8882         MOV     DPL,R0
   \   0000F1   8983         MOV     DPH,R1
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   85..82       MOV     DPL,?V4
   \   0000F7   85..83       MOV     DPH,?V5
   \   0000FA   F0           MOVX    @DPTR,A
    411                    *pBuf++ = HI_UINT16( *puint16 );
   \   0000FB   8882         MOV     DPL,R0
   \   0000FD   8983         MOV     DPH,R1
   \   0000FF   A3           INC     DPTR
   \   000100   E0           MOVX    A,@DPTR
   \   000101   85..82       MOV     DPL,?V4
   \   000104   85..83       MOV     DPH,?V5
   \   000107   A3           INC     DPTR
   \   000108   F0           MOVX    @DPTR,A
   \   000109   E5..         MOV     A,?V4
   \   00010B   2402         ADD     A,#0x2
   \   00010D   F5..         MOV     ?V4,A
   \   00010F   5002         JNC     ??MT_UtilGetDeviceInfo_8
   \   000111   05..         INC     ?V5
    412                  }
   \                     ??MT_UtilGetDeviceInfo_8:
   \   000113   0C           INC     R4
   \   000114   E8           MOV     A,R0
   \   000115   2402         ADD     A,#0x2
   \   000117   F8           MOV     R0,A
   \   000118   50C8         JNC     ??MT_UtilGetDeviceInfo_7
   \   00011A   09           INC     R1
   \   00011B   80C5         SJMP    ??MT_UtilGetDeviceInfo_7
    413                }
    414              }
    415              else
    416              {
    417                *pBuf++ = 0;
   \                     ??MT_UtilGetDeviceInfo_4:
   \   00011D   12....       LCALL   ?Subroutine22 & 0xFFFF
    418              }
   \                     ??CrossCallReturnLabel_33:
   \   000120   E4           CLR     A
   \   000121   F0           MOVX    @DPTR,A
   \   000122   E5..         MOV     A,?V4
   \   000124   240D         ADD     A,#0xd
    419          #endif
    420          
    421              MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    422                                           MT_UTIL_GET_DEVICE_INFO,
    423                                           bufLen, buf );
   \                     ??MT_UtilGetDeviceInfo_6:
   \   000126                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000126   AC..         MOV     R4,?V0
   \   000128   AD..         MOV     R5,?V1
   \   00012A   AB..         MOV     R3,?V2
   \   00012C   7A00         MOV     R2,#0x0
   \   00012E   7967         MOV     R1,#0x67
   \   000130   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    424          
    425              osal_mem_free( buf );
   \   000133                ; Setup parameters for call to function osal_mem_free
   \   000133   AA..         MOV     R2,?V0
   \   000135   AB..         MOV     R3,?V1
   \   000137   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    426            }
    427          
    428            if ( assocList )
   \                     ??MT_UtilGetDeviceInfo_2:
   \   00013A   EE           MOV     A,R6
   \   00013B   4F           ORL     A,R7
   \   00013C   6007         JZ      ??MT_UtilGetDeviceInfo_9
    429            {
    430              osal_mem_free( assocList );
   \   00013E                ; Setup parameters for call to function osal_mem_free
   \   00013E   EE           MOV     A,R6
   \   00013F   FA           MOV     R2,A
   \   000140   EF           MOV     A,R7
   \   000141   FB           MOV     R3,A
   \   000142   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    431            }
    432          }
   \                     ??MT_UtilGetDeviceInfo_9:
   \   000145   7401         MOV     A,#0x1
   \   000147   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E5..         MOV     A,?V4
   \   000002   240C         ADD     A,#0xc
   \   000004   F582         MOV     DPL,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V5
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V4
   \   000004   85..83       MOV     DPH,?V5
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    433          
    434          #ifdef MT_SRNG
    435          /***************************************************************************************************
    436          * @fn      MT_UtilSrngGen
    437          *
    438          * @brief   Generate Secure Random Numbers
    439          *
    440          * @param   None.
    441          *
    442          * @return  void
    443          ***************************************************************************************************/
    444          void MT_UtilSrngGen(void)
    445          {
    446            static uint32 count = 125000; /* 125000 * 8 bits = 1000000 bits */
    447            uint8 outrng[100];
    448            uint8 status;
    449          
    450            if(count > 0)
    451            {
    452              status = ssp_srng_generate((uint8 *)outrng, 100, NULL);
    453              if (status != SRNG_SUCCESS)
    454              {
    455                if(RNG_INIT_ERROR == status)
    456                {
    457                  ssp_srng_reseed();
    458                }
    459                else
    460                {
    461                  while(1)
    462                  {
    463                    ASM_NOP;
    464                  }
    465                } /* if(RNG_INIT_ERROR == status) */
    466              }/*if (status != SRNG_SUCCESS) */
    467          
    468              if(count >= 100)
    469              {
    470                count -= 100;
    471              }
    472              else
    473              {
    474                count = 0;
    475              }
    476              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ |
    477                                           (uint8)MT_RPC_SYS_DBG),
    478                                            MT_DEBUG_MSG,
    479                                            100,
    480                                            outrng);
    481              osal_start_timerEx(MT_TaskID, MT_SRNG_EVENT, 100);
    482            }
    483          }
    484          #endif
    485          
    486          /***************************************************************************************************
    487           * @fn      MT_UtilGetNvInfo
    488           *
    489           * @brief   The Get NV Info serial message.
    490           *
    491           * @param   None.
    492           *
    493           * @return  void
    494           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    495          void MT_UtilGetNvInfo(void)
   \                     MT_UtilGetNvInfo:
    496          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    497            uint8 len;
    498            uint8 stat;
    499            uint8 *buf;
    500            uint8 *pBuf;
    501            uint16 tmp16;
    502            uint32 tmp32;
    503          
    504            /*
    505              Get required length of buffer
    506              Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
    507            */
    508            len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
    509          
    510            buf = osal_mem_alloc( len );
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A20         MOV     R2,#0x20
   \   00000C   7B00         MOV     R3,#0x0
   \   00000E   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000011   8A..         MOV     ?V0,R2
   \   000013   8B..         MOV     ?V1,R3
   \   000015   AE..         MOV     R6,?V0
   \   000017   AF..         MOV     R7,?V1
    511            if ( buf )
   \   000019   EE           MOV     A,R6
   \   00001A   4F           ORL     A,R7
   \   00001B   7003         JNZ     $+5
   \   00001D   02....       LJMP    ??MT_UtilGetNvInfo_0 & 0xFFFF
    512            {
    513              /* Assume NV not available */
    514              osal_memset( buf, 0xFF, len );
   \   000020                ; Setup parameters for call to function osal_memset
   \   000020   7C20         MOV     R4,#0x20
   \   000022   7D00         MOV     R5,#0x0
   \   000024   79FF         MOV     R1,#-0x1
   \   000026   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    515          
    516              /* Skip over status */
    517              pBuf = buf + 1;
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   8582..       MOV     ?V2,DPL
   \   000031   8583..       MOV     ?V3,DPH
    518          
    519              /* Start with 64-bit extended address */
    520              stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \   000034                ; Setup parameters for call to function osal_nv_read
   \   000034   78..         MOV     R0,#?V2
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   75..08       MOV     ?V0,#0x8
   \   00003C   75..00       MOV     ?V1,#0x0
   \   00003F   78..         MOV     R0,#?V0
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   7C00         MOV     R4,#0x0
   \   000046   7D00         MOV     R5,#0x0
   \   000048   7A01         MOV     R2,#0x1
   \   00004A   7B00         MOV     R3,#0x0
   \   00004C   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00004F   7404         MOV     A,#0x4
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   \   000054   E9           MOV     A,R1
   \   000055   F5..         MOV     ?V0,A
    521              if ( stat ) stat = 0x01;
   \   000057   6003         JZ      ??MT_UtilGetNvInfo_1
   \   000059   75..01       MOV     ?V0,#0x1
    522              pBuf += Z_EXTADDR_LEN;
   \                     ??MT_UtilGetNvInfo_1:
   \   00005C   E5..         MOV     A,?V2
   \   00005E   2408         ADD     A,#0x8
   \   000060   F5..         MOV     ?V2,A
   \   000062   5002         JNC     ??MT_UtilGetNvInfo_2
   \   000064   05..         INC     ?V3
    523          
    524              /* Scan channel list (bit mask) */
    525              if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
   \                     ??MT_UtilGetNvInfo_2:
   \   000066                ; Setup parameters for call to function osal_nv_read
   \   000066   7402         MOV     A,#0x2
   \   000068   12....       LCALL   ?XSTACK_DISP100_8
   \   00006B   88..         MOV     ?V4,R0
   \   00006D   89..         MOV     ?V5,R1
   \   00006F   78..         MOV     R0,#?V4
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   75..04       MOV     ?V4,#0x4
   \   000077   75..00       MOV     ?V5,#0x0
   \   00007A   78..         MOV     R0,#?V4
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   7C00         MOV     R4,#0x0
   \   000081   7D00         MOV     R5,#0x0
   \   000083   7A84         MOV     R2,#-0x7c
   \   000085   7B00         MOV     R3,#0x0
   \   000087   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00008A   7404         MOV     A,#0x4
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
   \   000090   6008         JZ      ??MT_UtilGetNvInfo_3
    526              {
    527                stat |= 0x02;
   \   000092   E5..         MOV     A,?V0
   \   000094   D2E1         SETB    0xE0 /* A   */.1
   \   000096   F5..         MOV     ?V0,A
   \   000098   8060         SJMP    ??MT_UtilGetNvInfo_4
    528              }
    529              else
    530              {
    531                pBuf[0] = BREAK_UINT32( tmp32, 3 );
   \                     ??MT_UtilGetNvInfo_3:
   \   00009A   7402         MOV     A,#0x2
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   78..         MOV     R0,#?V4
   \   0000A1   12....       LCALL   ?L_MOV_X
   \   0000A4   7418         MOV     A,#0x18
   \   0000A6   78..         MOV     R0,#?V4
   \   0000A8   12....       LCALL   ?UL_SHR
   \   0000AB   85..82       MOV     DPL,?V2
   \   0000AE   85..83       MOV     DPH,?V3
   \   0000B1   E5..         MOV     A,?V4
   \   0000B3   F0           MOVX    @DPTR,A
    532                pBuf[1] = BREAK_UINT32( tmp32, 2 );
   \   0000B4   7402         MOV     A,#0x2
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   78..         MOV     R0,#?V4
   \   0000BB   12....       LCALL   ?L_MOV_X
   \   0000BE   7410         MOV     A,#0x10
   \   0000C0   78..         MOV     R0,#?V4
   \   0000C2   12....       LCALL   ?UL_SHR
   \   0000C5   85..82       MOV     DPL,?V2
   \   0000C8   85..83       MOV     DPH,?V3
   \   0000CB   A3           INC     DPTR
   \   0000CC   E5..         MOV     A,?V4
   \   0000CE   F0           MOVX    @DPTR,A
    533                pBuf[2] = BREAK_UINT32( tmp32, 1 );
   \   0000CF   7402         MOV     A,#0x2
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   78..         MOV     R0,#?V4
   \   0000D6   12....       LCALL   ?L_MOV_X
   \   0000D9   E5..         MOV     A,?V5
   \   0000DB   85..82       MOV     DPL,?V2
   \   0000DE   85..83       MOV     DPH,?V3
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   F0           MOVX    @DPTR,A
    534                pBuf[3] = BREAK_UINT32( tmp32, 0 );
   \   0000E4   7402         MOV     A,#0x2
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   78..         MOV     R0,#?V4
   \   0000EB   12....       LCALL   ?L_MOV_X
   \   0000EE   85..82       MOV     DPL,?V2
   \   0000F1   85..83       MOV     DPH,?V3
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   A3           INC     DPTR
   \   0000F7   E5..         MOV     A,?V4
   \   0000F9   F0           MOVX    @DPTR,A
    535              }
    536              pBuf += sizeof( tmp32 );
   \                     ??MT_UtilGetNvInfo_4:
   \   0000FA   E5..         MOV     A,?V2
   \   0000FC   2404         ADD     A,#0x4
   \   0000FE   F5..         MOV     ?V2,A
   \   000100   5002         JNC     ??MT_UtilGetNvInfo_5
   \   000102   05..         INC     ?V3
    537          
    538              /* ZigBee PanID */
    539              if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
   \                     ??MT_UtilGetNvInfo_5:
   \   000104                ; Setup parameters for call to function osal_nv_read
   \   000104   A8..         MOV     R0,?XSP + 0
   \   000106   A9..         MOV     R1,?XSP + 1
   \   000108   88..         MOV     ?V4,R0
   \   00010A   89..         MOV     ?V5,R1
   \   00010C   78..         MOV     R0,#?V4
   \   00010E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000111   75..02       MOV     ?V4,#0x2
   \   000114   75..00       MOV     ?V5,#0x0
   \   000117   78..         MOV     R0,#?V4
   \   000119   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011C   7C00         MOV     R4,#0x0
   \   00011E   7D00         MOV     R5,#0x0
   \   000120   7A83         MOV     R2,#-0x7d
   \   000122   7B00         MOV     R3,#0x0
   \   000124   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000127   7404         MOV     A,#0x4
   \   000129   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012C   E9           MOV     A,R1
   \   00012D   6008         JZ      ??MT_UtilGetNvInfo_6
    540              {
    541                stat |= 0x04;
   \   00012F   E5..         MOV     A,?V0
   \   000131   D2E2         SETB    0xE0 /* A   */.2
   \   000133   F5..         MOV     ?V0,A
   \   000135   801E         SJMP    ??MT_UtilGetNvInfo_7
    542              }
    543              else
    544              {
    545                pBuf[0] = LO_UINT16( tmp16 );
   \                     ??MT_UtilGetNvInfo_6:
   \   000137   85..82       MOV     DPL,?XSP + 0
   \   00013A   85..83       MOV     DPH,?XSP + 1
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   85..82       MOV     DPL,?V2
   \   000141   85..83       MOV     DPH,?V3
   \   000144   F0           MOVX    @DPTR,A
    546                pBuf[1] = HI_UINT16( tmp16 );
   \   000145   85..82       MOV     DPL,?XSP + 0
   \   000148   85..83       MOV     DPH,?XSP + 1
   \   00014B   A3           INC     DPTR
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   85..82       MOV     DPL,?V2
   \   000150   85..83       MOV     DPH,?V3
   \   000153   A3           INC     DPTR
   \   000154   F0           MOVX    @DPTR,A
    547              }
    548              pBuf += sizeof( tmp16 );
   \                     ??MT_UtilGetNvInfo_7:
   \   000155   E5..         MOV     A,?V2
   \   000157   2402         ADD     A,#0x2
   \   000159   F5..         MOV     ?V2,A
   \   00015B   5002         JNC     ??MT_UtilGetNvInfo_8
   \   00015D   05..         INC     ?V3
    549          
    550              /* Security level */
    551              if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
   \                     ??MT_UtilGetNvInfo_8:
   \   00015F                ; Setup parameters for call to function osal_nv_read
   \   00015F   78..         MOV     R0,#?V2
   \   000161   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000164   75..01       MOV     ?V4,#0x1
   \   000167   78..         MOV     R0,#?V4
   \   000169   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016C   7C00         MOV     R4,#0x0
   \   00016E   7D00         MOV     R5,#0x0
   \   000170   7A61         MOV     R2,#0x61
   \   000172   7B00         MOV     R3,#0x0
   \   000174   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000177   7404         MOV     A,#0x4
   \   000179   12....       LCALL   ?DEALLOC_XSTACK8
   \   00017C   E9           MOV     A,R1
   \   00017D   F8           MOV     R0,A
   \   00017E   85..82       MOV     DPL,?V2
   \   000181   85..83       MOV     DPH,?V3
   \   000184   A3           INC     DPTR
   \   000185   8582..       MOV     ?V2,DPL
   \   000188   8583..       MOV     ?V3,DPH
   \   00018B   6006         JZ      ??MT_UtilGetNvInfo_9
    552              {
    553                stat |= 0x08;
   \   00018D   E5..         MOV     A,?V0
   \   00018F   D2E3         SETB    0xE0 /* A   */.3
   \   000191   F5..         MOV     ?V0,A
    554              }
    555              /* Pre-configured security key */
    556              if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
   \                     ??MT_UtilGetNvInfo_9:
   \   000193                ; Setup parameters for call to function osal_nv_read
   \   000193   78..         MOV     R0,#?V2
   \   000195   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000198   75..10       MOV     ?V2,#0x10
   \   00019B   75..00       MOV     ?V3,#0x0
   \   00019E   78..         MOV     R0,#?V2
   \   0001A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A3   7C00         MOV     R4,#0x0
   \   0001A5   7D00         MOV     R5,#0x0
   \   0001A7   7A62         MOV     R2,#0x62
   \   0001A9   7B00         MOV     R3,#0x0
   \   0001AB   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0001AE   7404         MOV     A,#0x4
   \   0001B0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B3   E9           MOV     A,R1
   \   0001B4   6006         JZ      ??MT_UtilGetNvInfo_10
    557              {
    558                stat |= 0x10;
   \   0001B6   E5..         MOV     A,?V0
   \   0001B8   D2E4         SETB    0xE0 /* A   */.4
   \   0001BA   F5..         MOV     ?V0,A
    559              }
    560              /* Status bit mask - bit=1 indicates failure */
    561              *buf = stat;
   \                     ??MT_UtilGetNvInfo_10:
   \   0001BC   8E82         MOV     DPL,R6
   \   0001BE   8F83         MOV     DPH,R7
   \   0001C0   E5..         MOV     A,?V0
   \   0001C2   F0           MOVX    @DPTR,A
    562          
    563              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
    564                                            len, buf );
   \   0001C3                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0001C3   EE           MOV     A,R6
   \   0001C4   FC           MOV     R4,A
   \   0001C5   EF           MOV     A,R7
   \   0001C6   FD           MOV     R5,A
   \   0001C7   7B20         MOV     R3,#0x20
   \   0001C9   7A01         MOV     R2,#0x1
   \   0001CB   7967         MOV     R1,#0x67
   \   0001CD   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    565          
    566              osal_mem_free( buf );
   \   0001D0                ; Setup parameters for call to function osal_mem_free
   \   0001D0   EE           MOV     A,R6
   \   0001D1   FA           MOV     R2,A
   \   0001D2   EF           MOV     A,R7
   \   0001D3   FB           MOV     R3,A
   \   0001D4   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    567            }
    568          }
   \                     ??MT_UtilGetNvInfo_0:
   \   0001D7   7406         MOV     A,#0x6
   \   0001D9   02....       LJMP    ?Subroutine0 & 0xFFFF
    569          
    570          /***************************************************************************************************
    571           * @fn      MT_UtilSetPanID
    572           *
    573           * @brief   Set PanID message
    574           *
    575           * @param   pBuf - pointer to the data
    576           *
    577           * @return  void
    578           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    579          void MT_UtilSetPanID(uint8 *pBuf)
   \                     MT_UtilSetPanID:
    580          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    581            uint16 temp16;
    582            uint8 retValue;
    583            uint8 cmdId;
    584          
    585            /* parse header */
    586            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FE           MOV     R6,A
    587            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   000012   EA           MOV     A,R2
   \   000013   2403         ADD     A,#0x3
   \   000015   FA           MOV     R2,A
   \   000016   5001         JNC     ??MT_UtilSetPanID_0
   \   000018   0B           INC     R3
    588          
    589            temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
   \                     ??MT_UtilSetPanID_0:
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FC           MOV     R4,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   EC           MOV     A,R4
   \   000023   F8           MOV     R0,A
   \   000024   7401         MOV     A,#0x1
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E8           MOV     A,R0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E9           MOV     A,R1
   \   00002D   F0           MOVX    @DPTR,A
    590          
    591            retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
   \   00002E                ; Setup parameters for call to function osal_nv_item_len
   \   00002E   7A83         MOV     R2,#-0x7d
   \   000030   7B00         MOV     R3,#0x0
   \   000032   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000035   8A..         MOV     ?V0,R2
   \   000037   8B..         MOV     ?V1,R3
   \   000039                ; Setup parameters for call to function osal_nv_write
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?XSTACK_DISP100_8
   \   00003E   88..         MOV     ?V2,R0
   \   000040   89..         MOV     ?V3,R1
   \   000042   78..         MOV     R0,#?V2
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   78..         MOV     R0,#?V0
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   7C00         MOV     R4,#0x0
   \   00004E   7D00         MOV     R5,#0x0
   \   000050   7A83         MOV     R2,#-0x7d
   \   000052   7B00         MOV     R3,#0x0
   \   000054   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   12....       LCALL   ?Subroutine16 & 0xFFFF
    592          
    593            /* Build and send back the response */
    594            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
   \                     ??CrossCallReturnLabel_21:
   \   00005F   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    595          }
   \   000062   7403         MOV     A,#0x3
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067                REQUIRE ?Subroutine1
   \   000067                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E9           MOV     A,R1
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000008                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000008   AC..         MOV     R4,?XSP + 0
   \   00000A   AD..         MOV     R5,?XSP + 1
   \   00000C   7B01         MOV     R3,#0x1
   \   00000E   EE           MOV     A,R6
   \   00000F   FA           MOV     R2,A
   \   000010   7967         MOV     R1,#0x67
   \   000012   22           RET
    596          
    597          /***************************************************************************************************
    598           * @fn      MT_UtilSetChannels
    599           *
    600           * @brief   Set Channels
    601           *
    602           * @param   pBuf - pointer to the data
    603           *
    604           * @return  void
    605           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    606          void MT_UtilSetChannels(uint8 *pBuf)
   \                     MT_UtilSetChannels:
    607          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    608            uint32 tmp32;
    609            uint8 retValue;
    610            uint8 cmdId;
    611          
    612            /* parse header */
    613            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FE           MOV     R6,A
    614            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   000012   EA           MOV     A,R2
   \   000013   2403         ADD     A,#0x3
   \   000015   FA           MOV     R2,A
   \   000016   5001         JNC     ??MT_UtilSetChannels_0
   \   000018   0B           INC     R3
    615          
    616            tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
   \                     ??MT_UtilSetChannels_0:
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F5..         MOV     ?V0,A
   \   000020   E4           CLR     A
   \   000021   F5..         MOV     ?V1,A
   \   000023   F5..         MOV     ?V2,A
   \   000025   F5..         MOV     ?V3,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V4,A
   \   00002B   E4           CLR     A
   \   00002C   F5..         MOV     ?V5,A
   \   00002E   F5..         MOV     ?V6,A
   \   000030   F5..         MOV     ?V7,A
   \   000032   7408         MOV     A,#0x8
   \   000034   78..         MOV     R0,#?V4
   \   000036   12....       LCALL   ?L_SHL
   \   000039   78..         MOV     R0,#?V0
   \   00003B   79..         MOV     R1,#?V4
   \   00003D   12....       LCALL   ?L_ADD
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F5..         MOV     ?V4,A
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V5,A
   \   00004C   7410         MOV     A,#0x10
   \   00004E   78..         MOV     R0,#?V4
   \   000050   12....       LCALL   ?L_SHL
   \   000053   78..         MOV     R0,#?V0
   \   000055   79..         MOV     R1,#?V4
   \   000057   12....       LCALL   ?L_ADD
   \   00005A   8A82         MOV     DPL,R2
   \   00005C   8B83         MOV     DPH,R3
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F5..         MOV     ?V4,A
   \   000064   E4           CLR     A
   \   000065   F5..         MOV     ?V6,A
   \   000067   7418         MOV     A,#0x18
   \   000069   78..         MOV     R0,#?V4
   \   00006B   12....       LCALL   ?L_SHL
   \   00006E   78..         MOV     R0,#?V0
   \   000070   79..         MOV     R1,#?V4
   \   000072   12....       LCALL   ?L_ADD
   \   000075   7401         MOV     A,#0x1
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   78..         MOV     R0,#?V0
   \   00007C   12....       LCALL   ?L_MOV_TO_X
    617          
    618            retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
   \   00007F                ; Setup parameters for call to function osal_nv_item_len
   \   00007F   7A84         MOV     R2,#-0x7c
   \   000081   7B00         MOV     R3,#0x0
   \   000083   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000086   8A..         MOV     ?V0,R2
   \   000088   8B..         MOV     ?V1,R3
   \   00008A                ; Setup parameters for call to function osal_nv_write
   \   00008A   7401         MOV     A,#0x1
   \   00008C   12....       LCALL   ?XSTACK_DISP100_8
   \   00008F   88..         MOV     ?V2,R0
   \   000091   89..         MOV     ?V3,R1
   \   000093   78..         MOV     R0,#?V2
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   78..         MOV     R0,#?V0
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009D   7C00         MOV     R4,#0x0
   \   00009F   7D00         MOV     R5,#0x0
   \   0000A1   7A84         MOV     R2,#-0x7c
   \   0000A3   7B00         MOV     R3,#0x0
   \   0000A5   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000A8   7404         MOV     A,#0x4
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AD   12....       LCALL   ?Subroutine16 & 0xFFFF
    619          
    620            /* Build and send back the response */
    621            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
   \                     ??CrossCallReturnLabel_22:
   \   0000B0   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    622          }
   \   0000B3   7405         MOV     A,#0x5
   \   0000B5                REQUIRE ?Subroutine0
   \   0000B5                ; // Fall through to label ?Subroutine0
    623          
    624          /***************************************************************************************************
    625           * @fn      MT_UtilSetSecLevel
    626           *
    627           * @brief   Set Sec Level
    628           *
    629           * @param   byte *msg - pointer to the data
    630           *
    631           * @return  void
    632           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    633          void MT_UtilSetSecLevel(uint8 *pBuf)
   \                     MT_UtilSetSecLevel:
    634          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    635            uint8 retValue;
    636            uint8 cmdId;
    637          
    638            /* parse header */
    639            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0,A
    640            pBuf += MT_RPC_FRAME_HDR_SZ;
    641          
    642            retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
   \   000017                ; Setup parameters for call to function osal_nv_item_len
   \   000017   7A61         MOV     R2,#0x61
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   78..         MOV     R0,#?V2
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A61         MOV     R2,#0x61
   \   00002F                REQUIRE ?Subroutine2
   \   00002F                ; // Fall through to label ?Subroutine2
    643          
    644            /* Build and send back the response */
    645            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    646          
    647          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000005   7404         MOV     A,#0x4
   \   000007   12....       LCALL   ?DEALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00000D   AA..         MOV     R2,?V0
   \   00000F   7967         MOV     R1,#0x67
   \   000011   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   \   000014   7401         MOV     A,#0x1
   \   000016   12....       LCALL   ?DEALLOC_XSTACK8
   \   000019   7F06         MOV     R7,#0x6
   \   00001B   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E9           MOV     A,R1
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine31_0
   \   000007                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001   AC..         MOV     R4,?XSP + 0
   \   000003   AD..         MOV     R5,?XSP + 1
   \   000005   7B01         MOV     R3,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   8A..         MOV     ?V2,R2
   \   000002   8B..         MOV     ?V3,R3
   \   000004                ; Setup parameters for call to function osal_nv_write
   \   000004                ; Setup parameters for call to function osal_nv_write
   \   000004   EE           MOV     A,R6
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V4,A
   \   000009   E4           CLR     A
   \   00000A   3F           ADDC    A,R7
   \   00000B   F5..         MOV     ?V5,A
   \   00000D   78..         MOV     R0,#?V4
   \   00000F   22           RET
    648          
    649          /***************************************************************************************************
    650           * @fn      MT_UtilSetPreCfgKey
    651           *
    652           * @brief   Set Pre Cfg Key
    653           *
    654           * @param   pBuf - pointer to the data
    655           *
    656           * @return  void
    657           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    658          void MT_UtilSetPreCfgKey(uint8 *pBuf)
   \                     MT_UtilSetPreCfgKey:
    659          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    660            uint8 retValue;
    661            uint8 cmdId;
    662          
    663            /* parse header */
    664            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0,A
    665            pBuf += MT_RPC_FRAME_HDR_SZ;
    666          
    667            retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
   \   000017                ; Setup parameters for call to function osal_nv_item_len
   \   000017   7A62         MOV     R2,#0x62
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   78..         MOV     R0,#?V2
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A62         MOV     R2,#0x62
   \   00002F   80..         SJMP    ?Subroutine2
    668          
    669            /* Build and send back the response */
    670            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    671          
    672          }
    673          
    674          #ifdef FEATURE_GET_PRIMARY_IEEE
    675          /***************************************************************************************************
    676           * @fn      MT_UtilGetPrimaryIEEE
    677           *
    678           * @brief   Return a copy of the Primary IEEE address
    679           *
    680           * @param   none
    681           *
    682           * @return  void
    683           ***************************************************************************************************/
    684          void MT_UtilGetPrimaryIEEE(void)
    685          {
    686            uint8 i;
    687            uint8 retBuf[Z_EXTADDR_LEN+1];
    688          
    689            retBuf[0] = SUCCESS;
    690           
    691            for(i = 1; i <= Z_EXTADDR_LEN; i++)
    692            {
    693              retBuf[i] = ieeeMac[i];
    694            }
    695            
    696            MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), 
    697                                            MT_UTIL_GET_PRIMARY_IEEE, Z_EXTADDR_LEN+1, retBuf );
    698          }
    699          #endif /* FEATURE_GET_PRIMARY_IEEE */
    700          
    701          /***************************************************************************************************
    702           * @fn      MT_UtilCallbackSub
    703           *
    704           * @brief   The Callback subscribe.
    705           *
    706           * @param   pBuf - pointer to the data
    707           *
    708           * @return  void
    709           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    710          void MT_UtilCallbackSub(uint8 *pBuf)
   \                     MT_UtilCallbackSub:
    711          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FC           MOV     R4,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FD           MOV     R5,A
    712            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000E   8C82         MOV     DPL,R4
   \   000010   8D83         MOV     DPH,R5
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0,A
    713            uint8 retValue = ZFailure;
    714          
    715          #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
    716            uint8 subSystem;
    717            uint16 subscribed_command;
    718          
    719            // Move past header
    720            retValue = ZSuccess;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E4           CLR     A
   \   00001E   F0           MOVX    @DPTR,A
    721            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00001F   EC           MOV     A,R4
   \   000020   2403         ADD     A,#0x3
   \   000022   FC           MOV     R4,A
   \   000023   5001         JNC     ??MT_UtilCallbackSub_0
   \   000025   0D           INC     R5
    722          
    723            /* Command */
    724            subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
   \                     ??MT_UtilCallbackSub_0:
   \   000026   8C82         MOV     DPL,R4
   \   000028   8D83         MOV     DPH,R5
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FA           MOV     R2,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   E4           CLR     A
   \   000030   C8           XCH     A,R0
   \   000031   F9           MOV     R1,A
   \   000032   EA           MOV     A,R2
   \   000033   28           ADD     A,R0
   \   000034   E4           CLR     A
   \   000035   39           ADDC    A,R1
   \   000036   FB           MOV     R3,A
    725            pBuf += 2;
    726          
    727            /* Subsystem - 5 bits on the MSB of the command */
    728            subSystem = HI_UINT16(subscribed_command) & 0x1F ;
   \   000037   541F         ANL     A,#0x1f
   \   000039   F9           MOV     R1,A
    729          
    730            /* What is the action - SUBSCRIBE or !SUBSCRIBE */
    731            if (*pBuf)
   \   00003A   8C82         MOV     DPL,R4
   \   00003C   8D83         MOV     DPH,R5
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   6031         JZ      ??MT_UtilCallbackSub_1
    732            {
    733              /* Turn ON */
    734            #if defined( MT_MAC_CB_FUNC )
    735              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    736                _macCallbackSub = 0xFFFF;
    737            #endif
    738          
    739            #if defined( MT_NWK_CB_FUNC )
    740              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    741                _nwkCallbackSub = 0xFFFF;
    742            #endif
    743          
    744            #if defined( MT_ZDO_CB_FUNC )
    745              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
   \   000043   7405         MOV     A,#0x5
   \   000045   69           XRL     A,R1
   \   000046   600A         JZ      ??MT_UtilCallbackSub_2
   \   000048   74FF         MOV     A,#-0x1
   \   00004A   6A           XRL     A,R2
   \   00004B   7003         JNZ     ??MT_UtilCallbackSub_3
   \   00004D   74FF         MOV     A,#-0x1
   \   00004F   6B           XRL     A,R3
   \                     ??MT_UtilCallbackSub_3:
   \   000050   700C         JNZ     ??MT_UtilCallbackSub_4
    746                _zdoCallbackSub = 0xFFFFFFFF;
   \                     ??MT_UtilCallbackSub_2:
   \   000052   90....       MOV     DPTR,#_zdoCallbackSub
   \   000055   74FF         MOV     A,#-0x1
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
    747            #endif
    748          
    749            #if defined( MT_AF_CB_FUNC )
    750              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    751                _afCallbackSub = 0xFFFF;
    752            #endif
    753          
    754            #if defined( MT_SAPI_CB_FUNC )
    755              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
   \                     ??MT_UtilCallbackSub_4:
   \   00005E   7406         MOV     A,#0x6
   \   000060   69           XRL     A,R1
   \   000061   600A         JZ      ??MT_UtilCallbackSub_5
   \   000063   74FF         MOV     A,#-0x1
   \   000065   6A           XRL     A,R2
   \   000066   7003         JNZ     ??MT_UtilCallbackSub_6
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   6B           XRL     A,R3
   \                     ??MT_UtilCallbackSub_6:
   \   00006B   7037         JNZ     ??MT_UtilCallbackSub_7
    756                _sapiCallbackSub = 0xFFFF;
   \                     ??MT_UtilCallbackSub_5:
   \   00006D   90....       MOV     DPTR,#_sapiCallbackSub
   \   000070   74FF         MOV     A,#-0x1
   \   000072   802D         SJMP    ??MT_UtilCallbackSub_8
    757            #endif
    758            }
    759            else
    760            {
    761              /* Turn OFF */
    762            #if defined( MT_MAC_CB_FUNC )
    763              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    764                _macCallbackSub = 0x0000;
    765            #endif
    766          
    767            #if defined( MT_NWK_CB_FUNC )
    768              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    769                _nwkCallbackSub = 0x0000;
    770            #endif
    771          
    772            #if defined( MT_ZDO_CB_FUNC )
    773              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
   \                     ??MT_UtilCallbackSub_1:
   \   000074   7405         MOV     A,#0x5
   \   000076   69           XRL     A,R1
   \   000077   600A         JZ      ??MT_UtilCallbackSub_9
   \   000079   74FF         MOV     A,#-0x1
   \   00007B   6A           XRL     A,R2
   \   00007C   7003         JNZ     ??MT_UtilCallbackSub_10
   \   00007E   74FF         MOV     A,#-0x1
   \   000080   6B           XRL     A,R3
   \                     ??MT_UtilCallbackSub_10:
   \   000081   700B         JNZ     ??MT_UtilCallbackSub_11
    774                _zdoCallbackSub = 0x00000000;
   \                     ??MT_UtilCallbackSub_9:
   \   000083   90....       MOV     DPTR,#_zdoCallbackSub
   \   000086   E4           CLR     A
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   A3           INC     DPTR
   \   00008D   F0           MOVX    @DPTR,A
    775            #endif
    776          
    777            #if defined( MT_AF_CB_FUNC )
    778              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    779                _afCallbackSub = 0x0000;
    780            #endif
    781          
    782            #if defined( MT_SAPI_CB_FUNC )
    783              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
   \                     ??MT_UtilCallbackSub_11:
   \   00008E   7406         MOV     A,#0x6
   \   000090   69           XRL     A,R1
   \   000091   600A         JZ      ??MT_UtilCallbackSub_12
   \   000093   74FF         MOV     A,#-0x1
   \   000095   6A           XRL     A,R2
   \   000096   7003         JNZ     ??MT_UtilCallbackSub_13
   \   000098   74FF         MOV     A,#-0x1
   \   00009A   6B           XRL     A,R3
   \                     ??MT_UtilCallbackSub_13:
   \   00009B   7007         JNZ     ??MT_UtilCallbackSub_7
    784                  _sapiCallbackSub = 0x0000;
   \                     ??MT_UtilCallbackSub_12:
   \   00009D   90....       MOV     DPTR,#_sapiCallbackSub
   \   0000A0   E4           CLR     A
   \                     ??MT_UtilCallbackSub_8:
   \   0000A1   F0           MOVX    @DPTR,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   F0           MOVX    @DPTR,A
    785            #endif
    786            }
    787          #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
    788          
    789            /* Build and send back the response */
    790            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   \                     ??MT_UtilCallbackSub_7:
   \   0000A4                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0000A4   AC..         MOV     R4,?XSP + 0
   \   0000A6   AD..         MOV     R5,?XSP + 1
   \   0000A8   7B01         MOV     R3,#0x1
   \   0000AA   AA..         MOV     R2,?V0
   \   0000AC   7967         MOV     R1,#0x67
   \   0000AE   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    791          }
   \   0000B1   7401         MOV     A,#0x1
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B6   7F01         MOV     R7,#0x1
   \   0000B8   02....       LJMP    ?BANKED_LEAVE_XDATA
    792          
    793          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    794          /***************************************************************************************************
    795           * @fn      MT_UtilKeyEvent
    796           *
    797           * @brief   Process Key Event
    798           *
    799           * @param   pBuf - pointer to the data
    800           *
    801           * @return  void
    802           ***************************************************************************************************/
    803          void MT_UtilKeyEvent(uint8 *pBuf)
    804          {
    805            uint8 x = 0;
    806            uint8 retValue;
    807            uint8 cmdId;
    808          
    809            /* parse header */
    810            cmdId = pBuf[MT_RPC_POS_CMD1];
    811            pBuf += MT_RPC_FRAME_HDR_SZ;
    812          
    813            /* Translate between SPI values to device values */
    814            if ( *pBuf & 0x01 )
    815              x |= HAL_KEY_SW_1;
    816            if ( *pBuf & 0x02 )
    817              x |= HAL_KEY_SW_2;
    818            if ( *pBuf & 0x04 )
    819              x |= HAL_KEY_SW_3;
    820            if ( *pBuf & 0x08 )
    821              x |= HAL_KEY_SW_4;
    822          #if defined ( HAL_KEY_SW_5 )
    823            if ( *pBuf & 0x10 )
    824              x |= HAL_KEY_SW_5;
    825          #endif
    826          #if defined ( HAL_KEY_SW_6 )
    827            if ( *pBuf & 0x20 )
    828              x |= HAL_KEY_SW_6;
    829          #endif
    830          #if defined ( HAL_KEY_SW_7 )
    831            if ( *pBuf & 0x40 )
    832              x |= HAL_KEY_SW_7;
    833          #endif
    834          #if defined ( HAL_KEY_SW_8 )
    835            if ( *pBuf & 0x80 )
    836              x |= HAL_KEY_SW_8;
    837          #endif
    838            pBuf++;
    839          
    840            retValue = OnBoard_SendKeys(x, *pBuf);
    841          
    842            /* Build and send back the response */
    843            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    844          }
    845          #endif
    846          
    847          /***************************************************************************************************
    848           * @fn      MT_UtilTimeAlive
    849           *
    850           * @brief   Process Time Alive
    851           *
    852           * @param   None.
    853           *
    854           * @return  None
    855           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          void MT_UtilTimeAlive(void)
   \                     MT_UtilTimeAlive:
    857          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    858            uint8 timeAlive[4];
    859            uint32 tmp32;
    860          
    861            /* Time since last reset (seconds) */
    862            tmp32 = osal_GetSystemClock() / 1000;
   \   00000A                ; Setup parameters for call to function osal_GetSystemClock
   \   00000A   12....       LCALL   `??osal_GetSystemClock::?relay`; Banked call to: osal_GetSystemClock
   \   00000D   8A..         MOV     ?V4,R2
   \   00000F   8B..         MOV     ?V5,R3
   \   000011   8C..         MOV     ?V6,R4
   \   000013   8D..         MOV     ?V7,R5
   \   000015   90....       MOV     DPTR,#__Constant_3e8
   \   000018   78..         MOV     R0,#?V0
   \   00001A   12....       LCALL   ?L_MOV_X
   \   00001D   78..         MOV     R0,#?V4
   \   00001F   79..         MOV     R1,#?V0
   \   000021   12....       LCALL   ?UL_DIV_MOD
    863          
    864            /* Convert to high byte first into temp buffer */
    865            timeAlive[0] = BREAK_UINT32(tmp32, 0);
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   E5..         MOV     A,?V4
   \   00002C   F0           MOVX    @DPTR,A
    866            timeAlive[1] = BREAK_UINT32(tmp32, 1);
   \   00002D   85....       MOV     ?V1,?V5
   \   000030   E5..         MOV     A,?V1
   \   000032   F5..         MOV     ?V0,A
   \   000034   7401         MOV     A,#0x1
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E5..         MOV     A,?V0
   \   00003B   F0           MOVX    @DPTR,A
    867            timeAlive[2] = BREAK_UINT32(tmp32, 2);
   \   00003C   85....       MOV     ?V0,?V4
   \   00003F   85....       MOV     ?V2,?V6
   \   000042   85....       MOV     ?V3,?V7
   \   000045   7410         MOV     A,#0x10
   \   000047   78..         MOV     R0,#?V0
   \   000049   12....       LCALL   ?UL_SHR
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   E5..         MOV     A,?V0
   \   000053   F0           MOVX    @DPTR,A
    868            timeAlive[3] = BREAK_UINT32(tmp32, 3);
   \   000054   7418         MOV     A,#0x18
   \   000056   78..         MOV     R0,#?V4
   \   000058   12....       LCALL   ?UL_SHR
   \   00005B   7403         MOV     A,#0x3
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E5..         MOV     A,?V4
   \   000062   12....       LCALL   ?Subroutine18 & 0xFFFF
    869          
    870            /* Build and send back the response */
    871            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    872                                                 MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
   \                     ??CrossCallReturnLabel_23:
   \   000065   7B04         MOV     R3,#0x4
   \   000067   7A09         MOV     R2,#0x9
   \   000069   7967         MOV     R1,#0x67
   \   00006B   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    873          }
   \   00006E   7404         MOV     A,#0x4
   \   000070   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001   AC..         MOV     R4,?XSP + 0
   \   000003   AD..         MOV     R5,?XSP + 1
   \   000005   22           RET
    874          
    875          #if (defined HAL_LED) && (HAL_LED == TRUE)
    876          /***************************************************************************************************
    877           * @fn      MT_UtilLedControl
    878           *
    879           * @brief   Process the LED Control Message
    880           *
    881           * @param   pBuf - pointer to the received data
    882           *
    883           * @return  None
    884           ***************************************************************************************************/
    885          void MT_UtilLedControl(uint8 *pBuf)
    886          {
    887            uint8 iLed, Led, iMode, Mode, cmdId;
    888            uint8 retValue;
    889          
    890            /* parse header */
    891            cmdId = pBuf[MT_RPC_POS_CMD1];
    892            pBuf += MT_RPC_FRAME_HDR_SZ;
    893          
    894            /* LED and Mode */
    895            iLed = *pBuf++;
    896            iMode = *pBuf;
    897          
    898            if ( iLed == 1 )
    899              Led = HAL_LED_1;
    900            else if ( iLed == 2 )
    901              Led = HAL_LED_2;
    902            else if ( iLed == 3 )
    903              Led = HAL_LED_3;
    904            else if ( iLed == 4 )
    905              Led = HAL_LED_4;
    906            else if ( iLed == 0xFF )
    907              Led = HAL_LED_ALL;
    908            else
    909              Led = 0;
    910            
    911            if ( iMode == 0 )
    912              Mode = HAL_LED_MODE_OFF;
    913            else if ( iMode == 1 )
    914              Mode = HAL_LED_MODE_ON;
    915            else if ( iMode == 2 )
    916              Mode = HAL_LED_MODE_BLINK;
    917            else if ( iMode == 3 )
    918              Mode = HAL_LED_MODE_FLASH;
    919            else if ( iMode == 4 )
    920              Mode = HAL_LED_MODE_TOGGLE;
    921            else
    922              Led = 0;
    923          
    924            if ( Led != 0 )
    925            {
    926              HalLedSet (Led, Mode);
    927              retValue = ZSuccess;
    928            }
    929            else
    930            {
    931              retValue = ZFailure;
    932            }
    933          
    934            /* Build and send back the response */
    935            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    936          }
    937          #endif /* HAL_LED */
    938          
    939          /***************************************************************************************************
    940           * @fn          MT_UtilSrcMatchEnable
    941           *
    942           * @brief      Enabled AUTOPEND and source address matching.
    943           *
    944           * @param      pBuf - Buffer contains the data
    945           *
    946           * @return     void
    947           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          void MT_UtilSrcMatchEnable (uint8 *pBuf)
   \                     MT_UtilSrcMatchEnable:
   \   000000   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
    949          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    950            uint8 retValue, cmdId;
    951          
    952            /* Parse header */
    953            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   000009   12....       LCALL   ?Subroutine24 & 0xFFFF
    954            pBuf += MT_RPC_FRAME_HDR_SZ;
    955          
    956          #ifdef AUTO_PEND
    957            /* Call the routine */
    958            retValue = ZMacSrcMatchEnable();
    959          #else
    960            retValue = ZMacUnsupported;
   \                     ??CrossCallReturnLabel_37:
   \   00000C   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    961          #endif
    962          
    963            /* Build and send back the response */
    964            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   \                     ??CrossCallReturnLabel_52:
   \   00000F                REQUIRE ??Subroutine32_0
   \   00000F                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   7967         MOV     R1,#0x67
   \   000002   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    965          
    966          }
   \   000005   7401         MOV     A,#0x1
   \   000007                REQUIRE ??Subroutine33_0
   \   000007                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   D083         POP     DPH
   \   000005   D082         POP     DPL
   \   000007   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   85..82       MOV     DPL,?XSP + 0
   \   00000B   85..83       MOV     DPH,?XSP + 1
   \   00000E   74F5         MOV     A,#-0xb
   \   000010   22           RET
    967          
    968          /***************************************************************************************************
    969           * @fn          MT_UtilSrcMatchAddEntry
    970           *
    971           * @brief       Add a short or extended address to source address table.
    972           *
    973           * @param       pBuf - Buffer contains the data
    974           *
    975           * @return      void
    976           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    977          void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
   \                     MT_UtilSrcMatchAddEntry:
   \   000000   02....       LJMP    ?Subroutine3 & 0xFFFF
    978          {
    979            uint8 retValue, cmdId;
    980          
    981            /* Parse header */
    982            cmdId = pBuf[MT_RPC_POS_CMD1];
    983            pBuf += MT_RPC_FRAME_HDR_SZ;
    984          
    985          #ifdef AUTO_PEND
    986            uint16 panID;
    987            zAddrType_t devAddr;
    988          
    989            /* Address mode */
    990            devAddr.addrMode = *pBuf++;
    991          
    992            /* Address based on the address mode */
    993            MT_UtilSpi2Addr( &devAddr, pBuf);
    994            pBuf += Z_EXTADDR_LEN;
    995          
    996            /* PanID */
    997            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
    998          
    999            /* Call the routine */
   1000            retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
   1001          #else
   1002            retValue = ZMacUnsupported;
   1003          #endif
   1004          
   1005            /* Build and send back the response */
   1006            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1007          }
   1008          
   1009          /***************************************************************************************************
   1010           * @fn          MT_UtilSrcMatchDeleteEntry
   1011           *
   1012           * @brief      Delete a short or extended address from source address table.
   1013           *
   1014           * @param      pBuf - Buffer contains the data
   1015           *
   1016           * @return     void
   1017           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1018          void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
   \                     MT_UtilSrcMatchDeleteEntry:
   \   000000   02....       LJMP    ?Subroutine3 & 0xFFFF
   1019          {
   1020            uint8 retValue, cmdId;
   1021          
   1022            /* Parse header */
   1023            cmdId = pBuf[MT_RPC_POS_CMD1];
   1024            pBuf += MT_RPC_FRAME_HDR_SZ;
   1025          
   1026          #ifdef AUTO_PEND
   1027            uint16 panID;
   1028            zAddrType_t devAddr;
   1029          
   1030            /* Address mode */
   1031            devAddr.addrMode = *pBuf++;
   1032          
   1033            /* Address based on the address mode */
   1034            MT_UtilSpi2Addr( &devAddr, pBuf);
   1035            pBuf += Z_EXTADDR_LEN;
   1036          
   1037            /* PanID */
   1038            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
   1039          
   1040            /* Call the routine */
   1041            retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
   1042          #else
   1043            retValue = ZMacUnsupported;
   1044          #endif
   1045          
   1046            /* Build and send back the response */
   1047            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1048          }
   1049          
   1050          /***************************************************************************************************
   1051           * @fn          MT_UtilSrcMatchCheckSrcAddr
   1052           *
   1053           * @brief      Check if a short or extended address is in the source address table.
   1054           *
   1055           * @param      pBuf - Buffer contains the data
   1056           *
   1057           * @return     void
   1058           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1059          void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
   \                     MT_UtilSrcMatchCheckSrcAddr:
   1060          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1061            uint8 cmdId;
   1062            uint8 retArray[2];
   1063          
   1064            /* Parse header */
   1065            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
   1066            pBuf += MT_RPC_FRAME_HDR_SZ;
   1067          
   1068          #if 0  /* Unsupported  */
   1069            uint16 panID;
   1070            zAddrType_t devAddr;
   1071          
   1072            /* Address mode */
   1073            devAddr.addrMode = *pBuf++;
   1074          
   1075            /* Address based on the address mode */
   1076            MT_UtilSpi2Addr( &devAddr, pBuf);
   1077            pBuf += Z_EXTADDR_LEN;
   1078          
   1079            /* PanID */
   1080            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
   1081          
   1082            /* Call the routine */
   1083            retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
   1084          
   1085              /* Return failure if the index is invalid */
   1086            if (retArray[1] == ZMacSrcMatchInvalidIndex )
   1087            {
   1088              retArray[0] = ZFailure;
   1089            }
   1090            else
   1091            {
   1092              retArray[0] = ZSuccess;
   1093            }
   1094          #else
   1095            retArray[0] = ZMacUnsupported;
   1096            retArray[1] = ZMacSrcMatchInvalidIndex;
   \                     ??CrossCallReturnLabel_8:
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   74FF         MOV     A,#-0x1
   \   000011                REQUIRE ?Subroutine5
   \   000011                ; // Fall through to label ?Subroutine5
   1097          #endif
   1098          
   1099            /* Build and send back the response */
   1100            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
   1101          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000003   7B02         MOV     R3,#0x2
   \   000005   7967         MOV     R1,#0x67
   \   000007   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   \   00000A   7402         MOV     A,#0x2
   \   00000C   02....       LJMP    ??Subroutine33_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   7401         MOV     A,#0x1
   \   000006   22           RET
   1102          
   1103          /***************************************************************************************************
   1104           * @fn          MT_UtilSrcMatchAckAllPending
   1105           *
   1106           * @brief       Enabled/disable acknowledging all packets with pending bit set
   1107           *              It is normally enabled when adding new entries to
   1108           *              the source address table fails due to the table is full, or
   1109           *              disabled when more entries are deleted and the table has
   1110           *              empty slots.
   1111           *
   1112           * @param       pBuf - Buffer contains the data
   1113           *
   1114           * @return      void
   1115           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1116          void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
   \                     MT_UtilSrcMatchAckAllPending:
   \   000000   02....       LJMP    ?Subroutine3 & 0xFFFF
   1117          {
   1118            uint8 retValue, cmdId;
   1119          
   1120            /* Parse header */
   1121            cmdId = pBuf[MT_RPC_POS_CMD1];
   1122            pBuf += MT_RPC_FRAME_HDR_SZ;
   1123          
   1124          #ifdef AUTO_PEND
   1125            /* Call the routine */
   1126            retValue = ZMacSrcMatchAckAllPending(*pBuf);
   1127          #else
   1128            retValue = ZMacUnsupported;
   1129          #endif
   1130          
   1131            /* Build and send back the response */
   1132            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1133          }
   1134          
   1135          /***************************************************************************************************
   1136           * @fn          MT_UtilSrcMatchCheckAllPending
   1137           *
   1138           * @brief       Check if acknowledging all packets with pending bit set
   1139           *              is enabled.
   1140           *
   1141           * @param       pBuf - Buffer contains the data
   1142           *
   1143           * @return      void
   1144           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1145          void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
   \                     MT_UtilSrcMatchCheckAllPending:
   1146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1147            uint8 retArray[2], cmdId;
   1148          
   1149            /* Parse header */
   1150            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
   1151            pBuf += MT_RPC_FRAME_HDR_SZ;
   1152          
   1153          #ifdef AUTO_PEND
   1154            /* Call the routine */
   1155            retArray[0] = ZMacSuccess;
   1156            retArray[1] = ZMacSrcMatchCheckAllPending();
   1157          #else
   1158            retArray[0] = ZMacUnsupported;
   1159            retArray[1] = FALSE;
   \                     ??CrossCallReturnLabel_9:
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E4           CLR     A
   \   000010   80..         SJMP    ?Subroutine5
   1160          #endif
   1161          
   1162            /* Build and send back the response */
   1163            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
   1164          }
   1165          
   1166          /***************************************************************************************************
   1167           * SUPPORT
   1168           ***************************************************************************************************/
   1169          
   1170          #ifdef AUTO_PEND
   1171          /***************************************************************************************************
   1172           * @fn      MT_UtilRevExtCpy
   1173           *
   1174           * @brief
   1175           *
   1176           *   Reverse-copy an extended address.
   1177           *
   1178           * @param   pDst - Pointer to data destination
   1179           * @param   pSrc - Pointer to data source
   1180           *
   1181           * @return  void
   1182           ***************************************************************************************************/
   1183          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
   1184          {
   1185            int8 i;
   1186          
   1187            for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
   1188            {
   1189              *pDst++ = pSrc[i];
   1190            }
   1191          }
   1192          
   1193          /***************************************************************************************************
   1194           * @fn      MT_UtilSpi2Addr
   1195           *
   1196           * @brief   Copy an address from an SPI message to an address struct.  The
   1197           *          addrMode in pAddr must already be set.
   1198           *
   1199           * @param   pDst - Pointer to address struct
   1200           * @param   pSrc - Pointer SPI message byte array
   1201           *
   1202           * @return  void
   1203           ***************************************************************************************************/
   1204          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
   1205          {
   1206            if ( pDst->addrMode == Addr16Bit )
   1207            {
   1208              pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
   1209            }
   1210            else if ( pDst->addrMode == Addr64Bit )
   1211            {
   1212              MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
   1213            }
   1214          }
   1215          #endif // AUTO_PEND
   1216          
   1217          /***************************************************************************************************
   1218           * @fn      MT_UtilGpioRead
   1219           *
   1220           * @brief   Read values of all GPIOs (P0_0 -P2_4)
   1221           *
   1222           * @param   void
   1223           *
   1224           * @return  P0, P1, P2, P0DIR, P1DIR, P2DIR
   1225           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1226          void MT_UtilGpioRead(uint8 *pBuf)
   \                     MT_UtilGpioRead:
   1227          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 6
   \   000004   74FA         MOV     A,#-0x6
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1228          #if defined ( HAL_MCU_CC2530 )
   1229            uint8 rtrn[6] = {P0, P1, P2, P0DIR, P1DIR, P2DIR};
   \   000009   E580         MOV     A,0x80
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   E590         MOV     A,0x90
   \   000014   C0E0         PUSH    A
   \   000016   7401         MOV     A,#0x1
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   D0E0         POP     A
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E5A0         MOV     A,0xa0
   \   000020   C0E0         PUSH    A
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   D0E0         POP     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   E5FD         MOV     A,0xfd
   \   00002C   C0E0         PUSH    A
   \   00002E   7403         MOV     A,#0x3
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   D0E0         POP     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   E5FE         MOV     A,0xfe
   \   000038   C0E0         PUSH    A
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   D0E0         POP     A
   \   000041   F0           MOVX    @DPTR,A
   \   000042   E5FF         MOV     A,0xff
   \   000044   C0E0         PUSH    A
   \   000046   7405         MOV     A,#0x5
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   D0E0         POP     A
   \   00004D   12....       LCALL   ?Subroutine18 & 0xFFFF
   1230          #else
   1231            uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
   1232          #endif
   1233            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_READ,
   1234              6, rtrn);
   \                     ??CrossCallReturnLabel_25:
   \   000050   7B06         MOV     R3,#0x6
   \   000052   7A15         MOV     R2,#0x15
   \   000054   7967         MOV     R1,#0x67
   \   000056   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1235          }
   \   000059   7406         MOV     A,#0x6
   \   00005B   02....       LJMP    ??Subroutine33_0 & 0xFFFF
   \   00005E                REQUIRE _A_P0
   \   00005E                REQUIRE _A_P1
   \   00005E                REQUIRE _A_P2
   \   00005E                REQUIRE P0DIR
   \   00005E                REQUIRE P1DIR
   \   00005E                REQUIRE P2DIR
   1236          
   1237          /***************************************************************************************************
   1238           * @fn      MT_UtilGpioSetDirection
   1239           *
   1240           * @brief   Set the direction of a specific GPIO (P0_0 -P2_4)
   1241           *
   1242           * @param   port - 0, 1 or 2
   1243           * @param   bit - 0 - 7
   1244           * @param   direction - 0 for input, 1 for output
   1245           *
   1246           * @return  oldP0DIR, oldP1DIR, oldP2DIR, newP0DIR, newP1DIR, newP2DIR
   1247           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1248          void MT_UtilGpioSetDirection(uint8 *pBuf)
   \                     MT_UtilGpioSetDirection:
   1249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1250          #if defined ( HAL_MCU_CC2530 )
   1251            uint8 rtrn[6] = {P0DIR, P1DIR, P2DIR, 0, 0, 0};
   \   00000A   90....       MOV     DPTR,#`?<Constant {0, 0, 0, 0, 0, 0}>`
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   7406         MOV     A,#0x6
   \   000013   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000016   E5FD         MOV     A,0xfd
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   E5FE         MOV     A,0xfe
   \   000021   C0E0         PUSH    A
   \   000023   7401         MOV     A,#0x1
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   D0E0         POP     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   E5FF         MOV     A,0xff
   \   00002D   C0E0         PUSH    A
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   D0E0         POP     A
   \   000036   12....       LCALL   ?Subroutine8 & 0xFFFF
   1252            uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
   1253            uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
   1254            uint8 direction = pBuf[MT_RPC_POS_DAT0 + 2];
   1255            
   1256            if (direction == 0)
   \                     ??CrossCallReturnLabel_4:
   \   000039   7044         JNZ     ??MT_UtilGpioSetDirection_0
   1257            {
   1258              switch (port)
   \   00003B   E9           MOV     A,R1
   \   00003C   6008         JZ      ??MT_UtilGpioSetDirection_1
   \   00003E   14           DEC     A
   \   00003F   6018         JZ      ??MT_UtilGpioSetDirection_2
   \   000041   14           DEC     A
   \   000042   6028         JZ      ??MT_UtilGpioSetDirection_3
   \   000044   8078         SJMP    ??MT_UtilGpioSetDirection_4
   1259              {
   1260                case 0:
   1261                  P0DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_1:
   \   000046   75..01       MOV     ?V0,#0x1
   \   000049   75..00       MOV     ?V1,#0x0
   \   00004C   E8           MOV     A,R0
   \   00004D   78..         MOV     R0,#?V0
   \   00004F   12....       LCALL   ?S_SHL
   \   000052   E5..         MOV     A,?V0
   \   000054   F4           CPL     A
   \   000055   52FD         ANL     0xfd,A
   1262                  break;
   \   000057   8065         SJMP    ??MT_UtilGpioSetDirection_4
   1263                case 1:
   1264                  P1DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_2:
   \   000059   75..01       MOV     ?V0,#0x1
   \   00005C   75..00       MOV     ?V1,#0x0
   \   00005F   E8           MOV     A,R0
   \   000060   78..         MOV     R0,#?V0
   \   000062   12....       LCALL   ?S_SHL
   \   000065   E5..         MOV     A,?V0
   \   000067   F4           CPL     A
   \   000068   52FE         ANL     0xfe,A
   1265                  break;
   \   00006A   8052         SJMP    ??MT_UtilGpioSetDirection_4
   1266                case 2:
   1267                  P2DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_3:
   \   00006C   75..01       MOV     ?V0,#0x1
   \   00006F   75..00       MOV     ?V1,#0x0
   \   000072   E8           MOV     A,R0
   \   000073   78..         MOV     R0,#?V0
   \   000075   12....       LCALL   ?S_SHL
   \   000078   E5..         MOV     A,?V0
   \   00007A   F4           CPL     A
   \   00007B   52FF         ANL     0xff,A
   1268                  break;
   \   00007D   803F         SJMP    ??MT_UtilGpioSetDirection_4
   1269              }
   1270            }
   1271            else
   1272            {
   1273              switch (port)
   \                     ??MT_UtilGpioSetDirection_0:
   \   00007F   E9           MOV     A,R1
   \   000080   6008         JZ      ??MT_UtilGpioSetDirection_5
   \   000082   14           DEC     A
   \   000083   6017         JZ      ??MT_UtilGpioSetDirection_6
   \   000085   14           DEC     A
   \   000086   6026         JZ      ??MT_UtilGpioSetDirection_7
   \   000088   8034         SJMP    ??MT_UtilGpioSetDirection_4
   1274              {
   1275                case 0:
   1276                  P0DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_5:
   \   00008A   75..01       MOV     ?V0,#0x1
   \   00008D   75..00       MOV     ?V1,#0x0
   \   000090   E8           MOV     A,R0
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?S_SHL
   \   000096   E5..         MOV     A,?V0
   \   000098   42FD         ORL     0xfd,A
   1277                  break;
   \   00009A   8022         SJMP    ??MT_UtilGpioSetDirection_4
   1278                case 1:
   1279                  P1DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_6:
   \   00009C   75..01       MOV     ?V0,#0x1
   \   00009F   75..00       MOV     ?V1,#0x0
   \   0000A2   E8           MOV     A,R0
   \   0000A3   78..         MOV     R0,#?V0
   \   0000A5   12....       LCALL   ?S_SHL
   \   0000A8   E5..         MOV     A,?V0
   \   0000AA   42FE         ORL     0xfe,A
   1280                  break;
   \   0000AC   8010         SJMP    ??MT_UtilGpioSetDirection_4
   1281                case 2:
   1282                  P2DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_7:
   \   0000AE   75..01       MOV     ?V0,#0x1
   \   0000B1   75..00       MOV     ?V1,#0x0
   \   0000B4   E8           MOV     A,R0
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?S_SHL
   \   0000BA   E5..         MOV     A,?V0
   \   0000BC   42FF         ORL     0xff,A
   1283                  break;
   1284              }
   1285            }
   1286            
   1287            rtrn[3] = P0DIR;
   \                     ??MT_UtilGpioSetDirection_4:
   \   0000BE   E5FD         MOV     A,0xfd
   \   0000C0   C0E0         PUSH    A
   \   0000C2   7403         MOV     A,#0x3
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   D0E0         POP     A
   \   0000C9   F0           MOVX    @DPTR,A
   1288            rtrn[4] = P1DIR;
   \   0000CA   E5FE         MOV     A,0xfe
   \   0000CC   C0E0         PUSH    A
   \   0000CE   7404         MOV     A,#0x4
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   D0E0         POP     A
   \   0000D5   F0           MOVX    @DPTR,A
   1289            rtrn[5] = P2DIR;
   \   0000D6   E5FF         MOV     A,0xff
   \   0000D8   C0E0         PUSH    A
   \   0000DA   7405         MOV     A,#0x5
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   D0E0         POP     A
   \   0000E1   12....       LCALL   ?Subroutine18 & 0xFFFF
   1290          #else
   1291            uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
   1292          #endif
   1293            
   1294            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_SET_DIRECTION,
   1295              6, rtrn);
   \                     ??CrossCallReturnLabel_26:
   \   0000E4   7B06         MOV     R3,#0x6
   \   0000E6   7A14         MOV     R2,#0x14
   \   0000E8   7967         MOV     R1,#0x67
   \   0000EA   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1296          }
   \   0000ED   7406         MOV     A,#0x6
   \   0000EF                REQUIRE ?Subroutine4
   \   0000EF                REQUIRE P0DIR
   \   0000EF                REQUIRE P1DIR
   \   0000EF                REQUIRE P2DIR
   \   0000EF                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   1297          
   1298          /***************************************************************************************************
   1299           * @fn      MT_UtilGpioWrite
   1300           *
   1301           * @brief   Write value of a specific GPIO (P0_0 -P2_4)
   1302           *
   1303           * @param   port - 0, 1 or 2
   1304           * @param   bit - 0 - 7
   1305           * @param   value - 0 or 1
   1306           *
   1307           * @return  oldP0, oldP1, oldP2, newP0, newP1, newP2, P0DIR, P1DIR, P2DIR
   1308           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1309          void MT_UtilGpioWrite(uint8 *pBuf)
   \                     MT_UtilGpioWrite:
   1310          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1311          #if defined ( HAL_MCU_CC2530 )
   1312            uint8 rtrn[9] = {P0, P1, P2, 0, 0, 0, P0DIR, P1DIR, P2DIR};
   \   00000A   90....       MOV     DPTR,#`?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>`
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   7409         MOV     A,#0x9
   \   000013   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000016   E580         MOV     A,0x80
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   E590         MOV     A,0x90
   \   000021   C0E0         PUSH    A
   \   000023   7401         MOV     A,#0x1
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   D0E0         POP     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   E5A0         MOV     A,0xa0
   \   00002D   C0E0         PUSH    A
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   D0E0         POP     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   E5FD         MOV     A,0xfd
   \   000039   C0E0         PUSH    A
   \   00003B   7406         MOV     A,#0x6
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   D0E0         POP     A
   \   000042   F0           MOVX    @DPTR,A
   \   000043   E5FE         MOV     A,0xfe
   \   000045   C0E0         PUSH    A
   \   000047   7407         MOV     A,#0x7
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   D0E0         POP     A
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   E5FF         MOV     A,0xff
   \   000051   C0E0         PUSH    A
   \   000053   7408         MOV     A,#0x8
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   D0E0         POP     A
   \   00005A   12....       LCALL   ?Subroutine8 & 0xFFFF
   1313            uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
   1314            uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
   1315            uint8 value = pBuf[MT_RPC_POS_DAT0 + 2];
   1316            
   1317            if (value == 0)
   \                     ??CrossCallReturnLabel_5:
   \   00005D   7044         JNZ     ??MT_UtilGpioWrite_0
   1318            {
   1319              switch (port)
   \   00005F   E9           MOV     A,R1
   \   000060   6008         JZ      ??MT_UtilGpioWrite_1
   \   000062   14           DEC     A
   \   000063   6018         JZ      ??MT_UtilGpioWrite_2
   \   000065   14           DEC     A
   \   000066   6028         JZ      ??MT_UtilGpioWrite_3
   \   000068   8078         SJMP    ??MT_UtilGpioWrite_4
   1320              {
   1321                case 0:
   1322                  P0 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_1:
   \   00006A   75..01       MOV     ?V0,#0x1
   \   00006D   75..00       MOV     ?V1,#0x0
   \   000070   E8           MOV     A,R0
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?S_SHL
   \   000076   E5..         MOV     A,?V0
   \   000078   F4           CPL     A
   \   000079   5280         ANL     0x80,A
   1323                  break;
   \   00007B   8065         SJMP    ??MT_UtilGpioWrite_4
   1324                case 1:
   1325                  P1 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_2:
   \   00007D   75..01       MOV     ?V0,#0x1
   \   000080   75..00       MOV     ?V1,#0x0
   \   000083   E8           MOV     A,R0
   \   000084   78..         MOV     R0,#?V0
   \   000086   12....       LCALL   ?S_SHL
   \   000089   E5..         MOV     A,?V0
   \   00008B   F4           CPL     A
   \   00008C   5290         ANL     0x90,A
   1326                  break;
   \   00008E   8052         SJMP    ??MT_UtilGpioWrite_4
   1327                case 2:
   1328                  P2 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_3:
   \   000090   75..01       MOV     ?V0,#0x1
   \   000093   75..00       MOV     ?V1,#0x0
   \   000096   E8           MOV     A,R0
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?S_SHL
   \   00009C   E5..         MOV     A,?V0
   \   00009E   F4           CPL     A
   \   00009F   52A0         ANL     0xa0,A
   1329                  break;
   \   0000A1   803F         SJMP    ??MT_UtilGpioWrite_4
   1330              }
   1331            }
   1332            else
   1333            {
   1334              switch (port)
   \                     ??MT_UtilGpioWrite_0:
   \   0000A3   E9           MOV     A,R1
   \   0000A4   6008         JZ      ??MT_UtilGpioWrite_5
   \   0000A6   14           DEC     A
   \   0000A7   6017         JZ      ??MT_UtilGpioWrite_6
   \   0000A9   14           DEC     A
   \   0000AA   6026         JZ      ??MT_UtilGpioWrite_7
   \   0000AC   8034         SJMP    ??MT_UtilGpioWrite_4
   1335              {
   1336                case 0:
   1337                  P0 |= BV(bit);
   \                     ??MT_UtilGpioWrite_5:
   \   0000AE   75..01       MOV     ?V0,#0x1
   \   0000B1   75..00       MOV     ?V1,#0x0
   \   0000B4   E8           MOV     A,R0
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?S_SHL
   \   0000BA   E5..         MOV     A,?V0
   \   0000BC   4280         ORL     0x80,A
   1338                  break;
   \   0000BE   8022         SJMP    ??MT_UtilGpioWrite_4
   1339                case 1:
   1340                  P1 |= BV(bit);
   \                     ??MT_UtilGpioWrite_6:
   \   0000C0   75..01       MOV     ?V0,#0x1
   \   0000C3   75..00       MOV     ?V1,#0x0
   \   0000C6   E8           MOV     A,R0
   \   0000C7   78..         MOV     R0,#?V0
   \   0000C9   12....       LCALL   ?S_SHL
   \   0000CC   E5..         MOV     A,?V0
   \   0000CE   4290         ORL     0x90,A
   1341                  break;
   \   0000D0   8010         SJMP    ??MT_UtilGpioWrite_4
   1342                case 2:
   1343                  P2 |= BV(bit);
   \                     ??MT_UtilGpioWrite_7:
   \   0000D2   75..01       MOV     ?V0,#0x1
   \   0000D5   75..00       MOV     ?V1,#0x0
   \   0000D8   E8           MOV     A,R0
   \   0000D9   78..         MOV     R0,#?V0
   \   0000DB   12....       LCALL   ?S_SHL
   \   0000DE   E5..         MOV     A,?V0
   \   0000E0   42A0         ORL     0xa0,A
   1344                  break;
   1345              }
   1346            }
   1347            
   1348            rtrn[3] = P0;
   \                     ??MT_UtilGpioWrite_4:
   \   0000E2   E580         MOV     A,0x80
   \   0000E4   C0E0         PUSH    A
   \   0000E6   7403         MOV     A,#0x3
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   D0E0         POP     A
   \   0000ED   F0           MOVX    @DPTR,A
   1349            rtrn[4] = P1;
   \   0000EE   E590         MOV     A,0x90
   \   0000F0   C0E0         PUSH    A
   \   0000F2   7404         MOV     A,#0x4
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   D0E0         POP     A
   \   0000F9   F0           MOVX    @DPTR,A
   1350            rtrn[5] = P2;
   \   0000FA   E5A0         MOV     A,0xa0
   \   0000FC   C0E0         PUSH    A
   \   0000FE   7405         MOV     A,#0x5
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   D0E0         POP     A
   \   000105   12....       LCALL   ?Subroutine18 & 0xFFFF
   1351           
   1352          #else
   1353            uint8 rtrn[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
   1354          #endif
   1355          
   1356            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_WRITE,
   1357              9, rtrn);
   \                     ??CrossCallReturnLabel_27:
   \   000108   7B09         MOV     R3,#0x9
   \   00010A   7A16         MOV     R2,#0x16
   \   00010C   7967         MOV     R1,#0x67
   \   00010E   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1358          }
   \   000111   7409         MOV     A,#0x9
   \   000113   02....       LJMP    ?Subroutine4 & 0xFFFF
   \   000116                REQUIRE _A_P0
   \   000116                REQUIRE _A_P1
   \   000116                REQUIRE _A_P2
   \   000116                REQUIRE P0DIR
   \   000116                REQUIRE P1DIR
   \   000116                REQUIRE P2DIR

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   00           DB 0
   1359          
   1360          #if !defined NONWK
   1361          /**************************************************************************************************
   1362           * @fn      MT_UtilDataReq
   1363           *
   1364           * @brief   Process the MAC Data Request command.
   1365           *
   1366           * @param   pBuf - pointer to the received data
   1367           *
   1368           * @return  None
   1369          **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1370          void MT_UtilDataReq(uint8 *pBuf)
   \                     MT_UtilDataReq:
   1371          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1372            uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
   \   000009                ; Setup parameters for call to function NwkPollReq
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   12....       LCALL   `??NwkPollReq::?relay`; Banked call to: NwkPollReq
   \   000015   12....       LCALL   ?Subroutine17 & 0xFFFF
   1373            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
   1374                                                                                         1, &rtrn);
   \                     ??CrossCallReturnLabel_51:
   \   000018   7A11         MOV     R2,#0x11
   \   00001A   80..         SJMP    ??Subroutine32_0
   1375          }
   1376          
   1377          /***************************************************************************************************
   1378           * @fn      MT_UtilAddrMgrEntryLookupExt
   1379           *
   1380           * @brief   Proxy the AddrMgrEntryLookupExt() function.
   1381           *
   1382           * @param   pBuf - pointer to the received buffer
   1383           *
   1384           * @return  void
   1385           ***************************************************************************************************/
   1386          static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf)
   1387          {
   1388            uint8 nwkAddr[2];
   1389            AddrMgrEntry_t entry;
   1390            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1391            pBuf += MT_RPC_FRAME_HDR_SZ;
   1392          
   1393            osal_memcpy(entry.extAddr, pBuf, Z_EXTADDR_LEN);
   1394            (void)AddrMgrEntryLookupExt(&entry);
   1395          
   1396            nwkAddr[0] = LO_UINT16(entry.nwkAddr);
   1397            nwkAddr[1] = HI_UINT16(entry.nwkAddr);
   1398            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
   1399                                                 cmdId, sizeof(uint16), nwkAddr);
   1400          }
   1401          
   1402          /***************************************************************************************************
   1403           * @fn      MT_UtilAddrMgrEntryLookupNwk
   1404           *
   1405           * @brief   Proxy the AddrMgrEntryLookupNwk() function.
   1406           *
   1407           * @param   pBuf - pointer to the received buffer
   1408           *
   1409           * @return  void
   1410           ***************************************************************************************************/
   1411          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
   1412          {
   1413            AddrMgrEntry_t entry;
   1414            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1415            pBuf += MT_RPC_FRAME_HDR_SZ;
   1416          
   1417            entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
   1418            (void)AddrMgrEntryLookupNwk(&entry);
   1419          
   1420            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
   1421                                                 cmdId, Z_EXTADDR_LEN, entry.extAddr);
   1422          }
   1423          
   1424          #if defined MT_SYS_KEY_MANAGEMENT
   1425          /***************************************************************************************************
   1426           * @fn      MT_UtilAPSME_LinkKeyDataGet
   1427           *
   1428           * @brief   Retrieves APS Link Key data from NV.
   1429           *
   1430           * @param   pBuf - pointer to the received buffer
   1431           *
   1432           * @return  void
   1433           ***************************************************************************************************/
   1434          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
   1435          {
   1436            uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
   1437            APSME_LinkKeyData_t *pData = NULL;
   1438            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1439            uint16 apsLinkKeyNvId;
   1440            uint32 *apsRxFrmCntr;
   1441            uint32 *apsTxFrmCntr;
   1442          
   1443            pBuf += MT_RPC_FRAME_HDR_SZ;
   1444          
   1445            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1446          
   1447            if (SUCCESS == *rsp)
   1448            {
   1449              pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   1450          
   1451              if (pData != NULL)
   1452              {
   1453                // retrieve key from NV
   1454                if ( osal_nv_read( apsLinkKeyNvId, 0,
   1455                                  sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
   1456          
   1457                {
   1458                  uint8 *ptr = rsp+1;
   1459                  apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
   1460                  apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
   1461          
   1462                  (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
   1463                  ptr += SEC_KEY_LEN;
   1464                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
   1465                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
   1466                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
   1467                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
   1468                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
   1469                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
   1470                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
   1471                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
   1472                }
   1473          
   1474                // clear copy of key in RAM
   1475                osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
   1476          
   1477                osal_mem_free(pData);
   1478              }
   1479            }
   1480            else
   1481            {
   1482              // set data key and counters 0xFF
   1483              osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
   1484            }
   1485          
   1486            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1487                                                 MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
   1488          
   1489            // clear key data
   1490            osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
   1491          
   1492          }
   1493          
   1494          /***************************************************************************************************
   1495           * @fn      MT_UtilAPSME_LinkKeyNvIdGet
   1496           *
   1497           * @brief   Retrieves APS Link Key NV ID from the entry table.
   1498           *
   1499           * @param   pBuf - pointer to the received buffer
   1500           *
   1501           * @return  void
   1502           ***************************************************************************************************/
   1503          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
   1504          {
   1505            uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
   1506            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1507            uint16 apsLinkKeyNvId;
   1508          
   1509            pBuf += MT_RPC_FRAME_HDR_SZ;
   1510          
   1511            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1512          
   1513            if (SUCCESS == *rsp)
   1514            {
   1515              rsp[1] = LO_UINT16(apsLinkKeyNvId);
   1516              rsp[2] = HI_UINT16(apsLinkKeyNvId);
   1517            }
   1518            else
   1519            {
   1520              // send failure response with invalid NV ID
   1521              osal_memset(&rsp[1], 0xFF, 2);
   1522            }
   1523          
   1524            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1525                                                 MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
   1526          }
   1527          #endif // MT_SYS_KEY_MANAGEMENT
   1528          
   1529          /***************************************************************************************************
   1530           * @fn      MT_UtilAPSME_RequestKeyCmd
   1531           *
   1532           * @brief   Send RequestKey command message to TC for a specific partner Address.
   1533           *
   1534           * @param   pBuf  - pointer to the received buffer
   1535           *
   1536           * @return  void
   1537           ***************************************************************************************************/
   1538          void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
   1539          {
   1540            uint8 cmdId;
   1541            uint8 partnerAddr[Z_EXTADDR_LEN];
   1542            uint8 retValue;
   1543          
   1544            // parse header
   1545            cmdId = pBuf[MT_RPC_POS_CMD1];
   1546            pBuf += MT_RPC_FRAME_HDR_SZ;
   1547          
   1548            /* PartnerAddress */
   1549            osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
   1550          
   1551            retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
   1552          
   1553            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
   1554          }
   1555          
   1556          /***************************************************************************************************
   1557           * @fn      MT_UtilAssocCount
   1558           *
   1559           * @brief   Proxy the AssocCount() function.
   1560           *
   1561           * @param   pBuf - pointer to the received buffer
   1562           *
   1563           * @return  void
   1564           ***************************************************************************************************/
   1565          static void MT_UtilAssocCount(uint8 *pBuf)
   1566          {
   1567            uint16 cnt;
   1568            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1569            pBuf += MT_RPC_FRAME_HDR_SZ;
   1570          
   1571            cnt = AssocCount(pBuf[0], pBuf[1]);
   1572            pBuf[0] = LO_UINT16(cnt);
   1573            pBuf[1] = HI_UINT16(cnt);
   1574          
   1575            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
   1576          }
   1577          
   1578          /***************************************************************************************************
   1579           * @fn      MT_UtilAssocFindDevice
   1580           *
   1581           * @brief   Get an associated device by index.
   1582           *
   1583           * @param   pBuf - pointer to the received buffer
   1584           *
   1585           * @return  void
   1586           ***************************************************************************************************/
   1587          static void MT_UtilAssocFindDevice(uint8 *pBuf)
   1588          {
   1589            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1590            uint8 buf[sizeof(associated_devices_t)];
   1591          
   1592            packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
   1593            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1594                                                 sizeof(associated_devices_t), buf);
   1595          }
   1596          
   1597          /***************************************************************************************************
   1598           * @fn      MT_UtilAssocGetWithAddress
   1599           *
   1600           * @brief   Get an associated device by address.
   1601           *
   1602           * @param   pBuf - pointer to the received buffer
   1603           *
   1604           * @return  void
   1605           ***************************************************************************************************/
   1606          static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
   1607          {
   1608            extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
   1609            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1610            uint8 buf[sizeof(associated_devices_t)];
   1611          
   1612            pBuf += MT_RPC_FRAME_HDR_SZ;
   1613            packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
   1614                                            BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
   1615          
   1616            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1617                                                 sizeof(associated_devices_t), buf);
   1618          }
   1619          
   1620          /***************************************************************************************************
   1621           * @fn      MT_UtilBindAddEntry
   1622           *
   1623           * @brief   Add Binding Entry into Local Table.
   1624           *
   1625           * @param   pBuf - pointer to the received buffer
   1626           *
   1627           * @return  void
   1628           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1629          static void MT_UtilBindAddEntry(uint8 *pBuf)
   \                     MT_UtilBindAddEntry:
   1630          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1631            uint8 srcEp;
   1632            zAddrType_t dstAddr;
   1633            uint8 dstEp;
   1634            uint8 numClusterIds;
   1635            uint16 *clusterIds;
   1636            uint8 buf[sizeof(BindingEntry_t)];
   1637            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V7,A
   1638            pBuf += MT_RPC_FRAME_HDR_SZ;
   1639          
   1640            // Initialize the return buffer
   1641            osal_memset( buf, 0xFF, sizeof(BindingEntry_t) );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C0E         MOV     R4,#0xe
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   79FF         MOV     R1,#-0x1
   \   00001D   7409         MOV     A,#0x9
   \   00001F   12....       LCALL   ?XSTACK_DISP101_8
   \   000022   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   1642            buf[2] = 0xFE;    // set the default value of INVALID_NODE_ADDR
   \   000025   740B         MOV     A,#0xb
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   74FE         MOV     A,#-0x2
   \   00002C   F0           MOVX    @DPTR,A
   1643            buf[3] = 0xFF;    // set the default value of INVALID_NODE_ADDR
   \   00002D   740C         MOV     A,#0xc
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   74FF         MOV     A,#-0x1
   \   000034   F0           MOVX    @DPTR,A
   1644          
   1645            srcEp = *pBuf++;
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V4,A
   1646          
   1647            // Destination Address mode
   1648            dstAddr.addrMode = *pBuf++;
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F8           MOV     R0,A
   \   000049   7408         MOV     A,#0x8
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   E8           MOV     A,R0
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   EE           MOV     A,R6
   \   000051   2405         ADD     A,#0x5
   \   000053   FE           MOV     R6,A
   \   000054   5001         JNC     ??MT_UtilBindAddEntry_0
   \   000056   0F           INC     R7
   1649          
   1650            // Destination Address
   1651            if ( dstAddr.addrMode == Addr64Bit )
   \                     ??MT_UtilBindAddEntry_0:
   \   000057   7403         MOV     A,#0x3
   \   000059   68           XRL     A,R0
   \   00005A   700D         JNZ     ??MT_UtilBindAddEntry_1
   1652            {
   1653              uint8 *ptr; // Use this additional pointer because *pBuf is incremented later for both cases
   1654          
   1655              ptr = pBuf;
   1656              osal_cpyExtAddr( dstAddr.addr.extAddr, ptr );
   \   00005C                ; Setup parameters for call to function sAddrExtCpy
   \   00005C   EE           MOV     A,R6
   \   00005D   FC           MOV     R4,A
   \   00005E   EF           MOV     A,R7
   \   00005F   FD           MOV     R5,A
   \   000060   AA..         MOV     R2,?XSP + 0
   \   000062   AB..         MOV     R3,?XSP + 1
   \   000064   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   \   000067   8014         SJMP    ??MT_UtilBindAddEntry_2
   1657            }
   1658            else
   1659            {
   1660              dstAddr.addr.shortAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??MT_UtilBindAddEntry_1:
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F9           MOV     R1,A
   \   000072   EA           MOV     A,R2
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   E9           MOV     A,R1
   \   00007C   F0           MOVX    @DPTR,A
   1661            }
   1662            // The short address occupies LSB two bytes
   1663            pBuf += Z_EXTADDR_LEN;
   1664          
   1665            // DstEPInt
   1666            dstEp = *pBuf++;
   \                     ??MT_UtilBindAddEntry_2:
   \   00007D   8E82         MOV     DPL,R6
   \   00007F   8F83         MOV     DPH,R7
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F5..         MOV     ?V5,A
   1667          
   1668            numClusterIds = *pBuf++;
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F5..         MOV     ?V6,A
   1669          
   1670            if ( numClusterIds > 0 )
   \   00009C   6064         JZ      ??MT_UtilBindAddEntry_3
   1671            {
   1672              // copy list of clusters
   1673              clusterIds = (uint16 *)osal_mem_alloc( numClusterIds * sizeof(uint16) );
   \   00009E   25E0         ADD     A,0xE0 /* A   */
   \   0000A0   F5..         MOV     ?V2,A
   \   0000A2   E4           CLR     A
   \   0000A3   33           RLC     A
   \   0000A4   F5..         MOV     ?V3,A
   \   0000A6                ; Setup parameters for call to function osal_mem_alloc
   \   0000A6   AA..         MOV     R2,?V2
   \   0000A8   FB           MOV     R3,A
   \   0000A9   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000AC   8A..         MOV     ?V0,R2
   \   0000AE   8B..         MOV     ?V1,R3
   1674              osal_memcpy( clusterIds, pBuf, numClusterIds * sizeof(uint16));
   \   0000B0                ; Setup parameters for call to function osal_memcpy
   \   0000B0   EE           MOV     A,R6
   \   0000B1   240A         ADD     A,#0xa
   \   0000B3   F5..         MOV     ?V8,A
   \   0000B5   E4           CLR     A
   \   0000B6   3F           ADDC    A,R7
   \   0000B7   F5..         MOV     ?V9,A
   \   0000B9   75..00       MOV     ?V10,#0x0
   \   0000BC   78..         MOV     R0,#?V8
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000C1   AC..         MOV     R4,?V2
   \   0000C3   AD..         MOV     R5,?V3
   \   0000C5   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000C8   7403         MOV     A,#0x3
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   1675          
   1676              if ( clusterIds != NULL )
   \   0000CD   E5..         MOV     A,?V0
   \   0000CF   45..         ORL     A,?V1
   \   0000D1   602F         JZ      ??MT_UtilBindAddEntry_3
   1677              {
   1678                // The response to MT interface has to be pack into buf
   1679                packBindEntry_t( buf, bindAddEntry( srcEp, &dstAddr, dstEp, numClusterIds, clusterIds ));
   \   0000D3                ; Setup parameters for call to function bindAddEntry
   \   0000D3   78..         MOV     R0,#?V0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D8   AD..         MOV     R5,?V6
   \   0000DA   AC..         MOV     R4,?V5
   \   0000DC   7402         MOV     A,#0x2
   \   0000DE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000E1   A9..         MOV     R1,?V4
   \   0000E3   12....       LCALL   `??bindAddEntry::?relay`; Banked call to: bindAddEntry
   \   0000E6   7402         MOV     A,#0x2
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EB   8A..         MOV     ?V2,R2
   \   0000ED   8B..         MOV     ?V3,R3
   \   0000EF   AC..         MOV     R4,?V2
   \   0000F1   AD..         MOV     R5,?V3
   \   0000F3                ; Setup parameters for call to function packBindEntry_t
   \   0000F3   7409         MOV     A,#0x9
   \   0000F5   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F8   12....       LCALL   `??packBindEntry_t::?relay`; Banked call to: packBindEntry_t
   1680          
   1681                osal_mem_free( clusterIds );
   \   0000FB                ; Setup parameters for call to function osal_mem_free
   \   0000FB   AA..         MOV     R2,?V0
   \   0000FD   AB..         MOV     R3,?V1
   \   0000FF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   1682              }
   1683            }
   1684          
   1685            MT_BuildAndSendZToolResponse( ( (uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL ),
   1686                                          cmdId, sizeof(BindingEntry_t), buf );
   \                     ??MT_UtilBindAddEntry_3:
   \   000102                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000102   7409         MOV     A,#0x9
   \   000104   12....       LCALL   ?XSTACK_DISP102_8
   \   000107   7B0E         MOV     R3,#0xe
   \   000109   AA..         MOV     R2,?V7
   \   00010B   7967         MOV     R1,#0x67
   \   00010D   12....       LCALL   `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1687          }
   \   000110   7417         MOV     A,#0x17
   \   000112   12....       LCALL   ?DEALLOC_XSTACK8
   \   000115   7F0B         MOV     R7,#0xb
   \   000117   02....       LJMP    ?BANKED_LEAVE_XDATA
   1688          
   1689          /***************************************************************************************************
   1690           * @fn      packDev_t
   1691           *
   1692           * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
   1693           *          the pDev parameter is NULL).
   1694           *
   1695           * @param   pBuf - pointer to the buffer into which to pack the structure.
   1696           * @param   pDev - pointer to the structure.
   1697           *
   1698           * @return  void
   1699           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1700          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
   \                     packDev_t:
   1701          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1702            if (NULL == pDev)
   \   000005   EC           MOV     A,R4
   \   000006   4D           ORL     A,R5
   \   000007   7010         JNZ     ??packDev_t_0
   1703            {
   1704              uint16 rtrn = INVALID_NODE_ADDR;
   1705              *pBuf++ = LO_UINT16(rtrn);
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   74FE         MOV     A,#-0x2
   \   00000F   F0           MOVX    @DPTR,A
   1706              *pBuf++ = HI_UINT16(rtrn);
   \   000010   A3           INC     DPTR
   \   000011   04           INC     A
   \   000012   F0           MOVX    @DPTR,A
   \   000013   EA           MOV     A,R2
   \   000014   2402         ADD     A,#0x2
   \   000016   02....       LJMP    ??packDev_t_1 & 0xFFFF
   1707            }
   1708            else
   1709            {
   1710              *pBuf++ = LO_UINT16(pDev->shortAddr);
   \                     ??packDev_t_0:
   \   000019   12....       LCALL   ?Subroutine6 & 0xFFFF
   1711              *pBuf++ = HI_UINT16(pDev->shortAddr);
   1712              *pBuf++ = LO_UINT16(pDev->addrIdx);
   1713              *pBuf++ = HI_UINT16(pDev->addrIdx);
   1714              *pBuf++ = pDev->nodeRelation;
   1715              *pBuf++ = pDev->devStatus;
   \                     ??CrossCallReturnLabel_0:
   \   00001C   8C82         MOV     DPL,R4
   \   00001E   8D83         MOV     DPH,R5
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   12....       LCALL   ?Subroutine12 & 0xFFFF
   1716              *pBuf++ = pDev->assocCnt;
   \                     ??CrossCallReturnLabel_12:
   \   000028   8C82         MOV     DPL,R4
   \   00002A   8D83         MOV     DPH,R5
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000035   12....       LCALL   ?Subroutine19 & 0xFFFF
   1717              *pBuf++ = pDev->age;
   \                     ??CrossCallReturnLabel_53:
   \   000038   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00003B   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   1718              *pBuf++ = pDev->linkInfo.txCounter;
   \                     ??CrossCallReturnLabel_55:
   \   00003E   A3           INC     DPTR
   \   00003F   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000042   12....       LCALL   ?Subroutine19 & 0xFFFF
   1719              *pBuf++ = pDev->linkInfo.txCost;
   \                     ??CrossCallReturnLabel_54:
   \   000045   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000048   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   1720              *pBuf++ = pDev->linkInfo.rxLqi;
   \                     ??CrossCallReturnLabel_56:
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00004F   A3           INC     DPTR
   \   000050   F0           MOVX    @DPTR,A
   1721              *pBuf++ = pDev->linkInfo.inKeySeqNum;
   \   000051   EC           MOV     A,R4
   \   000052   240B         ADD     A,#0xb
   \   000054   F582         MOV     DPL,A
   \   000056   E4           CLR     A
   \   000057   3D           ADDC    A,R5
   \   000058   F583         MOV     DPH,A
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   C0E0         PUSH    A
   \   00005D   EA           MOV     A,R2
   \   00005E   240B         ADD     A,#0xb
   \   000060   F582         MOV     DPL,A
   \   000062   E4           CLR     A
   \   000063   3B           ADDC    A,R3
   \   000064   F583         MOV     DPH,A
   \   000066   D0E0         POP     A
   \   000068   F0           MOVX    @DPTR,A
   1722              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
   \   000069   EC           MOV     A,R4
   \   00006A   240C         ADD     A,#0xc
   \   00006C   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00006F   78..         MOV     R0,#?V0
   \   000071   12....       LCALL   ?L_MOV_X
   \   000074   EA           MOV     A,R2
   \   000075   240C         ADD     A,#0xc
   \   000077   12....       LCALL   ?Subroutine14 & 0xFFFF
   1723              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
   \                     ??CrossCallReturnLabel_16:
   \   00007A   12....       LCALL   ?L_MOV_X
   \   00007D   E5..         MOV     A,?V1
   \   00007F   F5..         MOV     ?V0,A
   \   000081   EA           MOV     A,R2
   \   000082   240D         ADD     A,#0xd
   \   000084   12....       LCALL   ?Subroutine14 & 0xFFFF
   1724              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
   \                     ??CrossCallReturnLabel_17:
   \   000087   12....       LCALL   ?L_MOV_X
   \   00008A   7410         MOV     A,#0x10
   \   00008C   78..         MOV     R0,#?V0
   \   00008E   12....       LCALL   ?UL_SHR
   \   000091   EA           MOV     A,R2
   \   000092   240E         ADD     A,#0xe
   \   000094   12....       LCALL   ?Subroutine14 & 0xFFFF
   1725              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
   \                     ??CrossCallReturnLabel_18:
   \   000097   12....       LCALL   ?L_MOV_X
   \   00009A   7418         MOV     A,#0x18
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?UL_SHR
   \   0000A1   EA           MOV     A,R2
   \   0000A2   240F         ADD     A,#0xf
   \   0000A4   F582         MOV     DPL,A
   \   0000A6   E4           CLR     A
   \   0000A7   3B           ADDC    A,R3
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   E5..         MOV     A,?V0
   \   0000AC   F0           MOVX    @DPTR,A
   1726              *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
   \   0000AD   EC           MOV     A,R4
   \   0000AE   2410         ADD     A,#0x10
   \   0000B0   F8           MOV     R0,A
   \   0000B1   E4           CLR     A
   \   0000B2   3D           ADDC    A,R5
   \   0000B3   F9           MOV     R1,A
   \   0000B4   8882         MOV     DPL,R0
   \   0000B6   8983         MOV     DPH,R1
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   C0E0         PUSH    A
   \   0000BB   EA           MOV     A,R2
   \   0000BC   2410         ADD     A,#0x10
   \   0000BE   F582         MOV     DPL,A
   \   0000C0   E4           CLR     A
   \   0000C1   3B           ADDC    A,R3
   \   0000C2   F583         MOV     DPH,A
   \   0000C4   D0E0         POP     A
   \   0000C6   F0           MOVX    @DPTR,A
   1727              *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
   \   0000C7   8882         MOV     DPL,R0
   \   0000C9   8983         MOV     DPH,R1
   \   0000CB   A3           INC     DPTR
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   C0E0         PUSH    A
   \   0000CF   EA           MOV     A,R2
   \   0000D0   2411         ADD     A,#0x11
   \   0000D2   F582         MOV     DPL,A
   \   0000D4   E4           CLR     A
   \   0000D5   3B           ADDC    A,R3
   \   0000D6   F583         MOV     DPH,A
   \   0000D8   D0E0         POP     A
   \   0000DA   F0           MOVX    @DPTR,A
   \   0000DB   EA           MOV     A,R2
   \   0000DC   2412         ADD     A,#0x12
   1728            }
   1729          }
   \                     ??packDev_t_1:
   \   0000DE   02....       LJMP    ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine34_0
   \   000001                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   3B           ADDC    A,R3
   \   000004   F583         MOV     DPH,A
   \   000006   E5..         MOV     A,?V0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   78..         MOV     R0,#?V0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   3D           ADDC    A,R5
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   FE           MOV     R6,A
   \   000006   E9           MOV     A,R1
   \   000007   FF           MOV     R7,A
   \   000008   8E82         MOV     DPL,R6
   \   00000A   8F83         MOV     DPH,R7
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   8C82         MOV     DPL,R4
   \   000002   8D83         MOV     DPH,R5
   \   000004   E0           MOVX    A,@DPTR
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   8C82         MOV     DPL,R4
   \   00000C   8D83         MOV     DPH,R5
   \   00000E   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000011   F0           MOVX    @DPTR,A
   \   000012   EC           MOV     A,R4
   \   000013   2402         ADD     A,#0x2
   \   000015   F8           MOV     R0,A
   \   000016   E4           CLR     A
   \   000017   3D           ADDC    A,R5
   \   000018   F9           MOV     R1,A
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000020   A3           INC     DPTR
   \   000021   F0           MOVX    @DPTR,A
   \   000022   8882         MOV     DPL,R0
   \   000024   8983         MOV     DPH,R1
   \   000026   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   8C82         MOV     DPL,R4
   \   00002C   8D83         MOV     DPH,R5
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000034   A3           INC     DPTR
   \   000035   F0           MOVX    @DPTR,A
   \   000036   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine35_0
   \   000001                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   1730          
   1731          /***************************************************************************************************
   1732           * @fn      packBindEntry_t
   1733           *
   1734           * @brief   Pack a BindingEntry_t structure into a byte buffer (pack INVALID_NODE_ADDR
   1735           *          as dstIdx if the pBind parameter is NULL).
   1736           *
   1737           * @param   pBuf - pointer to the buffer into which to pack the structure.
   1738           * @param   pBind - pointer to the structure.
   1739           *
   1740           * @return  void
   1741           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1742          static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind)
   \                     packBindEntry_t:
   1743          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   1744            if ( NULL == pBind )
   \   000005   EC           MOV     A,R4
   \   000006   4D           ORL     A,R5
   \   000007   7021         JNZ     ??packBindEntry_t_0
   1745            {
   1746              uint16 rtrn = INVALID_NODE_ADDR;
   1747              *pBuf++ = 0xFF;
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   74FF         MOV     A,#-0x1
   \   00000F   F0           MOVX    @DPTR,A
   1748              *pBuf++ = 0xFF;
   \   000010   A3           INC     DPTR
   \   000011   F0           MOVX    @DPTR,A
   1749              *pBuf++ = LO_UINT16(rtrn);
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   14           DEC     A
   \   000019   12....       LCALL   ?Subroutine28 & 0xFFFF
   1750              *pBuf++ = HI_UINT16(rtrn);
   1751              *pBuf++ = 0xFF;
   1752              *pBuf++ = 0xFF;
   1753          
   1754            }
   \                     ??CrossCallReturnLabel_45:
   \   00001C   04           INC     A
   \   00001D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000020   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   \   000025   EA           MOV     A,R2
   \   000026   2406         ADD     A,#0x6
   \   000028   8037         SJMP    ??packBindEntry_t_1
   1755            else
   1756            {
   1757              *pBuf++ = pBind->srcEP;
   \                     ??packBindEntry_t_0:
   \   00002A   12....       LCALL   ?Subroutine6 & 0xFFFF
   1758              *pBuf++ = pBind->dstGroupMode;
   1759              *pBuf++ = LO_UINT16( pBind->dstIdx );
   1760              *pBuf++ = HI_UINT16( pBind->dstIdx );
   1761              *pBuf++ = pBind->dstEP;
   1762              *pBuf++ = pBind->numClusterIds;
   \                     ??CrossCallReturnLabel_1:
   \   00002D   EC           MOV     A,R4
   \   00002E   2405         ADD     A,#0x5
   \   000030   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000033   12....       LCALL   ?Subroutine12 & 0xFFFF
   1763          
   1764              osal_memcpy( pBuf, pBind->clusterIdList, pBind->numClusterIds * sizeof(uint16));
   \                     ??CrossCallReturnLabel_13:
   \   000036                ; Setup parameters for call to function osal_memcpy
   \   000036   EC           MOV     A,R4
   \   000037   2406         ADD     A,#0x6
   \   000039   F5..         MOV     ?V0,A
   \   00003B   E4           CLR     A
   \   00003C   3D           ADDC    A,R5
   \   00003D   F5..         MOV     ?V1,A
   \   00003F   75..00       MOV     ?V2,#0x0
   \   000042   78..         MOV     R0,#?V0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   25E0         ADD     A,0xE0 /* A   */
   \   00004E   FC           MOV     R4,A
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   FD           MOV     R5,A
   \   000052   EA           MOV     A,R2
   \   000053   2406         ADD     A,#0x6
   \   000055   FA           MOV     R2,A
   \   000056   5001         JNC     ??packBindEntry_t_2
   \   000058   0B           INC     R3
   \                     ??packBindEntry_t_2:
   \   000059   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00005C   7403         MOV     A,#0x3
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
   1765            }
   1766          }
   \                     ??packBindEntry_t_1:
   \   000061   7F03         MOV     R7,#0x3
   \   000063   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   A982         MOV     R1,DPL
   \   000005   AA83         MOV     R2,DPH
   \   000007   89..         MOV     ?V4,R1
   \   000009   8A..         MOV     ?V5,R2
   \   00000B   75..00       MOV     ?V6,#0x0
   \   00000E   78..         MOV     R0,#?V4
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008                ; Setup parameters for call to function AssocFindDevice
   \   000008                ; Setup parameters for call to function osal_memcpy
   \   000008                ; Setup parameters for call to function osal_memcpy
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   22           RET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilCommandProcessing::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilCommandProcessing

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGetDeviceInfo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGetDeviceInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGetNvInfo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGetNvInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSetPanID::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSetPanID

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSetChannels::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSetChannels

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSetSecLevel::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSetSecLevel

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSetPreCfgKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSetPreCfgKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilCallbackSub::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilCallbackSub

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilTimeAlive::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilTimeAlive

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchEnable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchEnable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchAddEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchAddEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchDeleteEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchDeleteEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchCheckSrcAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchCheckSrcAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchAckAllPending::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchAckAllPending

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilSrcMatchCheckAllPending::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilSrcMatchCheckAllPending

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGpioRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGpioRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGpioSetDirection::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGpioSetDirection

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGpioWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGpioWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilDataReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilDataReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilBindAddEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilBindAddEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??packDev_t::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    packDev_t

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??packBindEntry_t::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    packBindEntry_t
   1767          
   1768          #if defined ZCL_KEY_ESTABLISH
   1769          /***************************************************************************************************
   1770           * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
   1771           *
   1772           * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
   1773           *
   1774           * @param   pBuf - pointer to the received buffer
   1775           *
   1776           * @return  void
   1777           ***************************************************************************************************/
   1778          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
   1779          {
   1780            afAddrType_t partnerAddr;
   1781            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1782            pBuf += MT_RPC_FRAME_HDR_SZ;
   1783          
   1784            partnerAddr.panId = 0;  // Not an inter-pan message.
   1785            partnerAddr.endPoint = pBuf[2];
   1786            partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
   1787            if (afAddr64Bit == partnerAddr.addrMode)
   1788            {
   1789              (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
   1790            }
   1791            else
   1792            {
   1793              partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
   1794            }
   1795          
   1796            zcl_key_establish_task_id = pBuf[0];
   1797            *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
   1798            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1799          }
   1800          
   1801          /***************************************************************************************************
   1802           * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
   1803           *
   1804           * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
   1805           *
   1806           * @param   pBuf - pointer to the received buffer
   1807           *
   1808           * @return  void
   1809           ***************************************************************************************************/
   1810          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
   1811          {
   1812          #if defined TC_LINKKEY_JOIN
   1813            uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
   1814            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1815            pBuf += MT_RPC_FRAME_HDR_SZ;
   1816          
   1817            if (NULL == output)
   1818            {
   1819              *pBuf = FAILURE;
   1820              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1821            }
   1822            else
   1823            {
   1824              *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
   1825              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1826                                                   SE_PROFILE_SIGNATURE_LENGTH+1, output);
   1827              osal_mem_free(output);
   1828            }
   1829          #endif
   1830          }
   1831          
   1832          /***************************************************************************************************
   1833           * @fn      MT_UtilKeyEstablishInd
   1834           *
   1835           * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
   1836           *
   1837           * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
   1838           *
   1839           * @return  None
   1840           ***************************************************************************************************/
   1841          void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
   1842          {
   1843            uint8 msg[6];
   1844          
   1845            msg[0] = zcl_key_establish_task_id;
   1846            msg[1] = pInd->hdr.event;
   1847            msg[2] = pInd->hdr.status;
   1848            msg[3] = pInd->waitTime;
   1849            msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
   1850            msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
   1851          
   1852            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
   1853                                                 MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
   1854          }
   1855          #endif
   1856          
   1857          /***************************************************************************************************
   1858           * @fn      MT_UtilSync
   1859           *
   1860           * @brief   Process the MT_UTIL_SYNC command
   1861           *
   1862           * @param   None
   1863           *
   1864           * @return  None
   1865           ***************************************************************************************************/
   1866          static void MT_UtilSync(void)
   1867          {
   1868           MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
   1869          }
   1870          #endif /* !defined NONWK */
   1871          #endif /* MT_UTIL_FUNC */
   1872          /**************************************************************************************************
   1873           **************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    106   MT_UtilBindAddEntry
        0     42   -> MT_BuildAndSendZToolResponse
        0     44   -> bindAddEntry
        0     42   -> osal_mem_alloc
        0     42   -> osal_mem_free
        0     45   -> osal_memcpy
        0     42   -> osal_memset
        0     42   -> packBindEntry_t
        0     42   -> sAddrExtCpy
      0     71   MT_UtilCallbackSub
        0     10   -> MT_BuildAndSendZToolResponse
      1     64   MT_UtilCommandProcessing
        0     61   -> AddrMgrEntryLookupExt
        0     61   -> AddrMgrEntryLookupNwk
        0     61   -> AddrMgrExtAddrValid
        0     61   -> AssocCount
        0     61   -> AssocFindDevice
        0     61   -> AssocGetWithAddress
        0     61   -> MT_BuildAndSendZToolResponse
        0     61   -> MT_UtilBindAddEntry
        0     61   -> MT_UtilCallbackSub
        0     61   -> MT_UtilDataReq
        0     61   -> MT_UtilGetDeviceInfo
        0     61   -> MT_UtilGetNvInfo
        0     61   -> MT_UtilGpioRead
        0     61   -> MT_UtilGpioSetDirection
        0     61   -> MT_UtilGpioWrite
        0     61   -> MT_UtilSetChannels
        0     61   -> MT_UtilSetPanID
        0     61   -> MT_UtilSetPreCfgKey
        0     61   -> MT_UtilSetSecLevel
        0     61   -> MT_UtilSrcMatchAckAllPending
        0     61   -> MT_UtilSrcMatchAddEntry
        0     61   -> MT_UtilSrcMatchCheckAllPending
        0     61   -> MT_UtilSrcMatchCheckSrcAddr
        0     61   -> MT_UtilSrcMatchDeleteEntry
        0     61   -> MT_UtilSrcMatchEnable
        0     61   -> MT_UtilTimeAlive
        0     61   -> ZDSecMgrRequestAppKey
        0     64   -> osal_memcpy
        0     61   -> packDev_t
      3     62   MT_UtilDataReq
        2      1   -> MT_BuildAndSendZToolResponse
        2      1   -> NwkPollReq
      1     82   MT_UtilGetDeviceInfo
        0     17   -> AssocMakeList
        0     17   -> MT_BuildAndSendZToolResponse
        0     17   -> NLME_GetShortAddr
        0     17   -> osal_mem_alloc
        0     17   -> osal_mem_free
        0     21   -> osal_nv_read
      1     87   MT_UtilGetNvInfo
        0     22   -> MT_BuildAndSendZToolResponse
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> osal_memset
        0     26   -> osal_nv_read
      3     67   MT_UtilGpioRead
        2      6   -> MT_BuildAndSendZToolResponse
      1     77   MT_UtilGpioSetDirection
        0     16   -> MT_BuildAndSendZToolResponse
      1     80   MT_UtilGpioWrite
        0     19   -> MT_BuildAndSendZToolResponse
      1     86   MT_UtilSetChannels
        0     21   -> MT_BuildAndSendZToolResponse
        0     21   -> osal_nv_item_len
        0     25   -> osal_nv_write
      1     80   MT_UtilSetPanID
        0     15   -> MT_BuildAndSendZToolResponse
        0     15   -> osal_nv_item_len
        0     19   -> osal_nv_write
      1     80   MT_UtilSetPreCfgKey
        0     15   -> MT_BuildAndSendZToolResponse
        0     15   -> osal_nv_item_len
        0     19   -> osal_nv_write
      1     80   MT_UtilSetSecLevel
        0     15   -> MT_BuildAndSendZToolResponse
        0     15   -> osal_nv_item_len
        0     19   -> osal_nv_write
      2     62   MT_UtilSrcMatchAckAllPending
        2      1   -> MT_BuildAndSendZToolResponse
      2     62   MT_UtilSrcMatchAddEntry
        2      1   -> MT_BuildAndSendZToolResponse
      2     63   MT_UtilSrcMatchCheckAllPending
        2      2   -> MT_BuildAndSendZToolResponse
      2     63   MT_UtilSrcMatchCheckSrcAddr
        2      2   -> MT_BuildAndSendZToolResponse
      2     62   MT_UtilSrcMatchDeleteEntry
        2      1   -> MT_BuildAndSendZToolResponse
      2     62   MT_UtilSrcMatchEnable
        2      1   -> MT_BuildAndSendZToolResponse
      1     81   MT_UtilTimeAlive
        0     20   -> MT_BuildAndSendZToolResponse
        0     20   -> osal_GetSystemClock
      1     56   packBindEntry_t
        0     14   -> osal_memcpy
      1     73   packDev_t


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>
       6  ?<Constant {0, 0, 0, 0, 0, 0}>
       8  ??Subroutine31_0
       7  ??Subroutine32_0
      10  ??Subroutine33_0
       6  ??Subroutine34_0
       7  ??Subroutine35_0
       8  ?Subroutine0
       5  ?Subroutine1
       7  ?Subroutine10
       4  ?Subroutine11
       5  ?Subroutine12
      16  ?Subroutine13
      16  ?Subroutine14
      17  ?Subroutine15
      19  ?Subroutine16
       7  ?Subroutine17
       6  ?Subroutine18
       1  ?Subroutine19
      30  ?Subroutine2
       5  ?Subroutine20
      13  ?Subroutine21
      12  ?Subroutine22
      13  ?Subroutine23
      17  ?Subroutine24
       4  ?Subroutine25
      16  ?Subroutine26
       6  ?Subroutine27
       9  ?Subroutine28
      11  ?Subroutine29
      15  ?Subroutine3
       1  ?Subroutine30
       8  ?Subroutine4
      15  ?Subroutine5
      55  ?Subroutine6
      17  ?Subroutine7
      26  ?Subroutine8
       8  ?Subroutine9
     282  MT_UtilBindAddEntry
       6  MT_UtilBindAddEntry::?relay
     187  MT_UtilCallbackSub
       6  MT_UtilCallbackSub::?relay
     733  MT_UtilCommandProcessing
       6  MT_UtilCommandProcessing::?relay
      28  MT_UtilDataReq
       6  MT_UtilDataReq::?relay
     330  MT_UtilGetDeviceInfo
       6  MT_UtilGetDeviceInfo::?relay
     476  MT_UtilGetNvInfo
       6  MT_UtilGetNvInfo::?relay
      94  MT_UtilGpioRead
       6  MT_UtilGpioRead::?relay
     239  MT_UtilGpioSetDirection
       6  MT_UtilGpioSetDirection::?relay
     278  MT_UtilGpioWrite
       6  MT_UtilGpioWrite::?relay
     181  MT_UtilSetChannels
       6  MT_UtilSetChannels::?relay
     103  MT_UtilSetPanID
       6  MT_UtilSetPanID::?relay
      49  MT_UtilSetPreCfgKey
       6  MT_UtilSetPreCfgKey::?relay
      47  MT_UtilSetSecLevel
       6  MT_UtilSetSecLevel::?relay
       3  MT_UtilSrcMatchAckAllPending
       6  MT_UtilSrcMatchAckAllPending::?relay
       3  MT_UtilSrcMatchAddEntry
       6  MT_UtilSrcMatchAddEntry::?relay
      18  MT_UtilSrcMatchCheckAllPending
       6  MT_UtilSrcMatchCheckAllPending::?relay
      17  MT_UtilSrcMatchCheckSrcAddr
       6  MT_UtilSrcMatchCheckSrcAddr::?relay
       3  MT_UtilSrcMatchDeleteEntry
       6  MT_UtilSrcMatchDeleteEntry::?relay
       3  MT_UtilSrcMatchEnable
       6  MT_UtilSrcMatchEnable::?relay
     115  MT_UtilTimeAlive
       6  MT_UtilTimeAlive::?relay
       1  P0DIR
       1  P1DIR
       1  P2DIR
       1  _A_P0
       1  _A_P1
       1  _A_P2
       4  __Constant_3e8
     102  packBindEntry_t
       6  packBindEntry_t::?relay
     225  packDev_t
       6  packDev_t::?relay

 
 3 946 bytes in segment BANKED_CODE
   132 bytes in segment BANK_RELAYS
     6 bytes in segment SFR_AN
    19 bytes in segment XDATA_ROM_C
 
 4 078 bytes of CODE  memory
    15 bytes of CONST memory (+ 4 bytes shared)
     0 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: none
